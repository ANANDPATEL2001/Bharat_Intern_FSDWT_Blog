/*! For license information please see main.8f581b25.js.LICENSE.txt */
(() => { "use strict"; var e = { 463: (e, t, n) => { var r = n(791), i = n(296); function s(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var o = new Set, a = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (a[e] = t, e = 0; e < t.length; e++)o.add(t[e]) } var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), h = Object.prototype.hasOwnProperty, d = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, p = {}; function m(e, t, n, r, i, s, o) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var y = /[\-:]([a-z])/g; function v(e) { return e[1].toUpperCase() } function w(e, t, n, r) { var i = g.hasOwnProperty(t) ? g[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null === t || "undefined" === typeof t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!h.call(p, e) || !h.call(f, e) && (d.test(e) ? p[e] = !0 : (f[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(y, v); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(y, v); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(y, v); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var b = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, E = Symbol.for("react.element"), S = Symbol.for("react.portal"), _ = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), I = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), k = Symbol.for("react.context"), C = Symbol.for("react.forward_ref"), N = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), A = Symbol.for("react.memo"), O = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var R = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var P = Symbol.iterator; function L(e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = P && e[P] || e["@@iterator"]) ? e : null } var F, M = Object.assign; function j(e) { if (void 0 === F) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); F = t && t[1] || "" } return "\n" + F + e } var V = !1; function B(e, t) { if (!e || V) return ""; V = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" === typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) { if (c && r && "string" === typeof c.stack) { for (var i = c.stack.split("\n"), s = r.stack.split("\n"), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (i[o] !== s[a]) { if (1 !== o || 1 !== a) do { if (o--, 0 > --a || i[o] !== s[a]) { var l = "\n" + i[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= o && 0 <= a); break } } } finally { V = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? j(e) : "" } function U(e) { switch (e.tag) { case 5: return j(e.type); case 16: return j("Lazy"); case 13: return j("Suspense"); case 19: return j("SuspenseList"); case 0: case 2: case 15: return e = B(e.type, !1); case 11: return e = B(e.type.render, !1); case 1: return e = B(e.type, !0); default: return "" } } function z(e) { if (null == e) return null; if ("function" === typeof e) return e.displayName || e.name || null; if ("string" === typeof e) return e; switch (e) { case _: return "Fragment"; case S: return "Portal"; case I: return "Profiler"; case x: return "StrictMode"; case N: return "Suspense"; case D: return "SuspenseList" }if ("object" === typeof e) switch (e.$$typeof) { case k: return (e.displayName || "Context") + ".Consumer"; case T: return (e._context.displayName || "Context") + ".Provider"; case C: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case A: return null !== (t = e.displayName || null) ? t : z(e.type) || "Memo"; case O: t = e._payload, e = e._init; try { return z(e(t)) } catch (n) { } }return null } function q(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return z(t); case 8: return t === x ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" === typeof t) return t.displayName || t.name || null; if ("string" === typeof t) return t }return null } function K(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function G(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function H(e) { e._valueTracker || (e._valueTracker = function (e) { var t = G(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) { var i = n.get, s = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, s.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function Q(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = G(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function W(e) { if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function $(e, t) { var n = t.checked; return M({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function X(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = K(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function Y(e, t) { null != (t = t.checked) && w(e, "checked", t, !1) } function J(e, t) { Y(e, t); var n = K(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, K(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function Z(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && W(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + K(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(s(91)); return M({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(s(92)); if (te(n)) { if (1 < n.length) throw Error(s(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: K(n) } } function se(e, t) { var n = K(t.value), r = K(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function oe(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function ae(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? ae(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, he = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function de(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var fe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = me(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(fe).forEach((function (e) { pe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e] })) })); var ye = M({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ve(e, t) { if (t) { if (ye[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(s(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(s(60)); if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(s(61)) } if (null != t.style && "object" !== typeof t.style) throw Error(s(62)) } } function we(e, t) { if (-1 === e.indexOf("-")) return "string" === typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var be = null; function Ee(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var Se = null, _e = null, xe = null; function Ie(e) { if (e = wi(e)) { if ("function" !== typeof Se) throw Error(s(280)); var t = e.stateNode; t && (t = Ei(t), Se(e.stateNode, e.type, t)) } } function Te(e) { _e ? xe ? xe.push(e) : xe = [e] : _e = e } function ke() { if (_e) { var e = _e, t = xe; if (xe = _e = null, Ie(e), t) for (e = 0; e < t.length; e++)Ie(t[e]) } } function Ce(e, t) { return e(t) } function Ne() { } var De = !1; function Ae(e, t, n) { if (De) return e(t, n); De = !0; try { return Ce(e, t, n) } finally { De = !1, (null !== _e || null !== xe) && (Ne(), ke()) } } function Oe(e, t) { var n = e.stateNode; if (null === n) return null; var r = Ei(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" !== typeof n) throw Error(s(231, t, typeof n)); return n } var Re = !1; if (u) try { var Pe = {}; Object.defineProperty(Pe, "passive", { get: function () { Re = !0 } }), window.addEventListener("test", Pe, Pe), window.removeEventListener("test", Pe, Pe) } catch (ue) { Re = !1 } function Le(e, t, n, r, i, s, o, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var Fe = !1, Me = null, je = !1, Ve = null, Be = { onError: function (e) { Fe = !0, Me = e } }; function Ue(e, t, n, r, i, s, o, a, l) { Fe = !1, Me = null, Le.apply(Be, arguments) } function ze(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function qe(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated } return null } function Ke(e) { if (ze(e) !== e) throw Error(s(188)) } function Ge(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = ze(e))) throw Error(s(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var o = i.alternate; if (null === o) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return Ke(i), e; if (o === r) return Ke(i), t; o = o.sibling } throw Error(s(188)) } if (n.return !== r.return) n = i, r = o; else { for (var a = !1, l = i.child; l;) { if (l === n) { a = !0, n = i, r = o; break } if (l === r) { a = !0, r = i, n = o; break } l = l.sibling } if (!a) { for (l = o.child; l;) { if (l === n) { a = !0, n = o, r = i; break } if (l === r) { a = !0, r = o, n = i; break } l = l.sibling } if (!a) throw Error(s(189)) } } if (n.alternate !== r) throw Error(s(190)) } if (3 !== n.tag) throw Error(s(188)); return n.stateNode.current === n ? e : t }(e)) ? He(e) : null } function He(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = He(e); if (null !== t) return t; e = e.sibling } return null } var Qe = i.unstable_scheduleCallback, We = i.unstable_cancelCallback, $e = i.unstable_shouldYield, Xe = i.unstable_requestPaint, Ye = i.unstable_now, Je = i.unstable_getCurrentPriorityLevel, Ze = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, st = null; var ot = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, 0 === e ? 32 : 31 - (at(e) / lt | 0) | 0 }, at = Math.log, lt = Math.LN2; var ct = 64, ut = 4194304; function ht(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function dt(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, s = e.pingedLanes, o = 268435455 & n; if (0 !== o) { var a = o & ~i; 0 !== a ? r = ht(a) : 0 !== (s &= o) && (r = ht(s)) } else 0 !== (o = n & ~i) ? r = ht(o) : 0 !== s && (r = ht(s)); if (0 === r) return 0; if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (s = t & -t) || 16 === i && 0 !== (4194240 & s))) return t; if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - ot(t)), r |= e[n], t &= ~i; return r } function ft(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function pt(e) { return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function yt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - ot(t)] = n } function vt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - ot(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var wt = 0; function bt(e) { return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1 } var Et, St, _t, xt, It, Tt = !1, kt = [], Ct = null, Nt = null, Dt = null, At = new Map, Ot = new Map, Rt = [], Pt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Lt(e, t) { switch (e) { case "focusin": case "focusout": Ct = null; break; case "dragenter": case "dragleave": Nt = null; break; case "mouseover": case "mouseout": Dt = null; break; case "pointerover": case "pointerout": At.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ot.delete(t.pointerId) } } function Ft(e, t, n, r, i, s) { return null === e || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, null !== t && (null !== (t = wi(t)) && St(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function Mt(e) { var t = vi(e.target); if (null !== t) { var n = ze(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = qe(n))) return e.blockedOn = t, void It(e.priority, (function () { _t(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function jt(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = $t(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = wi(n)) && St(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); be = r, n.target.dispatchEvent(r), be = null, t.shift() } return !0 } function Vt(e, t, n) { jt(e) && n.delete(t) } function Bt() { Tt = !1, null !== Ct && jt(Ct) && (Ct = null), null !== Nt && jt(Nt) && (Nt = null), null !== Dt && jt(Dt) && (Dt = null), At.forEach(Vt), Ot.forEach(Vt) } function Ut(e, t) { e.blockedOn === t && (e.blockedOn = null, Tt || (Tt = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Bt))) } function zt(e) { function t(t) { return Ut(t, e) } if (0 < kt.length) { Ut(kt[0], e); for (var n = 1; n < kt.length; n++) { var r = kt[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== Ct && Ut(Ct, e), null !== Nt && Ut(Nt, e), null !== Dt && Ut(Dt, e), At.forEach(t), Ot.forEach(t), n = 0; n < Rt.length; n++)(r = Rt[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Rt.length && null === (n = Rt[0]).blockedOn;)Mt(n), null === n.blockedOn && Rt.shift() } var qt = b.ReactCurrentBatchConfig, Kt = !0; function Gt(e, t, n, r) { var i = wt, s = qt.transition; qt.transition = null; try { wt = 1, Qt(e, t, n, r) } finally { wt = i, qt.transition = s } } function Ht(e, t, n, r) { var i = wt, s = qt.transition; qt.transition = null; try { wt = 4, Qt(e, t, n, r) } finally { wt = i, qt.transition = s } } function Qt(e, t, n, r) { if (Kt) { var i = $t(e, t, n, r); if (null === i) Kr(e, t, r, Wt, n), Lt(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return Ct = Ft(Ct, e, t, n, r, i), !0; case "dragenter": return Nt = Ft(Nt, e, t, n, r, i), !0; case "mouseover": return Dt = Ft(Dt, e, t, n, r, i), !0; case "pointerover": var s = i.pointerId; return At.set(s, Ft(At.get(s) || null, e, t, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, Ot.set(s, Ft(Ot.get(s) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (Lt(e, r), 4 & t && -1 < Pt.indexOf(e)) { for (; null !== i;) { var s = wi(i); if (null !== s && Et(s), null === (s = $t(e, t, n, r)) && Kr(e, t, r, Wt, n), s === i) break; i = s } null !== i && r.stopPropagation() } else Kr(e, t, r, null, n) } } var Wt = null; function $t(e, t, n, r) { if (Wt = null, null !== (e = vi(e = Ee(r)))) if (null === (t = ze(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = qe(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Wt = e, null } function Xt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Je()) { case Ze: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var Yt = null, Jt = null, Zt = null; function en() { if (Zt) return Zt; var e, t, n = Jt, r = n.length, i = "value" in Yt ? Yt.value : Yt.textContent, s = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var o = r - e; for (t = 1; t <= o && n[r - t] === i[s - t]; t++); return Zt = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function sn(e) { function t(t, n, r, i, s) { for (var o in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = s, this.currentTarget = null, e) e.hasOwnProperty(o) && (t = e[o], this[o] = t ? t(i) : i[o]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return M(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var on, an, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = sn(cn), hn = M({}, cn, { view: 0, detail: 0 }), dn = sn(hn), fn = M({}, hn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: In, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (on = e.screenX - ln.screenX, an = e.screenY - ln.screenY) : an = on = 0, ln = e), on) }, movementY: function (e) { return "movementY" in e ? e.movementY : an } }), pn = sn(fn), mn = sn(M({}, fn, { dataTransfer: 0 })), gn = sn(M({}, hn, { relatedTarget: 0 })), yn = sn(M({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), vn = M({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), wn = sn(vn), bn = sn(M({}, cn, { data: 0 })), En = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Sn = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, _n = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function xn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = _n[e]) && !!t[e] } function In() { return xn } var Tn = M({}, hn, { key: function (e) { if (e.key) { var t = En[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Sn[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: In, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), kn = sn(Tn), Cn = sn(M({}, fn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Nn = sn(M({}, hn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: In })), Dn = sn(M({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), An = M({}, fn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), On = sn(An), Rn = [9, 13, 27, 32], Pn = u && "CompositionEvent" in window, Ln = null; u && "documentMode" in document && (Ln = document.documentMode); var Fn = u && "TextEvent" in window && !Ln, Mn = u && (!Pn || Ln && 8 < Ln && 11 >= Ln), jn = String.fromCharCode(32), Vn = !1; function Bn(e, t) { switch (e) { case "keyup": return -1 !== Rn.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Un(e) { return "object" === typeof (e = e.detail) && "data" in e ? e.data : null } var zn = !1; var qn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Kn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!qn[e.type] : "textarea" === t } function Gn(e, t, n, r) { Te(r), 0 < (t = Hr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Hn = null, Qn = null; function Wn(e) { jr(e, 0) } function $n(e) { if (Q(bi(e))) return e } function Xn(e, t) { if ("change" === e) return t } var Yn = !1; if (u) { var Jn; if (u) { var Zn = "oninput" in document; if (!Zn) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), Zn = "function" === typeof er.oninput } Jn = Zn } else Jn = !1; Yn = Jn && (!document.documentMode || 9 < document.documentMode) } function tr() { Hn && (Hn.detachEvent("onpropertychange", nr), Qn = Hn = null) } function nr(e) { if ("value" === e.propertyName && $n(Qn)) { var t = []; Gn(t, Qn, e, Ee(e)), Ae(Wn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), Qn = n, (Hn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return $n(Qn) } function sr(e, t) { if ("click" === e) return $n(t) } function or(e, t) { if ("input" === e || "change" === e) return $n(t) } var ar = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }; function lr(e, t) { if (ar(e, t)) return !0; if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!h.call(t, i) || !ar(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function hr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? hr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function dr() { for (var e = window, t = W(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" === typeof t.contentWindow.location.href } catch (r) { n = !1 } if (!n) break; t = W((e = t.contentWindow).document) } return t } function fr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function pr(e) { var t = dr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && hr(n.ownerDocument.documentElement, n)) { if (null !== r && fr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = void 0 === r.end ? s : Math.min(r.end, i), !e.extend && s > r && (i = r, r = s, s = i), i = ur(n, s); var o = ur(n, r); i && o && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), s > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, yr = null, vr = null, wr = !1; function br(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; wr || null == gr || gr !== W(r) || ("selectionStart" in (r = gr) && fr(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : r = { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, vr && lr(vr, r) || (vr = r, 0 < (r = Hr(yr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = gr))) } function Er(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Sr = { animationend: Er("Animation", "AnimationEnd"), animationiteration: Er("Animation", "AnimationIteration"), animationstart: Er("Animation", "AnimationStart"), transitionend: Er("Transition", "TransitionEnd") }, _r = {}, xr = {}; function Ir(e) { if (_r[e]) return _r[e]; if (!Sr[e]) return e; var t, n = Sr[e]; for (t in n) if (n.hasOwnProperty(t) && t in xr) return _r[e] = n[t]; return e } u && (xr = document.createElement("div").style, "AnimationEvent" in window || (delete Sr.animationend.animation, delete Sr.animationiteration.animation, delete Sr.animationstart.animation), "TransitionEvent" in window || delete Sr.transitionend.transition); var Tr = Ir("animationend"), kr = Ir("animationiteration"), Cr = Ir("animationstart"), Nr = Ir("transitionend"), Dr = new Map, Ar = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Or(e, t) { Dr.set(e, t), l(t, [e]) } for (var Rr = 0; Rr < Ar.length; Rr++) { var Pr = Ar[Rr]; Or(Pr.toLowerCase(), "on" + (Pr[0].toUpperCase() + Pr.slice(1))) } Or(Tr, "onAnimationEnd"), Or(kr, "onAnimationIteration"), Or(Cr, "onAnimationStart"), Or("dblclick", "onDoubleClick"), Or("focusin", "onFocus"), Or("focusout", "onBlur"), Or(Nr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Lr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Fr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Lr)); function Mr(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, o, a, l, c) { if (Ue.apply(this, arguments), Fe) { if (!Fe) throw Error(s(198)); var u = Me; Fe = !1, Me = null, je || (je = !0, Ve = u) } }(r, t, void 0, e), e.currentTarget = null } function jr(e, t) { t = 0 !== (4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var s = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== s && i.isPropagationStopped()) break e; Mr(i, a, c), s = l } else for (o = 0; o < r.length; o++) { if (l = (a = r[o]).instance, c = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e; Mr(i, a, c), s = l } } } if (je) throw e = Ve, je = !1, Ve = null, e } function Vr(e, t) { var n = t[mi]; void 0 === n && (n = t[mi] = new Set); var r = e + "__bubble"; n.has(r) || (qr(t, e, 2, !1), n.add(r)) } function Br(e, t, n) { var r = 0; t && (r |= 4), qr(n, e, r, t) } var Ur = "_reactListening" + Math.random().toString(36).slice(2); function zr(e) { if (!e[Ur]) { e[Ur] = !0, o.forEach((function (t) { "selectionchange" !== t && (Fr.has(t) || Br(t, !1, e), Br(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Ur] || (t[Ur] = !0, Br("selectionchange", !1, t)) } } function qr(e, t, n, r) { switch (Xt(t)) { case 1: var i = Gt; break; case 4: i = Ht; break; default: i = Qt }n = i.bind(null, t, n, e), i = void 0, !Re || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Kr(e, t, n, r, i) { var s = r; if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (; ;) { if (null === r) return; var o = r.tag; if (3 === o || 4 === o) { var a = r.stateNode.containerInfo; if (a === i || 8 === a.nodeType && a.parentNode === i) break; if (4 === o) for (o = r.return; null !== o;) { var l = o.tag; if ((3 === l || 4 === l) && ((l = o.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; o = o.return } for (; null !== a;) { if (null === (o = vi(a))) return; if (5 === (l = o.tag) || 6 === l) { r = s = o; continue e } a = a.parentNode } } r = r.return } Ae((function () { var r = s, i = Ee(n), o = []; e: { var a = Dr.get(e); if (void 0 !== a) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = kn; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = pn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = Nn; break; case Tr: case kr: case Cr: l = yn; break; case Nr: l = Dn; break; case "scroll": l = dn; break; case "wheel": l = On; break; case "copy": case "cut": case "paste": l = wn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = Cn }var u = 0 !== (4 & t), h = !u && "scroll" === e, d = u ? null !== a ? a + "Capture" : null : a; u = []; for (var f, p = r; null !== p;) { var m = (f = p).stateNode; if (5 === f.tag && null !== m && (f = m, null !== d && (null != (m = Oe(p, d)) && u.push(Gr(p, m, f)))), h) break; p = p.return } 0 < u.length && (a = new l(a, c, null, n, i), o.push({ event: a, listeners: u })) } } if (0 === (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(a = "mouseover" === e || "pointerover" === e) || n === be || !(c = n.relatedTarget || n.fromElement) || !vi(c) && !c[pi]) && (l || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? vi(c) : null) && (c !== (h = ze(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = pn, m = "onMouseLeave", d = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Cn, m = "onPointerLeave", d = "onPointerEnter", p = "pointer"), h = null == l ? a : bi(l), f = null == c ? a : bi(c), (a = new u(m, p + "leave", l, n, i)).target = h, a.relatedTarget = f, m = null, vi(i) === r && ((u = new u(d, p + "enter", c, n, i)).target = f, u.relatedTarget = h, m = u), h = m, l && c) e: { for (d = c, p = 0, f = u = l; f; f = Qr(f))p++; for (f = 0, m = d; m; m = Qr(m))f++; for (; 0 < p - f;)u = Qr(u), p--; for (; 0 < f - p;)d = Qr(d), f--; for (; p--;) { if (u === d || null !== d && u === d.alternate) break e; u = Qr(u), d = Qr(d) } u = null } else u = null; null !== l && Wr(o, a, l, u, !1), null !== c && null !== h && Wr(o, h, c, u, !0) } if ("select" === (l = (a = r ? bi(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type) var g = Xn; else if (Kn(a)) if (Yn) g = or; else { g = ir; var y = rr } else (l = a.nodeName) && "input" === l.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = sr); switch (g && (g = g(e, r)) ? Gn(o, g, n, i) : (y && y(e, a, r), "focusout" === e && (y = a._wrapperState) && y.controlled && "number" === a.type && ee(a, "number", a.value)), y = r ? bi(r) : window, e) { case "focusin": (Kn(y) || "true" === y.contentEditable) && (gr = y, yr = r, vr = null); break; case "focusout": vr = yr = gr = null; break; case "mousedown": wr = !0; break; case "contextmenu": case "mouseup": case "dragend": wr = !1, br(o, n, i); break; case "selectionchange": if (mr) break; case "keydown": case "keyup": br(o, n, i) }var v; if (Pn) e: { switch (e) { case "compositionstart": var w = "onCompositionStart"; break e; case "compositionend": w = "onCompositionEnd"; break e; case "compositionupdate": w = "onCompositionUpdate"; break e }w = void 0 } else zn ? Bn(e, n) && (w = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (w = "onCompositionStart"); w && (Mn && "ko" !== n.locale && (zn || "onCompositionStart" !== w ? "onCompositionEnd" === w && zn && (v = en()) : (Jt = "value" in (Yt = i) ? Yt.value : Yt.textContent, zn = !0)), 0 < (y = Hr(r, w)).length && (w = new bn(w, e, null, n, i), o.push({ event: w, listeners: y }), v ? w.data = v : null !== (v = Un(n)) && (w.data = v))), (v = Fn ? function (e, t) { switch (e) { case "compositionend": return Un(t); case "keypress": return 32 !== t.which ? null : (Vn = !0, jn); case "textInput": return (e = t.data) === jn && Vn ? null : e; default: return null } }(e, n) : function (e, t) { if (zn) return "compositionend" === e || !Pn && Bn(e, t) ? (e = en(), Zt = Jt = Yt = null, zn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Mn && "ko" !== t.locale ? null : t.data } }(e, n)) && (0 < (r = Hr(r, "onBeforeInput")).length && (i = new bn("onBeforeInput", "beforeinput", null, n, i), o.push({ event: i, listeners: r }), i.data = v)) } jr(o, t) })) } function Gr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Hr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, s = i.stateNode; 5 === i.tag && null !== s && (i = s, null != (s = Oe(e, n)) && r.unshift(Gr(e, s, i)), null != (s = Oe(e, t)) && r.push(Gr(e, s, i))), e = e.return } return r } function Qr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Wr(e, t, n, r, i) { for (var s = t._reactName, o = []; null !== n && n !== r;) { var a = n, l = a.alternate, c = a.stateNode; if (null !== l && l === r) break; 5 === a.tag && null !== c && (a = c, i ? null != (l = Oe(n, s)) && o.unshift(Gr(n, l, a)) : i || null != (l = Oe(n, s)) && o.push(Gr(n, l, a))), n = n.return } 0 !== o.length && e.push({ event: t, listeners: o }) } var $r = /\r\n?/g, Xr = /\u0000|\uFFFD/g; function Yr(e) { return ("string" === typeof e ? e : "" + e).replace($r, "\n").replace(Xr, "") } function Jr(e, t, n) { if (t = Yr(t), Yr(e) !== t && n) throw Error(s(425)) } function Zr() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" === typeof setTimeout ? setTimeout : void 0, ii = "function" === typeof clearTimeout ? clearTimeout : void 0, si = "function" === typeof Promise ? Promise : void 0, oi = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof si ? function (e) { return si.resolve(null).then(e).catch(ai) } : ri; function ai(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void zt(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); zt(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var hi = Math.random().toString(36).slice(2), di = "__reactFiber$" + hi, fi = "__reactProps$" + hi, pi = "__reactContainer$" + hi, mi = "__reactEvents$" + hi, gi = "__reactListeners$" + hi, yi = "__reactHandles$" + hi; function vi(e) { var t = e[di]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[pi] || n[di]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[di]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function wi(e) { return !(e = e[di] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function bi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(s(33)) } function Ei(e) { return e[fi] || null } var Si = [], _i = -1; function xi(e) { return { current: e } } function Ii(e) { 0 > _i || (e.current = Si[_i], Si[_i] = null, _i--) } function Ti(e, t) { _i++, Si[_i] = e.current, e.current = t } var ki = {}, Ci = xi(ki), Ni = xi(!1), Di = ki; function Ai(e, t) { var n = e.type.contextTypes; if (!n) return ki; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, s = {}; for (i in n) s[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = s), s } function Oi(e) { return null !== (e = e.childContextTypes) && void 0 !== e } function Ri() { Ii(Ni), Ii(Ci) } function Pi(e, t, n) { if (Ci.current !== ki) throw Error(s(168)); Ti(Ci, t), Ti(Ni, n) } function Li(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(s(108, q(e) || "Unknown", i)); return M({}, n, r) } function Fi(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ki, Di = Ci.current, Ti(Ci, e), Ti(Ni, Ni.current), !0 } function Mi(e, t, n) { var r = e.stateNode; if (!r) throw Error(s(169)); n ? (e = Li(e, t, Di), r.__reactInternalMemoizedMergedChildContext = e, Ii(Ni), Ii(Ci), Ti(Ci, e)) : Ii(Ni), Ti(Ni, n) } var ji = null, Vi = !1, Bi = !1; function Ui(e) { null === ji ? ji = [e] : ji.push(e) } function zi() { if (!Bi && null !== ji) { Bi = !0; var e = 0, t = wt; try { var n = ji; for (wt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } ji = null, Vi = !1 } catch (i) { throw null !== ji && (ji = ji.slice(e + 1)), Qe(Ze, zi), i } finally { wt = t, Bi = !1 } } return null } var qi = [], Ki = 0, Gi = null, Hi = 0, Qi = [], Wi = 0, $i = null, Xi = 1, Yi = ""; function Ji(e, t) { qi[Ki++] = Hi, qi[Ki++] = Gi, Gi = e, Hi = t } function Zi(e, t, n) { Qi[Wi++] = Xi, Qi[Wi++] = Yi, Qi[Wi++] = $i, $i = e; var r = Xi; e = Yi; var i = 32 - ot(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - ot(t) + i; if (30 < s) { var o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Xi = 1 << 32 - ot(t) + i | n << i | r, Yi = s + e } else Xi = 1 << s | n << i | r, Yi = e } function es(e) { null !== e.return && (Ji(e, 1), Zi(e, 1, 0)) } function ts(e) { for (; e === Gi;)Gi = qi[--Ki], qi[Ki] = null, Hi = qi[--Ki], qi[Ki] = null; for (; e === $i;)$i = Qi[--Wi], Qi[Wi] = null, Yi = Qi[--Wi], Qi[Wi] = null, Xi = Qi[--Wi], Qi[Wi] = null } var ns = null, rs = null, is = !1, ss = null; function os(e, t) { var n = Oc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function as(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, ns = e, rs = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, ns = e, rs = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== $i ? { id: Xi, overflow: Yi } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Oc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, ns = e, rs = null, !0); default: return !1 } } function ls(e) { return 0 !== (1 & e.mode) && 0 === (128 & e.flags) } function cs(e) { if (is) { var t = rs; if (t) { var n = t; if (!as(e, t)) { if (ls(e)) throw Error(s(418)); t = ci(n.nextSibling); var r = ns; t && as(e, t) ? os(r, n) : (e.flags = -4097 & e.flags | 2, is = !1, ns = e) } } else { if (ls(e)) throw Error(s(418)); e.flags = -4097 & e.flags | 2, is = !1, ns = e } } } function us(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; ns = e } function hs(e) { if (e !== ns) return !1; if (!is) return us(e), is = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = rs)) { if (ls(e)) throw ds(), Error(s(418)); for (; t;)os(e, t), t = ci(t.nextSibling) } if (us(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(s(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { rs = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } rs = null } } else rs = ns ? ci(e.stateNode.nextSibling) : null; return !0 } function ds() { for (var e = rs; e;)e = ci(e.nextSibling) } function fs() { rs = ns = null, is = !1 } function ps(e) { null === ss ? ss = [e] : ss.push(e) } var ms = b.ReactCurrentBatchConfig; function gs(e, t) { if (e && e.defaultProps) { for (var n in t = M({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var ys = xi(null), vs = null, ws = null, bs = null; function Es() { bs = ws = vs = null } function Ss(e) { var t = ys.current; Ii(ys), e._currentValue = t } function _s(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function xs(e, t) { vs = e, bs = ws = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (ba = !0), e.firstContext = null) } function Is(e) { var t = e._currentValue; if (bs !== e) if (e = { context: e, memoizedValue: t, next: null }, null === ws) { if (null === vs) throw Error(s(308)); ws = e, vs.dependencies = { lanes: 0, firstContext: e } } else ws = ws.next = e; return t } var Ts = null; function ks(e) { null === Ts ? Ts = [e] : Ts.push(e) } function Cs(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, ks(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ns(e, r) } function Ns(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var Ds = !1; function As(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Os(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Rs(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Ps(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 !== (2 & Nl)) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ns(e, n) } return null === (i = r.interleaved) ? (t.next = t, ks(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ns(e, n) } function Ls(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, vt(e, n) } } function Fs(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, s = null; if (null !== (n = n.firstBaseUpdate)) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === s ? i = s = o : s = s.next = o, n = n.next } while (null !== n); null === s ? i = s = t : s = s.next = t } else i = s = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Ms(e, t, n, r) { var i = e.updateQueue; Ds = !1; var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending; if (null !== a) { i.shared.pending = null; var l = a, c = l.next; l.next = null, null === o ? s = c : o.next = c, o = l; var u = e.alternate; null !== u && ((a = (u = u.updateQueue).lastBaseUpdate) !== o && (null === a ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (null !== s) { var h = i.baseState; for (o = 0, u = c = l = null, a = s; ;) { var d = a.lane, f = a.eventTime; if ((r & d) === d) { null !== u && (u = u.next = { eventTime: f, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var p = e, m = a; switch (d = t, f = n, m.tag) { case 1: if ("function" === typeof (p = m.payload)) { h = p.call(f, h, d); break e } h = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if (null === (d = "function" === typeof (p = m.payload) ? p.call(f, h, d) : p) || void 0 === d) break e; h = M({}, h, d); break e; case 2: Ds = !0 } } null !== a.callback && 0 !== a.lane && (e.flags |= 64, null === (d = i.effects) ? i.effects = [a] : d.push(a)) } else f = { eventTime: f, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, null === u ? (c = u = f, l = h) : u = u.next = f, o |= d; if (null === (a = a.next)) { if (null === (a = i.shared.pending)) break; a = (d = a).next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } if (null === u && (l = h), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { o |= i.lane, i = i.next } while (i !== t) } else null === s && (i.shared.lanes = 0); Ml |= o, e.lanes = o, e.memoizedState = h } } function js(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" !== typeof i) throw Error(s(191, i)); i.call(r) } } } var Vs = (new r.Component).refs; function Bs(e, t, n, r) { n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : M({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var Us = { isMounted: function (e) { return !!(e = e._reactInternals) && ze(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), s = Rs(r, i); s.payload = t, void 0 !== n && null !== n && (s.callback = n), null !== (t = Ps(e, s, i)) && (rc(t, e, i, r), Ls(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), s = Rs(r, i); s.tag = 1, s.payload = t, void 0 !== n && null !== n && (s.callback = n), null !== (t = Ps(e, s, i)) && (rc(t, e, i, r), Ls(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tc(), r = nc(e), i = Rs(n, r); i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Ps(e, i, r)) && (rc(t, e, r, n), Ls(t, e, r)) } }; function zs(e, t, n, r, i, s, o) { return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, s, o) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, s)) } function qs(e, t, n) { var r = !1, i = ki, s = t.contextType; return "object" === typeof s && null !== s ? s = Is(s) : (i = Oi(t) ? Di : Ci.current, s = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ai(e, i) : ki), t = new t(n, s), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Us, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t } function Ks(e, t, n, r) { e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Us.enqueueReplaceState(t, t.state, null) } function Gs(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = Vs, As(e); var s = t.contextType; "object" === typeof s && null !== s ? i.context = Is(s) : (s = Oi(t) ? Di : Ci.current, i.context = Ai(e, s)), i.state = e.memoizedState, "function" === typeof (s = t.getDerivedStateFromProps) && (Bs(e, t, s, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Us.enqueueReplaceState(i, i.state, null), Ms(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308) } function Hs(e, t, n) { if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(s(309)); var r = n.stateNode } if (!r) throw Error(s(147, e)); var i = r, o = "" + e; return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === o ? t.ref : (t = function (e) { var t = i.refs; t === Vs && (t = i.refs = {}), null === e ? delete t[o] : t[o] = e }, t._stringRef = o, t) } if ("string" !== typeof e) throw Error(s(284)); if (!n._owner) throw Error(s(290, e)) } return e } function Qs(e, t) { throw e = Object.prototype.toString.call(t), Error(s(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Ws(e) { return (0, e._init)(e._payload) } function $s(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Pc(e, t)).index = 0, e.sibling = null, e } function o(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function a(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = jc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var s = n.type; return s === _ ? h(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === s || "object" === typeof s && null !== s && s.$$typeof === O && Ws(s) === t.type) ? ((r = i(t, n.props)).ref = Hs(e, t, n), r.return = e, r) : ((r = Lc(n.type, n.key, n.props, null, e.mode, r)).ref = Hs(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Vc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function h(e, t, n, r, s) { return null === t || 7 !== t.tag ? ((t = Fc(n, e.mode, r, s)).return = e, t) : ((t = i(t, n)).return = e, t) } function d(e, t, n) { if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = jc("" + t, e.mode, n)).return = e, t; if ("object" === typeof t && null !== t) { switch (t.$$typeof) { case E: return (n = Lc(t.type, t.key, t.props, null, e.mode, n)).ref = Hs(e, null, t), n.return = e, n; case S: return (t = Vc(t, e.mode, n)).return = e, t; case O: return d(e, (0, t._init)(t._payload), n) }if (te(t) || L(t)) return (t = Fc(t, e.mode, n, null)).return = e, t; Qs(e, t) } return null } function f(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" === typeof n && null !== n) { switch (n.$$typeof) { case E: return n.key === i ? c(e, t, n, r) : null; case S: return n.key === i ? u(e, t, n, r) : null; case O: return f(e, t, (i = n._init)(n._payload), r) }if (te(n) || L(n)) return null !== i ? null : h(e, t, n, r, null); Qs(e, n) } return null } function p(e, t, n, r, i) { if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" === typeof r && null !== r) { switch (r.$$typeof) { case E: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case S: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case O: return p(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || L(r)) return h(t, e = e.get(n) || null, r, i, null); Qs(t, r) } return null } function m(i, s, a, l) { for (var c = null, u = null, h = s, m = s = 0, g = null; null !== h && m < a.length; m++) { h.index > m ? (g = h, h = null) : g = h.sibling; var y = f(i, h, a[m], l); if (null === y) { null === h && (h = g); break } e && h && null === y.alternate && t(i, h), s = o(y, s, m), null === u ? c = y : u.sibling = y, u = y, h = g } if (m === a.length) return n(i, h), is && Ji(i, m), c; if (null === h) { for (; m < a.length; m++)null !== (h = d(i, a[m], l)) && (s = o(h, s, m), null === u ? c = h : u.sibling = h, u = h); return is && Ji(i, m), c } for (h = r(i, h); m < a.length; m++)null !== (g = p(h, i, m, a[m], l)) && (e && null !== g.alternate && h.delete(null === g.key ? m : g.key), s = o(g, s, m), null === u ? c = g : u.sibling = g, u = g); return e && h.forEach((function (e) { return t(i, e) })), is && Ji(i, m), c } function g(i, a, l, c) { var u = L(l); if ("function" !== typeof u) throw Error(s(150)); if (null == (l = u.call(l))) throw Error(s(151)); for (var h = u = null, m = a, g = a = 0, y = null, v = l.next(); null !== m && !v.done; g++, v = l.next()) { m.index > g ? (y = m, m = null) : y = m.sibling; var w = f(i, m, v.value, c); if (null === w) { null === m && (m = y); break } e && m && null === w.alternate && t(i, m), a = o(w, a, g), null === h ? u = w : h.sibling = w, h = w, m = y } if (v.done) return n(i, m), is && Ji(i, g), u; if (null === m) { for (; !v.done; g++, v = l.next())null !== (v = d(i, v.value, c)) && (a = o(v, a, g), null === h ? u = v : h.sibling = v, h = v); return is && Ji(i, g), u } for (m = r(i, m); !v.done; g++, v = l.next())null !== (v = p(m, i, g, v.value, c)) && (e && null !== v.alternate && m.delete(null === v.key ? g : v.key), a = o(v, a, g), null === h ? u = v : h.sibling = v, h = v); return e && m.forEach((function (e) { return t(i, e) })), is && Ji(i, g), u } return function e(r, s, o, l) { if ("object" === typeof o && null !== o && o.type === _ && null === o.key && (o = o.props.children), "object" === typeof o && null !== o) { switch (o.$$typeof) { case E: e: { for (var c = o.key, u = s; null !== u;) { if (u.key === c) { if ((c = o.type) === _) { if (7 === u.tag) { n(r, u.sibling), (s = i(u, o.props.children)).return = r, r = s; break e } } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === O && Ws(c) === u.type) { n(r, u.sibling), (s = i(u, o.props)).ref = Hs(r, u, o), s.return = r, r = s; break e } n(r, u); break } t(r, u), u = u.sibling } o.type === _ ? ((s = Fc(o.props.children, r.mode, l, o.key)).return = r, r = s) : ((l = Lc(o.type, o.key, o.props, null, r.mode, l)).ref = Hs(r, s, o), l.return = r, r = l) } return a(r); case S: e: { for (u = o.key; null !== s;) { if (s.key === u) { if (4 === s.tag && s.stateNode.containerInfo === o.containerInfo && s.stateNode.implementation === o.implementation) { n(r, s.sibling), (s = i(s, o.children || [])).return = r, r = s; break e } n(r, s); break } t(r, s), s = s.sibling } (s = Vc(o, r.mode, l)).return = r, r = s } return a(r); case O: return e(r, s, (u = o._init)(o._payload), l) }if (te(o)) return m(r, s, o, l); if (L(o)) return g(r, s, o, l); Qs(r, o) } return "string" === typeof o && "" !== o || "number" === typeof o ? (o = "" + o, null !== s && 6 === s.tag ? (n(r, s.sibling), (s = i(s, o)).return = r, r = s) : (n(r, s), (s = jc(o, r.mode, l)).return = r, r = s), a(r)) : n(r, s) } } var Xs = $s(!0), Ys = $s(!1), Js = {}, Zs = xi(Js), eo = xi(Js), to = xi(Js); function no(e) { if (e === Js) throw Error(s(174)); return e } function ro(e, t) { switch (Ti(to, t), Ti(eo, e), Ti(Zs, Js), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }Ii(Zs), Ti(Zs, t) } function io() { Ii(Zs), Ii(eo), Ii(to) } function so(e) { no(to.current); var t = no(Zs.current), n = le(t, e.type); t !== n && (Ti(eo, e), Ti(Zs, n)) } function oo(e) { eo.current === e && (Ii(Zs), Ii(eo)) } var ao = xi(0); function lo(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 !== (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var co = []; function uo() { for (var e = 0; e < co.length; e++)co[e]._workInProgressVersionPrimary = null; co.length = 0 } var ho = b.ReactCurrentDispatcher, fo = b.ReactCurrentBatchConfig, po = 0, mo = null, go = null, yo = null, vo = !1, wo = !1, bo = 0, Eo = 0; function So() { throw Error(s(321)) } function _o(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!ar(e[n], t[n])) return !1; return !0 } function xo(e, t, n, r, i, o) { if (po = o, mo = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ho.current = null === e || null === e.memoizedState ? aa : la, e = n(r, i), wo) { o = 0; do { if (wo = !1, bo = 0, 25 <= o) throw Error(s(301)); o += 1, yo = go = null, t.updateQueue = null, ho.current = ca, e = n(r, i) } while (wo) } if (ho.current = oa, t = null !== go && null !== go.next, po = 0, yo = go = mo = null, vo = !1, t) throw Error(s(300)); return e } function Io() { var e = 0 !== bo; return bo = 0, e } function To() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === yo ? mo.memoizedState = yo = e : yo = yo.next = e, yo } function ko() { if (null === go) { var e = mo.alternate; e = null !== e ? e.memoizedState : null } else e = go.next; var t = null === yo ? mo.memoizedState : yo.next; if (null !== t) yo = t, go = e; else { if (null === e) throw Error(s(310)); e = { memoizedState: (go = e).memoizedState, baseState: go.baseState, baseQueue: go.baseQueue, queue: go.queue, next: null }, null === yo ? mo.memoizedState = yo = e : yo = yo.next = e } return yo } function Co(e, t) { return "function" === typeof t ? t(e) : t } function No(e) { var t = ko(), n = t.queue; if (null === n) throw Error(s(311)); n.lastRenderedReducer = e; var r = go, i = r.baseQueue, o = n.pending; if (null !== o) { if (null !== i) { var a = i.next; i.next = o.next, o.next = a } r.baseQueue = i = o, n.pending = null } if (null !== i) { o = i.next, r = r.baseState; var l = a = null, c = null, u = o; do { var h = u.lane; if ((po & h) === h) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var d = { lane: h, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = d, a = r) : c = c.next = d, mo.lanes |= h, Ml |= h } u = u.next } while (null !== u && u !== o); null === c ? a = r : c.next = l, ar(r, t.memoizedState) || (ba = !0), t.memoizedState = r, t.baseState = a, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { o = i.lane, mo.lanes |= o, Ml |= o, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Do(e) { var t = ko(), n = t.queue; if (null === n) throw Error(s(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (null !== i) { n.pending = null; var a = i = i.next; do { o = e(o, a.action), a = a.next } while (a !== i); ar(o, t.memoizedState) || (ba = !0), t.memoizedState = o, null === t.baseQueue && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function Ao() { } function Oo(e, t) { var n = mo, r = ko(), i = t(), o = !ar(r.memoizedState, i); if (o && (r.memoizedState = i, ba = !0), r = r.queue, Ko(Lo.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || null !== yo && 1 & yo.memoizedState.tag) { if (n.flags |= 2048, Vo(9, Po.bind(null, n, r, i, t), void 0, null), null === Dl) throw Error(s(349)); 0 !== (30 & po) || Ro(n, t, i) } return i } function Ro(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = mo.updateQueue) ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Po(e, t, n, r) { t.value = n, t.getSnapshot = r, Fo(t) && Mo(e) } function Lo(e, t, n) { return n((function () { Fo(t) && Mo(e) })) } function Fo(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !ar(e, n) } catch (r) { return !0 } } function Mo(e) { var t = Ns(e, 1); null !== t && rc(t, e, 1, -1) } function jo(e) { var t = To(); return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Co, lastRenderedState: e }, t.queue = e, e = e.dispatch = na.bind(null, mo, e), [t.memoizedState, e] } function Vo(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = mo.updateQueue) ? (t = { lastEffect: null, stores: null }, mo.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function Bo() { return ko().memoizedState } function Uo(e, t, n, r) { var i = To(); mo.flags |= e, i.memoizedState = Vo(1 | t, n, void 0, void 0 === r ? null : r) } function zo(e, t, n, r) { var i = ko(); r = void 0 === r ? null : r; var s = void 0; if (null !== go) { var o = go.memoizedState; if (s = o.destroy, null !== r && _o(r, o.deps)) return void (i.memoizedState = Vo(t, n, s, r)) } mo.flags |= e, i.memoizedState = Vo(1 | t, n, s, r) } function qo(e, t) { return Uo(8390656, 8, e, t) } function Ko(e, t) { return zo(2048, 8, e, t) } function Go(e, t) { return zo(4, 2, e, t) } function Ho(e, t) { return zo(4, 4, e, t) } function Qo(e, t) { return "function" === typeof t ? (e = e(), t(e), function () { t(null) }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Wo(e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, zo(4, 4, Qo.bind(null, t, e), n) } function $o() { } function Xo(e, t) { var n = ko(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && _o(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Yo(e, t) { var n = ko(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && _o(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Jo(e, t, n) { return 0 === (21 & po) ? (e.baseState && (e.baseState = !1, ba = !0), e.memoizedState = n) : (ar(n, t) || (n = mt(), mo.lanes |= n, Ml |= n, e.baseState = !0), t) } function Zo(e, t) { var n = wt; wt = 0 !== n && 4 > n ? n : 4, e(!0); var r = fo.transition; fo.transition = {}; try { e(!1), t() } finally { wt = n, fo.transition = r } } function ea() { return ko().memoizedState } function ta(e, t, n) { var r = nc(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, ra(e)) ia(t, n); else if (null !== (n = Cs(e, t, n, r))) { rc(n, e, r, tc()), sa(n, t, r) } } function na(e, t, n) { var r = nc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (ra(e)) ia(t, i); else { var s = e.alternate; if (0 === e.lanes && (null === s || 0 === s.lanes) && null !== (s = t.lastRenderedReducer)) try { var o = t.lastRenderedState, a = s(o, n); if (i.hasEagerState = !0, i.eagerState = a, ar(a, o)) { var l = t.interleaved; return null === l ? (i.next = i, ks(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (c) { } null !== (n = Cs(e, t, i, r)) && (rc(n, e, r, i = tc()), sa(n, t, r)) } } function ra(e) { var t = e.alternate; return e === mo || null !== t && t === mo } function ia(e, t) { wo = vo = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function sa(e, t, n) { if (0 !== (4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, vt(e, n) } } var oa = { readContext: Is, useCallback: So, useContext: So, useEffect: So, useImperativeHandle: So, useInsertionEffect: So, useLayoutEffect: So, useMemo: So, useReducer: So, useRef: So, useState: So, useDebugValue: So, useDeferredValue: So, useTransition: So, useMutableSource: So, useSyncExternalStore: So, useId: So, unstable_isNewReconciler: !1 }, aa = { readContext: Is, useCallback: function (e, t) { return To().memoizedState = [e, void 0 === t ? null : t], e }, useContext: Is, useEffect: qo, useImperativeHandle: function (e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Uo(4194308, 4, Qo.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Uo(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Uo(4, 2, e, t) }, useMemo: function (e, t) { var n = To(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = To(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = ta.bind(null, mo, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, To().memoizedState = e }, useState: jo, useDebugValue: $o, useDeferredValue: function (e) { return To().memoizedState = e }, useTransition: function () { var e = jo(!1), t = e[0]; return e = Zo.bind(null, e[1]), To().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = mo, i = To(); if (is) { if (void 0 === n) throw Error(s(407)); n = n() } else { if (n = t(), null === Dl) throw Error(s(349)); 0 !== (30 & po) || Ro(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, qo(Lo.bind(null, r, o, e), [e]), r.flags |= 2048, Vo(9, Po.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = To(), t = Dl.identifierPrefix; if (is) { var n = Yi; t = ":" + t + "R" + (n = (Xi & ~(1 << 32 - ot(Xi) - 1)).toString(32) + n), 0 < (n = bo++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = Eo++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, la = { readContext: Is, useCallback: Xo, useContext: Is, useEffect: Ko, useImperativeHandle: Wo, useInsertionEffect: Go, useLayoutEffect: Ho, useMemo: Yo, useReducer: No, useRef: Bo, useState: function () { return No(Co) }, useDebugValue: $o, useDeferredValue: function (e) { return Jo(ko(), go.memoizedState, e) }, useTransition: function () { return [No(Co)[0], ko().memoizedState] }, useMutableSource: Ao, useSyncExternalStore: Oo, useId: ea, unstable_isNewReconciler: !1 }, ca = { readContext: Is, useCallback: Xo, useContext: Is, useEffect: Ko, useImperativeHandle: Wo, useInsertionEffect: Go, useLayoutEffect: Ho, useMemo: Yo, useReducer: Do, useRef: Bo, useState: function () { return Do(Co) }, useDebugValue: $o, useDeferredValue: function (e) { var t = ko(); return null === go ? t.memoizedState = e : Jo(t, go.memoizedState, e) }, useTransition: function () { return [Do(Co)[0], ko().memoizedState] }, useMutableSource: Ao, useSyncExternalStore: Oo, useId: ea, unstable_isNewReconciler: !1 }; function ua(e, t) { try { var n = "", r = t; do { n += U(r), r = r.return } while (r); var i = n } catch (s) { i = "\nError generating stack: " + s.message + "\n" + s.stack } return { value: e, source: t, stack: i, digest: null } } function ha(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function da(e, t) { try { console.error(t.value) } catch (n) { setTimeout((function () { throw n })) } } var fa = "function" === typeof WeakMap ? WeakMap : Map; function pa(e, t, n) { (n = Rs(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Gl || (Gl = !0, Hl = r), da(0, t) }, n } function ma(e, t, n) { (n = Rs(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" === typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { da(0, t) } } var s = e.stateNode; return null !== s && "function" === typeof s.componentDidCatch && (n.callback = function () { da(0, t), "function" !== typeof r && (null === Ql ? Ql = new Set([this]) : Ql.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function ga(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new fa; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Tc.bind(null, e, t, n), t.then(e, e)) } function ya(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function va(e, t, n, r, i) { return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Rs(-1, 1)).tag = 2, Ps(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e) } var wa = b.ReactCurrentOwner, ba = !1; function Ea(e, t, n, r) { t.child = null === e ? Ys(t, null, n, r) : Xs(t, e.child, n, r) } function Sa(e, t, n, r, i) { n = n.render; var s = t.ref; return xs(t, i), r = xo(e, t, n, r, s, i), n = Io(), null === e || ba ? (is && n && es(t), t.flags |= 1, Ea(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ga(e, t, i)) } function _a(e, t, n, r, i) { if (null === e) { var s = n.type; return "function" !== typeof s || Rc(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Lc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, xa(e, t, s, r, i)) } if (s = e.child, 0 === (e.lanes & i)) { var o = s.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(o, r) && e.ref === t.ref) return Ga(e, t, i) } return t.flags |= 1, (e = Pc(s, r)).ref = t.ref, e.return = t, t.child = e } function xa(e, t, n, r, i) { if (null !== e) { var s = e.memoizedProps; if (lr(s, r) && e.ref === t.ref) { if (ba = !1, t.pendingProps = r = s, 0 === (e.lanes & i)) return t.lanes = e.lanes, Ga(e, t, i); 0 !== (131072 & e.flags) && (ba = !0) } } return ka(e, t, n, r, i) } function Ia(e, t, n) { var r = t.pendingProps, i = r.children, s = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (0 === (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ti(Pl, Rl), Rl |= n; else { if (0 === (1073741824 & n)) return e = null !== s ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ti(Pl, Rl), Rl |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== s ? s.baseLanes : n, Ti(Pl, Rl), Rl |= r } else null !== s ? (r = s.baseLanes | n, t.memoizedState = null) : r = n, Ti(Pl, Rl), Rl |= r; return Ea(e, t, i, n), t.child } function Ta(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function ka(e, t, n, r, i) { var s = Oi(n) ? Di : Ci.current; return s = Ai(t, s), xs(t, i), n = xo(e, t, n, r, s, i), r = Io(), null === e || ba ? (is && r && es(t), t.flags |= 1, Ea(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ga(e, t, i)) } function Ca(e, t, n, r, i) { if (Oi(n)) { var s = !0; Fi(t) } else s = !1; if (xs(t, i), null === t.stateNode) Ka(e, t), qs(t, n, r), Gs(t, n, r, i), r = !0; else if (null === e) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var l = o.context, c = n.contextType; "object" === typeof c && null !== c ? c = Is(c) : c = Ai(t, c = Oi(n) ? Di : Ci.current); var u = n.getDerivedStateFromProps, h = "function" === typeof u || "function" === typeof o.getSnapshotBeforeUpdate; h || "function" !== typeof o.UNSAFE_componentWillReceiveProps && "function" !== typeof o.componentWillReceiveProps || (a !== r || l !== c) && Ks(t, o, r, c), Ds = !1; var d = t.memoizedState; o.state = d, Ms(t, r, o, i), l = t.memoizedState, a !== r || d !== l || Ni.current || Ds ? ("function" === typeof u && (Bs(t, n, u, r), l = t.memoizedState), (a = Ds || zs(t, n, a, r, d, l, c)) ? (h || "function" !== typeof o.UNSAFE_componentWillMount && "function" !== typeof o.componentWillMount || ("function" === typeof o.componentWillMount && o.componentWillMount(), "function" === typeof o.UNSAFE_componentWillMount && o.UNSAFE_componentWillMount()), "function" === typeof o.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof o.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), o.props = r, o.state = l, o.context = c, r = a) : ("function" === typeof o.componentDidMount && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, Os(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : gs(t.type, a), o.props = c, h = t.pendingProps, d = o.context, "object" === typeof (l = n.contextType) && null !== l ? l = Is(l) : l = Ai(t, l = Oi(n) ? Di : Ci.current); var f = n.getDerivedStateFromProps; (u = "function" === typeof f || "function" === typeof o.getSnapshotBeforeUpdate) || "function" !== typeof o.UNSAFE_componentWillReceiveProps && "function" !== typeof o.componentWillReceiveProps || (a !== h || d !== l) && Ks(t, o, r, l), Ds = !1, d = t.memoizedState, o.state = d, Ms(t, r, o, i); var p = t.memoizedState; a !== h || d !== p || Ni.current || Ds ? ("function" === typeof f && (Bs(t, n, f, r), p = t.memoizedState), (c = Ds || zs(t, n, c, r, d, p, l) || !1) ? (u || "function" !== typeof o.UNSAFE_componentWillUpdate && "function" !== typeof o.componentWillUpdate || ("function" === typeof o.componentWillUpdate && o.componentWillUpdate(r, p, l), "function" === typeof o.UNSAFE_componentWillUpdate && o.UNSAFE_componentWillUpdate(r, p, l)), "function" === typeof o.componentDidUpdate && (t.flags |= 4), "function" === typeof o.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof o.componentDidUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" !== typeof o.getSnapshotBeforeUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), o.props = r, o.state = p, o.context = l, r = c) : ("function" !== typeof o.componentDidUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), "function" !== typeof o.getSnapshotBeforeUpdate || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return Na(e, t, n, r, s, i) } function Na(e, t, n, r, i, s) { Ta(e, t); var o = 0 !== (128 & t.flags); if (!r && !o) return i && Mi(t, n, !1), Ga(e, t, s); r = t.stateNode, wa.current = t; var a = o && "function" !== typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && o ? (t.child = Xs(t, e.child, null, s), t.child = Xs(t, null, a, s)) : Ea(e, t, a, s), t.memoizedState = r.state, i && Mi(t, n, !0), t.child } function Da(e) { var t = e.stateNode; t.pendingContext ? Pi(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Pi(0, t.context, !1), ro(e, t.containerInfo) } function Aa(e, t, n, r, i) { return fs(), ps(i), t.flags |= 256, Ea(e, t, n, r), t.child } var Oa, Ra, Pa, La, Fa = { dehydrated: null, treeContext: null, retryLane: 0 }; function Ma(e) { return { baseLanes: e, cachePool: null, transitions: null } } function ja(e, t, n) { var r, i = t.pendingProps, o = ao.current, a = !1, l = 0 !== (128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & o)), r ? (a = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (o |= 1), Ti(ao, 1 & o), null === e) return cs(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, a ? (i = t.mode, a = t.child, l = { mode: "hidden", children: l }, 0 === (1 & i) && null !== a ? (a.childLanes = 0, a.pendingProps = l) : a = Mc(l, i, 0, null), e = Fc(e, i, n, null), a.return = t, e.return = t, a.sibling = e, t.child = a, t.child.memoizedState = Ma(n), t.memoizedState = Fa, e) : Va(t, l)); if (null !== (o = e.memoizedState) && null !== (r = o.dehydrated)) return function (e, t, n, r, i, o, a) { if (n) return 256 & t.flags ? (t.flags &= -257, Ba(e, t, a, r = ha(Error(s(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Mc({ mode: "visible", children: r.children }, i, 0, null), (o = Fc(o, i, a, null)).flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, 0 !== (1 & t.mode) && Xs(t, e.child, null, a), t.child.memoizedState = Ma(a), t.memoizedState = Fa, o); if (0 === (1 & t.mode)) return Ba(e, t, a, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, Ba(e, t, a, r = ha(o = Error(s(419)), r, void 0)) } if (l = 0 !== (a & e.childLanes), ba || l) { if (null !== (r = Dl)) { switch (a & -a) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = 0 !== (i & (r.suspendedLanes | a)) ? 0 : i) && i !== o.retryLane && (o.retryLane = i, Ns(e, i), rc(r, e, i, -1)) } return gc(), Ba(e, t, a, r = ha(Error(s(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Cc.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, rs = ci(i.nextSibling), ns = t, is = !0, ss = null, null !== e && (Qi[Wi++] = Xi, Qi[Wi++] = Yi, Qi[Wi++] = $i, Xi = e.id, Yi = e.overflow, $i = t), t = Va(t, r.children), t.flags |= 4096, t) }(e, t, l, i, r, o, n); if (a) { a = i.fallback, l = t.mode, r = (o = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 0 === (1 & l) && t.child !== o ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Pc(o, c)).subtreeFlags = 14680064 & o.subtreeFlags, null !== r ? a = Pc(r, a) : (a = Fc(a, l, n, null)).flags |= 2, a.return = t, i.return = t, i.sibling = a, t.child = i, i = a, a = t.child, l = null === (l = e.child.memoizedState) ? Ma(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, a.memoizedState = l, a.childLanes = e.childLanes & ~n, t.memoizedState = Fa, i } return e = (a = e.child).sibling, i = Pc(a, { mode: "visible", children: i.children }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Va(e, t) { return (t = Mc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function Ba(e, t, n, r) { return null !== r && ps(r), Xs(t, e.child, null, n), (e = Va(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Ua(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), _s(e.return, t, n) } function za(e, t, n, r, i) { var s = e.memoizedState; null === s ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function qa(e, t, n) { var r = t.pendingProps, i = r.revealOrder, s = r.tail; if (Ea(e, t, r.children, n), 0 !== (2 & (r = ao.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Ua(e, n, t); else if (19 === e.tag) Ua(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ti(ao, r), 0 === (1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === lo(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), za(t, !1, i, n, s); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === lo(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } za(t, !0, n, null, s); break; case "together": za(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Ka(e, t) { 0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Ga(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), Ml |= t.lanes, 0 === (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(s(153)); if (null !== t.child) { for (n = Pc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Pc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Ha(e, t) { if (!is) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Qa(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Wa(e, t, n) { var r = t.pendingProps; switch (ts(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Qa(t), null; case 1: case 17: return Oi(t.type) && Ri(), Qa(t), null; case 3: return r = t.stateNode, io(), Ii(Ni), Ii(Ci), uo(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (hs(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== ss && (ac(ss), ss = null))), Ra(e, t), Qa(t), null; case 5: oo(t); var i = no(to.current); if (n = t.type, null !== e && null != t.stateNode) Pa(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(s(166)); return Qa(t), null } if (e = no(Zs.current), hs(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[di] = t, r[fi] = o, e = 0 !== (1 & t.mode), n) { case "dialog": Vr("cancel", r), Vr("close", r); break; case "iframe": case "object": case "embed": Vr("load", r); break; case "video": case "audio": for (i = 0; i < Lr.length; i++)Vr(Lr[i], r); break; case "source": Vr("error", r); break; case "img": case "image": case "link": Vr("error", r), Vr("load", r); break; case "details": Vr("toggle", r); break; case "input": X(r, o), Vr("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Vr("invalid", r); break; case "textarea": ie(r, o), Vr("invalid", r) }for (var l in ve(n, o), i = null, o) if (o.hasOwnProperty(l)) { var c = o[l]; "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== o.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== o.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", "" + c]) : a.hasOwnProperty(l) && null != c && "onScroll" === l && Vr("scroll", r) } switch (n) { case "input": H(r), Z(r, o, !0); break; case "textarea": H(r), oe(r); break; case "select": case "option": break; default: "function" === typeof o.onClick && (r.onclick = Zr) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = ae(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[di] = t, e[fi] = r, Oa(e, t, !1, !1), t.stateNode = e; e: { switch (l = we(n, r), n) { case "dialog": Vr("cancel", e), Vr("close", e), i = r; break; case "iframe": case "object": case "embed": Vr("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Lr.length; i++)Vr(Lr[i], e); i = r; break; case "source": Vr("error", e), i = r; break; case "img": case "image": case "link": Vr("error", e), Vr("load", e), i = r; break; case "details": Vr("toggle", e), i = r; break; case "input": X(e, r), i = $(e, r), Vr("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = M({}, r, { value: void 0 }), Vr("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), Vr("invalid", e) }for (o in ve(n, i), c = i) if (c.hasOwnProperty(o)) { var u = c[o]; "style" === o ? ge(e, u) : "dangerouslySetInnerHTML" === o ? null != (u = u ? u.__html : void 0) && he(e, u) : "children" === o ? "string" === typeof u ? ("textarea" !== n || "" !== u) && de(e, u) : "number" === typeof u && de(e, "" + u) : "suppressContentEditableWarning" !== o && "suppressHydrationWarning" !== o && "autoFocus" !== o && (a.hasOwnProperty(o) ? null != u && "onScroll" === o && Vr("scroll", e) : null != u && w(e, o, u, l)) } switch (n) { case "input": H(e), Z(e, r, !1); break; case "textarea": H(e), oe(e); break; case "option": null != r.value && e.setAttribute("value", "" + K(r.value)); break; case "select": e.multiple = !!r.multiple, null != (o = r.value) ? ne(e, !!r.multiple, o, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" === typeof i.onClick && (e.onclick = Zr) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Qa(t), null; case 6: if (e && null != t.stateNode) La(e, t, e.memoizedProps, r); else { if ("string" !== typeof r && null === t.stateNode) throw Error(s(166)); if (n = no(to.current), no(Zs.current), hs(t)) { if (r = t.stateNode, n = t.memoizedProps, r[di] = t, (o = r.nodeValue !== n) && null !== (e = ns)) switch (e.tag) { case 3: Jr(r.nodeValue, n, 0 !== (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Jr(r.nodeValue, n, 0 !== (1 & e.mode)) }o && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[di] = t, t.stateNode = r } return Qa(t), null; case 13: if (Ii(ao), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (is && null !== rs && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) ds(), fs(), t.flags |= 98560, o = !1; else if (o = hs(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!o) throw Error(s(318)); if (!(o = null !== (o = t.memoizedState) ? o.dehydrated : null)) throw Error(s(317)); o[di] = t } else fs(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Qa(t), o = !1 } else null !== ss && (ac(ss), ss = null), o = !0; if (!o) return 65536 & t.flags ? t : null } return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & ao.current) ? 0 === Ll && (Ll = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Qa(t), null); case 4: return io(), Ra(e, t), null === e && zr(t.stateNode.containerInfo), Qa(t), null; case 10: return Ss(t.type._context), Qa(t), null; case 19: if (Ii(ao), null === (o = t.memoizedState)) return Qa(t), null; if (r = 0 !== (128 & t.flags), null === (l = o.rendering)) if (r) Ha(o, !1); else { if (0 !== Ll || null !== e && 0 !== (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = lo(e))) { for (t.flags |= 128, Ha(o, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (o = n).flags &= 14680066, null === (l = o.alternate) ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = l.childLanes, o.lanes = l.lanes, o.child = l.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = l.memoizedProps, o.memoizedState = l.memoizedState, o.updateQueue = l.updateQueue, o.type = l.type, e = l.dependencies, o.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ti(ao, 1 & ao.current | 2), t.child } e = e.sibling } null !== o.tail && Ye() > ql && (t.flags |= 128, r = !0, Ha(o, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = lo(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Ha(o, !0), null === o.tail && "hidden" === o.tailMode && !l.alternate && !is) return Qa(t), null } else 2 * Ye() - o.renderingStartTime > ql && 1073741824 !== n && (t.flags |= 128, r = !0, Ha(o, !1), t.lanes = 4194304); o.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = o.last) ? n.sibling = l : t.child = l, o.last = l) } return null !== o.tail ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Ye(), t.sibling = null, n = ao.current, Ti(ao, r ? 1 & n | 2 : 1 & n), t) : (Qa(t), null); case 22: case 23: return dc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Rl) && (Qa(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Qa(t), null; case 24: case 25: return null }throw Error(s(156, t.tag)) } function $a(e, t) { switch (ts(t), t.tag) { case 1: return Oi(t.type) && Ri(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return io(), Ii(Ni), Ii(Ci), uo(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return oo(t), null; case 13: if (Ii(ao), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(s(340)); fs() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return Ii(ao), null; case 4: return io(), null; case 10: return Ss(t.type._context), null; case 22: case 23: return dc(), null; default: return null } } Oa = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, Ra = function () { }, Pa = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, no(Zs.current); var s, o = null; switch (n) { case "input": i = $(e, i), r = $(e, r), o = []; break; case "select": i = M({}, i, { value: void 0 }), r = M({}, r, { value: void 0 }), o = []; break; case "textarea": i = re(e, i), r = re(e, r), o = []; break; default: "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = Zr) }for (u in ve(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (s in l) l.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (a.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (s in l) !l.hasOwnProperty(s) || c && c.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in c) c.hasOwnProperty(s) && l[s] !== c[s] && (n || (n = {}), n[s] = c[s]) } else n || (o || (o = []), o.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (o = o || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (o = o || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (a.hasOwnProperty(u) ? (null != c && "onScroll" === u && Vr("scroll", e), o || l === c || (o = [])) : (o = o || []).push(u, c)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }, La = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Xa = !1, Ya = !1, Ja = "function" === typeof WeakSet ? WeakSet : Set, Za = null; function el(e, t) { var n = e.ref; if (null !== n) if ("function" === typeof n) try { n(null) } catch (r) { Ic(e, t, r) } else n.current = null } function tl(e, t, n) { try { n() } catch (r) { Ic(e, t, r) } } var nl = !1; function rl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var s = i.destroy; i.destroy = void 0, void 0 !== s && tl(t, n, s) } i = i.next } while (i !== r) } } function il(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function sl(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" === typeof t ? t(e) : t.current = e } } function ol(e) { var t = e.alternate; null !== t && (e.alternate = null, ol(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[di], delete t[fi], delete t[mi], delete t[gi], delete t[yi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function al(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ll(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || al(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Zr)); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } function ul(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;)ul(e, t, n), e = e.sibling } var hl = null, dl = !1; function fl(e, t, n) { for (n = n.child; null !== n;)pl(e, t, n), n = n.sibling } function pl(e, t, n) { if (st && "function" === typeof st.onCommitFiberUnmount) try { st.onCommitFiberUnmount(it, n) } catch (a) { } switch (n.tag) { case 5: Ya || el(n, t); case 6: var r = hl, i = dl; hl = null, fl(e, t, n), dl = i, null !== (hl = r) && (dl ? (e = hl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : hl.removeChild(n.stateNode)); break; case 18: null !== hl && (dl ? (e = hl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), zt(e)) : li(hl, n.stateNode)); break; case 4: r = hl, i = dl, hl = n.stateNode.containerInfo, dl = !0, fl(e, t, n), hl = r, dl = i; break; case 0: case 11: case 14: case 15: if (!Ya && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) { i = r = r.next; do { var s = i, o = s.destroy; s = s.tag, void 0 !== o && (0 !== (2 & s) || 0 !== (4 & s)) && tl(n, t, o), i = i.next } while (i !== r) } fl(e, t, n); break; case 1: if (!Ya && (el(n, t), "function" === typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Ic(n, t, a) } fl(e, t, n); break; case 21: fl(e, t, n); break; case 22: 1 & n.mode ? (Ya = (r = Ya) || null !== n.memoizedState, fl(e, t, n), Ya = r) : fl(e, t, n); break; default: fl(e, t, n) } } function ml(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Ja), t.forEach((function (t) { var r = Nc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function gl(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, a = t, l = a; e: for (; null !== l;) { switch (l.tag) { case 5: hl = l.stateNode, dl = !1; break e; case 3: case 4: hl = l.stateNode.containerInfo, dl = !0; break e }l = l.return } if (null === hl) throw Error(s(160)); pl(o, a, i), hl = null, dl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (u) { Ic(i, t, u) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)yl(t, e), t = t.sibling } function yl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (gl(t, e), vl(e), 4 & r) { try { rl(3, e, e.return), il(3, e) } catch (g) { Ic(e, e.return, g) } try { rl(5, e, e.return) } catch (g) { Ic(e, e.return, g) } } break; case 1: gl(t, e), vl(e), 512 & r && null !== n && el(n, n.return); break; case 5: if (gl(t, e), vl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) { var i = e.stateNode; try { de(i, "") } catch (g) { Ic(e, e.return, g) } } if (4 & r && null != (i = e.stateNode)) { var o = e.memoizedProps, a = null !== n ? n.memoizedProps : o, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === o.type && null != o.name && Y(i, o), we(l, a); var u = we(l, o); for (a = 0; a < c.length; a += 2) { var h = c[a], d = c[a + 1]; "style" === h ? ge(i, d) : "dangerouslySetInnerHTML" === h ? he(i, d) : "children" === h ? de(i, d) : w(i, h, d, u) } switch (l) { case "input": J(i, o); break; case "textarea": se(i, o); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var p = o.value; null != p ? ne(i, !!o.multiple, p, !1) : f !== !!o.multiple && (null != o.defaultValue ? ne(i, !!o.multiple, o.defaultValue, !0) : ne(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[fi] = o } catch (g) { Ic(e, e.return, g) } } break; case 6: if (gl(t, e), vl(e), 4 & r) { if (null === e.stateNode) throw Error(s(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (g) { Ic(e, e.return, g) } } break; case 3: if (gl(t, e), vl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { zt(t.containerInfo) } catch (g) { Ic(e, e.return, g) } break; case 4: default: gl(t, e), vl(e); break; case 13: gl(t, e), vl(e), 8192 & (i = e.child).flags && (o = null !== i.memoizedState, i.stateNode.isHidden = o, !o || null !== i.alternate && null !== i.alternate.memoizedState || (zl = Ye())), 4 & r && ml(e); break; case 22: if (h = null !== n && null !== n.memoizedState, 1 & e.mode ? (Ya = (u = Ya) || h, gl(t, e), Ya = u) : gl(t, e), vl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !h && 0 !== (1 & e.mode)) for (Za = e, h = e.child; null !== h;) { for (d = Za = h; null !== Za;) { switch (p = (f = Za).child, f.tag) { case 0: case 11: case 14: case 15: rl(4, f, f.return); break; case 1: el(f, f.return); var m = f.stateNode; if ("function" === typeof m.componentWillUnmount) { r = f, n = f.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (g) { Ic(r, n, g) } } break; case 5: el(f, f.return); break; case 22: if (null !== f.memoizedState) { Sl(d); continue } }null !== p ? (p.return = f, Za = p) : Sl(d) } h = h.sibling } e: for (h = null, d = e; ;) { if (5 === d.tag) { if (null === h) { h = d; try { i = d.stateNode, u ? "function" === typeof (o = i.style).setProperty ? o.setProperty("display", "none", "important") : o.display = "none" : (l = d.stateNode, a = void 0 !== (c = d.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", a)) } catch (g) { Ic(e, e.return, g) } } } else if (6 === d.tag) { if (null === h) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (g) { Ic(e, e.return, g) } } else if ((22 !== d.tag && 23 !== d.tag || null === d.memoizedState || d === e) && null !== d.child) { d.child.return = d, d = d.child; continue } if (d === e) break e; for (; null === d.sibling;) { if (null === d.return || d.return === e) break e; h === d && (h = null), d = d.return } h === d && (h = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: gl(t, e), vl(e), 4 & r && ml(e); case 21: } } function vl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (al(n)) { var r = n; break e } n = n.return } throw Error(s(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (de(i, ""), r.flags &= -33), ul(e, ll(e), i); break; case 3: case 4: var o = r.stateNode.containerInfo; cl(e, ll(e), o); break; default: throw Error(s(161)) } } catch (a) { Ic(e, e.return, a) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function wl(e, t, n) { Za = e, bl(e, t, n) } function bl(e, t, n) { for (var r = 0 !== (1 & e.mode); null !== Za;) { var i = Za, s = i.child; if (22 === i.tag && r) { var o = null !== i.memoizedState || Xa; if (!o) { var a = i.alternate, l = null !== a && null !== a.memoizedState || Ya; a = Xa; var c = Ya; if (Xa = o, (Ya = l) && !c) for (Za = i; null !== Za;)l = (o = Za).child, 22 === o.tag && null !== o.memoizedState ? _l(i) : null !== l ? (l.return = o, Za = l) : _l(i); for (; null !== s;)Za = s, bl(s, t, n), s = s.sibling; Za = i, Xa = a, Ya = c } El(e) } else 0 !== (8772 & i.subtreeFlags) && null !== s ? (s.return = i, Za = s) : El(e) } } function El(e) { for (; null !== Za;) { var t = Za; if (0 !== (8772 & t.flags)) { var n = t.alternate; try { if (0 !== (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: Ya || il(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !Ya) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : gs(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; null !== o && js(t, o, r); break; case 3: var a = t.updateQueue; if (null !== a) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }js(t, a, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var h = u.memoizedState; if (null !== h) { var d = h.dehydrated; null !== d && zt(d) } } } break; default: throw Error(s(163)) }Ya || 512 & t.flags && sl(t) } catch (f) { Ic(t, t.return, f) } } if (t === e) { Za = null; break } if (null !== (n = t.sibling)) { n.return = t.return, Za = n; break } Za = t.return } } function Sl(e) { for (; null !== Za;) { var t = Za; if (t === e) { Za = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, Za = n; break } Za = t.return } } function _l(e) { for (; null !== Za;) { var t = Za; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { il(4, t) } catch (l) { Ic(t, n, l) } break; case 1: var r = t.stateNode; if ("function" === typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (l) { Ic(t, i, l) } } var s = t.return; try { sl(t) } catch (l) { Ic(t, s, l) } break; case 5: var o = t.return; try { sl(t) } catch (l) { Ic(t, o, l) } } } catch (l) { Ic(t, t.return, l) } if (t === e) { Za = null; break } var a = t.sibling; if (null !== a) { a.return = t.return, Za = a; break } Za = t.return } } var xl, Il = Math.ceil, Tl = b.ReactCurrentDispatcher, kl = b.ReactCurrentOwner, Cl = b.ReactCurrentBatchConfig, Nl = 0, Dl = null, Al = null, Ol = 0, Rl = 0, Pl = xi(0), Ll = 0, Fl = null, Ml = 0, jl = 0, Vl = 0, Bl = null, Ul = null, zl = 0, ql = 1 / 0, Kl = null, Gl = !1, Hl = null, Ql = null, Wl = !1, $l = null, Xl = 0, Yl = 0, Jl = null, Zl = -1, ec = 0; function tc() { return 0 !== (6 & Nl) ? Ye() : -1 !== Zl ? Zl : Zl = Ye() } function nc(e) { return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Nl) && 0 !== Ol ? Ol & -Ol : null !== ms.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = wt) ? e : e = void 0 === (e = window.event) ? 16 : Xt(e.type) } function rc(e, t, n, r) { if (50 < Yl) throw Yl = 0, Jl = null, Error(s(185)); yt(e, n, r), 0 !== (2 & Nl) && e === Dl || (e === Dl && (0 === (2 & Nl) && (jl |= n), 4 === Ll && lc(e, Ol)), ic(e, r), 1 === n && 0 === Nl && 0 === (1 & t.mode) && (ql = Ye() + 500, Vi && zi())) } function ic(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s;) { var o = 31 - ot(s), a = 1 << o, l = i[o]; -1 === l ? 0 !== (a & n) && 0 === (a & r) || (i[o] = ft(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a } }(e, t); var r = dt(e, e === Dl ? Ol : 0); if (0 === r) null !== n && We(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && We(n), 1 === t) 0 === e.tag ? function (e) { Vi = !0, Ui(e) }(cc.bind(null, e)) : Ui(cc.bind(null, e)), oi((function () { 0 === (6 & Nl) && zi() })), n = null; else { switch (bt(r)) { case 1: n = Ze; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Dc(n, sc.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function sc(e, t) { if (Zl = -1, ec = 0, 0 !== (6 & Nl)) throw Error(s(327)); var n = e.callbackNode; if (_c() && e.callbackNode !== n) return null; var r = dt(e, e === Dl ? Ol : 0); if (0 === r) return null; if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = yc(e, r); else { t = r; var i = Nl; Nl |= 2; var o = mc(); for (Dl === e && Ol === t || (Kl = null, ql = Ye() + 500, fc(e, t)); ;)try { wc(); break } catch (l) { pc(e, l) } Es(), Tl.current = o, Nl = i, null !== Al ? t = 0 : (Dl = null, Ol = 0, t = Ll) } if (0 !== t) { if (2 === t && (0 !== (i = pt(e)) && (r = i, t = oc(e, i))), 1 === t) throw n = Fl, fc(e, 0), lc(e, r), ic(e, Ye()), n; if (6 === t) lc(e, r); else { if (i = e.current.alternate, 0 === (30 & r) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!ar(s(), i)) return !1 } catch (a) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) && (2 === (t = yc(e, r)) && (0 !== (o = pt(e)) && (r = o, t = oc(e, o))), 1 === t)) throw n = Fl, fc(e, 0), lc(e, r), ic(e, Ye()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(s(345)); case 2: case 5: Sc(e, Ul, Kl); break; case 3: if (lc(e, r), (130023424 & r) === r && 10 < (t = zl + 500 - Ye())) { if (0 !== dt(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { tc(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(Sc.bind(null, e, Ul, Kl), t); break } Sc(e, Ul, Kl); break; case 4: if (lc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var a = 31 - ot(r); o = 1 << a, (a = t[a]) > i && (i = a), r &= ~o } if (r = i, 10 < (r = (120 > (r = Ye() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Il(r / 1960)) - r)) { e.timeoutHandle = ri(Sc.bind(null, e, Ul, Kl), r); break } Sc(e, Ul, Kl); break; default: throw Error(s(329)) } } } return ic(e, Ye()), e.callbackNode === n ? sc.bind(null, e) : null } function oc(e, t) { var n = Bl; return e.current.memoizedState.isDehydrated && (fc(e, t).flags |= 256), 2 !== (e = yc(e, t)) && (t = Ul, Ul = n, null !== t && ac(t)), e } function ac(e) { null === Ul ? Ul = e : Ul.push.apply(Ul, e) } function lc(e, t) { for (t &= ~Vl, t &= ~jl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - ot(t), r = 1 << n; e[n] = -1, t &= ~r } } function cc(e) { if (0 !== (6 & Nl)) throw Error(s(327)); _c(); var t = dt(e, 0); if (0 === (1 & t)) return ic(e, Ye()), null; var n = yc(e, t); if (0 !== e.tag && 2 === n) { var r = pt(e); 0 !== r && (t = r, n = oc(e, r)) } if (1 === n) throw n = Fl, fc(e, 0), lc(e, t), ic(e, Ye()), n; if (6 === n) throw Error(s(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Sc(e, Ul, Kl), ic(e, Ye()), null } function uc(e, t) { var n = Nl; Nl |= 1; try { return e(t) } finally { 0 === (Nl = n) && (ql = Ye() + 500, Vi && zi()) } } function hc(e) { null !== $l && 0 === $l.tag && 0 === (6 & Nl) && _c(); var t = Nl; Nl |= 1; var n = Cl.transition, r = wt; try { if (Cl.transition = null, wt = 1, e) return e() } finally { wt = r, Cl.transition = n, 0 === (6 & (Nl = t)) && zi() } } function dc() { Rl = Pl.current, Ii(Pl) } function fc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Al) for (n = Al.return; null !== n;) { var r = n; switch (ts(r), r.tag) { case 1: null !== (r = r.type.childContextTypes) && void 0 !== r && Ri(); break; case 3: io(), Ii(Ni), Ii(Ci), uo(); break; case 5: oo(r); break; case 4: io(); break; case 13: case 19: Ii(ao); break; case 10: Ss(r.type._context); break; case 22: case 23: dc() }n = n.return } if (Dl = e, Al = e = Pc(e.current, null), Ol = Rl = t, Ll = 0, Fl = null, Vl = jl = Ml = 0, Ul = Bl = null, null !== Ts) { for (t = 0; t < Ts.length; t++)if (null !== (r = (n = Ts[t]).interleaved)) { n.interleaved = null; var i = r.next, s = n.pending; if (null !== s) { var o = s.next; s.next = i, r.next = o } n.pending = r } Ts = null } return e } function pc(e, t) { for (; ;) { var n = Al; try { if (Es(), ho.current = oa, vo) { for (var r = mo.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } vo = !1 } if (po = 0, yo = go = mo = null, wo = !1, bo = 0, kl.current = null, null === n || null === n.return) { Ll = 1, Fl = t, Al = null; break } e: { var o = e, a = n.return, l = n, c = t; if (t = Ol, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) { var u = c, h = l, d = h.tag; if (0 === (1 & h.mode) && (0 === d || 11 === d || 15 === d)) { var f = h.alternate; f ? (h.updateQueue = f.updateQueue, h.memoizedState = f.memoizedState, h.lanes = f.lanes) : (h.updateQueue = null, h.memoizedState = null) } var p = ya(a); if (null !== p) { p.flags &= -257, va(p, a, l, 0, t), 1 & p.mode && ga(o, u, t), c = u; var m = (t = p).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (0 === (1 & t)) { ga(o, u, t), gc(); break e } c = Error(s(426)) } else if (is && 1 & l.mode) { var y = ya(a); if (null !== y) { 0 === (65536 & y.flags) && (y.flags |= 256), va(y, a, l, 0, t), ps(ua(c, l)); break e } } o = c = ua(c, l), 4 !== Ll && (Ll = 2), null === Bl ? Bl = [o] : Bl.push(o), o = a; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t, Fs(o, pa(0, c, t)); break e; case 1: l = c; var v = o.type, w = o.stateNode; if (0 === (128 & o.flags) && ("function" === typeof v.getDerivedStateFromError || null !== w && "function" === typeof w.componentDidCatch && (null === Ql || !Ql.has(w)))) { o.flags |= 65536, t &= -t, o.lanes |= t, Fs(o, ma(o, l, t)); break e } }o = o.return } while (null !== o) } Ec(n) } catch (b) { t = b, Al === n && null !== n && (Al = n = n.return); continue } break } } function mc() { var e = Tl.current; return Tl.current = oa, null === e ? oa : e } function gc() { 0 !== Ll && 3 !== Ll && 2 !== Ll || (Ll = 4), null === Dl || 0 === (268435455 & Ml) && 0 === (268435455 & jl) || lc(Dl, Ol) } function yc(e, t) { var n = Nl; Nl |= 2; var r = mc(); for (Dl === e && Ol === t || (Kl = null, fc(e, t)); ;)try { vc(); break } catch (i) { pc(e, i) } if (Es(), Nl = n, Tl.current = r, null !== Al) throw Error(s(261)); return Dl = null, Ol = 0, Ll } function vc() { for (; null !== Al;)bc(Al) } function wc() { for (; null !== Al && !$e();)bc(Al) } function bc(e) { var t = xl(e.alternate, e, Rl); e.memoizedProps = e.pendingProps, null === t ? Ec(e) : Al = t, kl.current = null } function Ec(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 === (32768 & t.flags)) { if (null !== (n = Wa(n, t, Rl))) return void (Al = n) } else { if (null !== (n = $a(n, t))) return n.flags &= 32767, void (Al = n); if (null === e) return Ll = 6, void (Al = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Al = t); Al = t = e } while (null !== t); 0 === Ll && (Ll = 5) } function Sc(e, t, n) { var r = wt, i = Cl.transition; try { Cl.transition = null, wt = 1, function (e, t, n, r) { do { _c() } while (null !== $l); if (0 !== (6 & Nl)) throw Error(s(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(s(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - ot(n), s = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~s } }(e, o), e === Dl && (Al = Dl = null, Ol = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Wl || (Wl = !0, Dc(tt, (function () { return _c(), null }))), o = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || o) { o = Cl.transition, Cl.transition = null; var a = wt; wt = 1; var l = Nl; Nl |= 4, kl.current = null, function (e, t) { if (ei = Kt, fr(e = dr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch (E) { n = null; break e } var a = 0, l = -1, c = -1, u = 0, h = 0, d = e, f = null; t: for (; ;) { for (var p; d !== n || 0 !== i && 3 !== d.nodeType || (l = a + i), d !== o || 0 !== r && 3 !== d.nodeType || (c = a + r), 3 === d.nodeType && (a += d.nodeValue.length), null !== (p = d.firstChild);)f = d, d = p; for (; ;) { if (d === e) break t; if (f === n && ++u === i && (l = a), f === o && ++h === r && (c = a), null !== (p = d.nextSibling)) break; f = (d = f).parentNode } d = p } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Kt = !1, Za = t; null !== Za;)if (e = (t = Za).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, Za = e; else for (; null !== Za;) { t = Za; try { var m = t.alternate; if (0 !== (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, y = m.memoizedState, v = t.stateNode, w = v.getSnapshotBeforeUpdate(t.elementType === t.type ? g : gs(t.type, g), y); v.__reactInternalSnapshotBeforeUpdate = w } break; case 3: var b = t.stateNode.containerInfo; 1 === b.nodeType ? b.textContent = "" : 9 === b.nodeType && b.documentElement && b.removeChild(b.documentElement); break; default: throw Error(s(163)) } } catch (E) { Ic(t, t.return, E) } if (null !== (e = t.sibling)) { e.return = t.return, Za = e; break } Za = t.return } m = nl, nl = !1 }(e, n), yl(n, e), pr(ti), Kt = !!ei, ti = ei = null, e.current = n, wl(n, e, i), Xe(), Nl = l, wt = a, Cl.transition = o } else e.current = n; if (Wl && (Wl = !1, $l = e, Xl = i), o = e.pendingLanes, 0 === o && (Ql = null), function (e) { if (st && "function" === typeof st.onCommitFiberRoot) try { st.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags)) } catch (t) { } }(n.stateNode), ic(e, Ye()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Gl) throw Gl = !1, e = Hl, Hl = null, e; 0 !== (1 & Xl) && 0 !== e.tag && _c(), o = e.pendingLanes, 0 !== (1 & o) ? e === Jl ? Yl++ : (Yl = 0, Jl = e) : Yl = 0, zi() }(e, t, n, r) } finally { Cl.transition = i, wt = r } return null } function _c() { if (null !== $l) { var e = bt(Xl), t = Cl.transition, n = wt; try { if (Cl.transition = null, wt = 16 > e ? 16 : e, null === $l) var r = !1; else { if (e = $l, $l = null, Xl = 0, 0 !== (6 & Nl)) throw Error(s(331)); var i = Nl; for (Nl |= 4, Za = e.current; null !== Za;) { var o = Za, a = o.child; if (0 !== (16 & Za.flags)) { var l = o.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for (Za = u; null !== Za;) { var h = Za; switch (h.tag) { case 0: case 11: case 15: rl(8, h, o) }var d = h.child; if (null !== d) d.return = h, Za = d; else for (; null !== Za;) { var f = (h = Za).sibling, p = h.return; if (ol(h), h === u) { Za = null; break } if (null !== f) { f.return = p, Za = f; break } Za = p } } } var m = o.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var y = g.sibling; g.sibling = null, g = y } while (null !== g) } } Za = o } } if (0 !== (2064 & o.subtreeFlags) && null !== a) a.return = o, Za = a; else e: for (; null !== Za;) { if (0 !== (2048 & (o = Za).flags)) switch (o.tag) { case 0: case 11: case 15: rl(9, o, o.return) }var v = o.sibling; if (null !== v) { v.return = o.return, Za = v; break e } Za = o.return } } var w = e.current; for (Za = w; null !== Za;) { var b = (a = Za).child; if (0 !== (2064 & a.subtreeFlags) && null !== b) b.return = a, Za = b; else e: for (a = w; null !== Za;) { if (0 !== (2048 & (l = Za).flags)) try { switch (l.tag) { case 0: case 11: case 15: il(9, l) } } catch (S) { Ic(l, l.return, S) } if (l === a) { Za = null; break e } var E = l.sibling; if (null !== E) { E.return = l.return, Za = E; break e } Za = l.return } } if (Nl = i, zi(), st && "function" === typeof st.onPostCommitFiberRoot) try { st.onPostCommitFiberRoot(it, e) } catch (S) { } r = !0 } return r } finally { wt = n, Cl.transition = t } } return !1 } function xc(e, t, n) { e = Ps(e, t = pa(0, t = ua(n, t), 1), 1), t = tc(), null !== e && (yt(e, 1, t), ic(e, t)) } function Ic(e, t, n) { if (3 === e.tag) xc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { xc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Ql || !Ql.has(r))) { t = Ps(t, e = ma(t, e = ua(n, e), 1), 1), e = tc(), null !== t && (yt(t, 1, e), ic(t, e)); break } } t = t.return } } function Tc(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Dl === e && (Ol & n) === n && (4 === Ll || 3 === Ll && (130023424 & Ol) === Ol && 500 > Ye() - zl ? fc(e, 0) : Vl |= n), ic(e, t) } function kc(e, t) { 0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = tc(); null !== (e = Ns(e, t)) && (yt(e, t, n), ic(e, n)) } function Cc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), kc(e, n) } function Nc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(s(314)) }null !== r && r.delete(t), kc(e, n) } function Dc(e, t) { return Qe(e, t) } function Ac(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Oc(e, t, n, r) { return new Ac(e, t, n, r) } function Rc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Pc(e, t) { var n = e.alternate; return null === n ? ((n = Oc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Lc(e, t, n, r, i, o) { var a = 2; if (r = e, "function" === typeof e) Rc(e) && (a = 1); else if ("string" === typeof e) a = 5; else e: switch (e) { case _: return Fc(n.children, i, o, t); case x: a = 8, i |= 8; break; case I: return (e = Oc(12, n, t, 2 | i)).elementType = I, e.lanes = o, e; case N: return (e = Oc(13, n, t, i)).elementType = N, e.lanes = o, e; case D: return (e = Oc(19, n, t, i)).elementType = D, e.lanes = o, e; case R: return Mc(n, i, o, t); default: if ("object" === typeof e && null !== e) switch (e.$$typeof) { case T: a = 10; break e; case k: a = 9; break e; case C: a = 11; break e; case A: a = 14; break e; case O: a = 16, r = null; break e }throw Error(s(130, null == e ? e : typeof e, "")) }return (t = Oc(a, n, t, i)).elementType = e, t.type = r, t.lanes = o, t } function Fc(e, t, n, r) { return (e = Oc(7, e, r, t)).lanes = n, e } function Mc(e, t, n, r) { return (e = Oc(22, e, r, t)).elementType = R, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function jc(e, t, n) { return (e = Oc(6, e, null, t)).lanes = n, e } function Vc(e, t, n) { return (t = Oc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Bc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Uc(e, t, n, r, i, s, o, a, l) { return e = new Bc(e, t, n, a, l), 1 === t ? (t = 1, !0 === s && (t |= 8)) : t = 0, s = Oc(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, As(s), e } function zc(e) { if (!e) return ki; e: { if (ze(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(s(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Oi(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(s(171)) } if (1 === e.tag) { var n = e.type; if (Oi(n)) return Li(e, n, t) } return t } function qc(e, t, n, r, i, s, o, a, l) { return (e = Uc(n, r, !0, e, 0, s, 0, a, l)).context = zc(null), n = e.current, (s = Rs(r = tc(), i = nc(n))).callback = void 0 !== t && null !== t ? t : null, Ps(n, s, i), e.current.lanes = i, yt(e, i, r), ic(e, r), e } function Kc(e, t, n, r) { var i = t.current, s = tc(), o = nc(i); return n = zc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Rs(s, o)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Ps(i, t, o)) && (rc(e, i, o, s), Ls(e, i, o)), o } function Gc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Hc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Qc(e, t) { Hc(e, t), (e = e.alternate) && Hc(e, t) } xl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Ni.current) ba = !0; else { if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return ba = !1, function (e, t, n) { switch (t.tag) { case 3: Da(t), fs(); break; case 5: so(t); break; case 1: Oi(t.type) && Fi(t); break; case 4: ro(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ti(ys, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ti(ao, 1 & ao.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? ja(e, t, n) : (Ti(ao, 1 & ao.current), null !== (e = Ga(e, t, n)) ? e.sibling : null); Ti(ao, 1 & ao.current); break; case 19: if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) { if (r) return qa(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ti(ao, ao.current), r) break; return null; case 22: case 23: return t.lanes = 0, Ia(e, t, n) }return Ga(e, t, n) }(e, t, n); ba = 0 !== (131072 & e.flags) } else ba = !1, is && 0 !== (1048576 & t.flags) && Zi(t, Hi, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Ka(e, t), e = t.pendingProps; var i = Ai(t, Ci.current); xs(t, n), i = xo(null, t, r, e, i, n); var o = Io(); return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Oi(r) ? (o = !0, Fi(t)) : o = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, As(t), i.updater = Us, t.stateNode = i, i._reactInternals = t, Gs(t, r, e, n), t = Na(null, t, r, !0, o, n)) : (t.tag = 0, is && o && es(t), Ea(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Ka(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" === typeof e) return Rc(e) ? 1 : 0; if (void 0 !== e && null !== e) { if ((e = e.$$typeof) === C) return 11; if (e === A) return 14 } return 2 }(r), e = gs(r, e), i) { case 0: t = ka(null, t, r, e, n); break e; case 1: t = Ca(null, t, r, e, n); break e; case 11: t = Sa(null, t, r, e, n); break e; case 14: t = _a(null, t, r, gs(r.type, e), n); break e }throw Error(s(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, ka(e, t, r, i = t.elementType === r ? i : gs(r, i), n); case 1: return r = t.type, i = t.pendingProps, Ca(e, t, r, i = t.elementType === r ? i : gs(r, i), n); case 3: e: { if (Da(t), null === e) throw Error(s(387)); r = t.pendingProps, i = (o = t.memoizedState).element, Os(e, t), Ms(t, r, null, n); var a = t.memoizedState; if (r = a.element, o.isDehydrated) { if (o = { element: r, isDehydrated: !1, cache: a.cache, pendingSuspenseBoundaries: a.pendingSuspenseBoundaries, transitions: a.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { t = Aa(e, t, r, n, i = ua(Error(s(423)), t)); break e } if (r !== i) { t = Aa(e, t, r, n, i = ua(Error(s(424)), t)); break e } for (rs = ci(t.stateNode.containerInfo.firstChild), ns = t, is = !0, ss = null, n = Ys(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (fs(), r === i) { t = Ga(e, t, n); break e } Ea(e, t, r, n) } t = t.child } return t; case 5: return so(t), null === e && cs(t), r = t.type, i = t.pendingProps, o = null !== e ? e.memoizedProps : null, a = i.children, ni(r, i) ? a = null : null !== o && ni(r, o) && (t.flags |= 32), Ta(e, t), Ea(e, t, a, n), t.child; case 6: return null === e && cs(t), null; case 13: return ja(e, t, n); case 4: return ro(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Xs(t, null, r, n) : Ea(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, Sa(e, t, r, i = t.elementType === r ? i : gs(r, i), n); case 7: return Ea(e, t, t.pendingProps, n), t.child; case 8: case 12: return Ea(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, a = i.value, Ti(ys, r._currentValue), r._currentValue = a, null !== o) if (ar(o.value, a)) { if (o.children === i.children && !Ni.current) { t = Ga(e, t, n); break e } } else for (null !== (o = t.child) && (o.return = t); null !== o;) { var l = o.dependencies; if (null !== l) { a = o.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === o.tag) { (c = Rs(-1, n & -n)).tag = 2; var u = o.updateQueue; if (null !== u) { var h = (u = u.shared).pending; null === h ? c.next = c : (c.next = h.next, h.next = c), u.pending = c } } o.lanes |= n, null !== (c = o.alternate) && (c.lanes |= n), _s(o.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === o.tag) a = o.type === t.type ? null : o.child; else if (18 === o.tag) { if (null === (a = o.return)) throw Error(s(341)); a.lanes |= n, null !== (l = a.alternate) && (l.lanes |= n), _s(a, n, t), a = o.sibling } else a = o.child; if (null !== a) a.return = o; else for (a = o; null !== a;) { if (a === t) { a = null; break } if (null !== (o = a.sibling)) { o.return = a.return, a = o; break } a = a.return } o = a } Ea(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, xs(t, n), r = r(i = Is(i)), t.flags |= 1, Ea(e, t, r, n), t.child; case 14: return i = gs(r = t.type, t.pendingProps), _a(e, t, r, i = gs(r.type, i), n); case 15: return xa(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : gs(r, i), Ka(e, t), t.tag = 1, Oi(r) ? (e = !0, Fi(t)) : e = !1, xs(t, n), qs(t, r, i), Gs(t, r, i, n), Na(null, t, r, !0, e, n); case 19: return qa(e, t, n); case 22: return Ia(e, t, n) }throw Error(s(156, t.tag)) }; var Wc = "function" === typeof reportError ? reportError : function (e) { console.error(e) }; function $c(e) { this._internalRoot = e } function Xc(e) { this._internalRoot = e } function Yc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Jc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function Zc() { } function eu(e, t, n, r, i) { var s = n._reactRootContainer; if (s) { var o = s; if ("function" === typeof i) { var a = i; i = function () { var e = Gc(o); a.call(e) } } Kc(t, o, e, i) } else o = function (e, t, n, r, i) { if (i) { if ("function" === typeof r) { var s = r; r = function () { var e = Gc(o); s.call(e) } } var o = qc(t, r, e, 0, null, !1, 0, "", Zc); return e._reactRootContainer = o, e[pi] = o.current, zr(8 === e.nodeType ? e.parentNode : e), hc(), o } for (; i = e.lastChild;)e.removeChild(i); if ("function" === typeof r) { var a = r; r = function () { var e = Gc(l); a.call(e) } } var l = Uc(e, 0, !1, null, 0, !1, 0, "", Zc); return e._reactRootContainer = l, e[pi] = l.current, zr(8 === e.nodeType ? e.parentNode : e), hc((function () { Kc(t, l, n, r) })), l }(n, t, e, i, r); return Gc(o) } Xc.prototype.render = $c.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(s(409)); Kc(e, t, null, null) }, Xc.prototype.unmount = $c.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; hc((function () { Kc(null, e, null, null) })), t[pi] = null } }, Xc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = xt(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Rt.length && 0 !== t && t < Rt[n].priority; n++); Rt.splice(n, 0, e), 0 === n && Mt(e) } }, Et = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = ht(t.pendingLanes); 0 !== n && (vt(t, 1 | n), ic(t, Ye()), 0 === (6 & Nl) && (ql = Ye() + 500, zi())) } break; case 13: hc((function () { var t = Ns(e, 1); if (null !== t) { var n = tc(); rc(t, e, 1, n) } })), Qc(e, 1) } }, St = function (e) { if (13 === e.tag) { var t = Ns(e, 134217728); if (null !== t) rc(t, e, 134217728, tc()); Qc(e, 134217728) } }, _t = function (e) { if (13 === e.tag) { var t = nc(e), n = Ns(e, t); if (null !== n) rc(n, e, t, tc()); Qc(e, t) } }, xt = function () { return wt }, It = function (e, t) { var n = wt; try { return wt = e, t() } finally { wt = n } }, Se = function (e, t, n) { switch (t) { case "input": if (J(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Ei(r); if (!i) throw Error(s(90)); Q(r), J(r, i) } } } break; case "textarea": se(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, Ce = uc, Ne = hc; var tu = { usingClientEntryPoint: !1, Events: [wi, bi, Ei, Te, ke, uc] }, nu = { findFiberByHostInstance: vi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, ru = { bundleType: nu.bundleType, version: nu.version, rendererPackageName: nu.rendererPackageName, rendererConfig: nu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: b.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = Ge(e)) ? null : e.stateNode }, findFiberByHostInstance: nu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!iu.isDisabled && iu.supportsFiber) try { it = iu.inject(ru), st = iu } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!Yc(t)) throw Error(s(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: S, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!Yc(e)) throw Error(s(299)); var n = !1, r = "", i = Wc; return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Uc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, zr(8 === e.nodeType ? e.parentNode : e), new $c(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" === typeof e.render) throw Error(s(188)); throw e = Object.keys(e).join(","), Error(s(268, e)) } return e = null === (e = Ge(t)) ? null : e.stateNode }, t.flushSync = function (e) { return hc(e) }, t.hydrate = function (e, t, n) { if (!Jc(t)) throw Error(s(200)); return eu(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!Yc(e)) throw Error(s(405)); var r = null != n && n.hydratedSources || null, i = !1, o = "", a = Wc; if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (o = n.identifierPrefix), void 0 !== n.onRecoverableError && (a = n.onRecoverableError)), t = qc(t, null, e, 1, null != n ? n : null, i, 0, o, a), e[pi] = t.current, zr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Xc(t) }, t.render = function (e, t, n) { if (!Jc(t)) throw Error(s(200)); return eu(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Jc(e)) throw Error(s(40)); return !!e._reactRootContainer && (hc((function () { eu(null, null, e, !1, (function () { e._reactRootContainer = null, e[pi] = null })) })), !0) }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Jc(n)) throw Error(s(200)); if (null == e || void 0 === e._reactInternals) throw Error(s(38)); return eu(e, t, n, !1, r) }, t.version = "18.2.0-next-9e3b772b8-20220608" }, 250: (e, t, n) => { var r = n(164); t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot }, 164: (e, t, n) => { !function e() { if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } }(), e.exports = n(463) }, 374: (e, t, n) => { var r = n(791), i = Symbol.for("react.element"), s = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, s = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) o.call(t, r) && !l.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === s[r] && (s[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: s, _owner: a.current } } t.Fragment = s, t.jsx = c, t.jsxs = c }, 117: (e, t) => { var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.iterator; var p = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function y(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } function v() { } function w(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } y.prototype.isReactComponent = {}, y.prototype.setState = function (e, t) { if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, y.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, v.prototype = y.prototype; var b = w.prototype = new v; b.constructor = w, m(b, y.prototype), b.isPureReactComponent = !0; var E = Array.isArray, S = Object.prototype.hasOwnProperty, _ = { current: null }, x = { key: !0, ref: !0, __self: !0, __source: !0 }; function I(e, t, r) { var i, s = {}, o = null, a = null; if (null != t) for (i in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (o = "" + t.key), t) S.call(t, i) && !x.hasOwnProperty(i) && (s[i] = t[i]); var l = arguments.length - 2; if (1 === l) s.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; s.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === s[i] && (s[i] = l[i]); return { $$typeof: n, type: e, key: o, ref: a, props: s, _owner: _.current } } function T(e) { return "object" === typeof e && null !== e && e.$$typeof === n } var k = /\/+/g; function C(e, t) { return "object" === typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function N(e, t, i, s, o) { var a = typeof e; "undefined" !== a && "boolean" !== a || (e = null); var l = !1; if (null === e) l = !0; else switch (a) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return o = o(l = e), e = "" === s ? "." + C(l, 0) : s, E(o) ? (i = "", null != e && (i = e.replace(k, "$&/") + "/"), N(o, t, i, "", (function (e) { return e }))) : null != o && (T(o) && (o = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(o, i + (!o.key || l && l.key === o.key ? "" : ("" + o.key).replace(k, "$&/") + "/") + e)), t.push(o)), 1; if (l = 0, s = "" === s ? "." : s + ":", E(e)) for (var c = 0; c < e.length; c++) { var u = s + C(a = e[c], c); l += N(a, t, i, u, o) } else if (u = function (e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = f && e[f] || e["@@iterator"]) ? e : null }(e), "function" === typeof u) for (e = u.call(e), c = 0; !(a = e.next()).done;)l += N(a = a.value, t, i, u = s + C(a, c++), o); else if ("object" === a) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function D(e, t, n) { if (null == e) return e; var r = [], i = 0; return N(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function A(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var O = { current: null }, R = { transition: null }, P = { ReactCurrentDispatcher: O, ReactCurrentBatchConfig: R, ReactCurrentOwner: _ }; t.Children = { map: D, forEach: function (e, t, n) { D(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return D(e, (function () { t++ })), t }, toArray: function (e) { return D(e, (function (e) { return e })) || [] }, only: function (e) { if (!T(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = y, t.Fragment = i, t.Profiler = o, t.PureComponent = w, t.StrictMode = s, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = P, t.cloneElement = function (e, t, r) { if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = m({}, e.props), s = e.key, o = e.ref, a = e._owner; if (null != t) { if (void 0 !== t.ref && (o = t.ref, a = _.current), void 0 !== t.key && (s = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) S.call(t, c) && !x.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: s, ref: o, props: i, _owner: a } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: a, _context: e }, e.Consumer = e }, t.createElement = I, t.createFactory = function (e) { var t = I.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = T, t.lazy = function (e) { return { $$typeof: d, _payload: { _status: -1, _result: e }, _init: A } }, t.memo = function (e, t) { return { $$typeof: h, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = R.transition; R.transition = {}; try { e() } finally { R.transition = t } }, t.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, t.useCallback = function (e, t) { return O.current.useCallback(e, t) }, t.useContext = function (e) { return O.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return O.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return O.current.useEffect(e, t) }, t.useId = function () { return O.current.useId() }, t.useImperativeHandle = function (e, t, n) { return O.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return O.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return O.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return O.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return O.current.useReducer(e, t, n) }, t.useRef = function (e) { return O.current.useRef(e) }, t.useState = function (e) { return O.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return O.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return O.current.useTransition() }, t.version = "18.2.0" }, 791: (e, t, n) => { e.exports = n(117) }, 184: (e, t, n) => { e.exports = n(374) }, 813: (e, t) => { function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < s(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var a = 2 * (r + 1) - 1, l = e[a], c = a + 1, u = e[c]; if (0 > s(l, n)) c < i && 0 > s(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[a] = n, r = a); else { if (!(c < i && 0 > s(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function s(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" === typeof performance && "function" === typeof performance.now) { var o = performance; t.unstable_now = function () { return o.now() } } else { var a = Date, l = a.now(); t.unstable_now = function () { return a.now() - l } } var c = [], u = [], h = 1, d = null, f = 3, p = !1, m = !1, g = !1, y = "function" === typeof setTimeout ? setTimeout : null, v = "function" === typeof clearTimeout ? clearTimeout : null, w = "undefined" !== typeof setImmediate ? setImmediate : null; function b(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function E(e) { if (g = !1, b(e), !m) if (null !== r(c)) m = !0, R(S); else { var t = r(u); null !== t && P(E, t.startTime - e) } } function S(e, n) { m = !1, g && (g = !1, v(T), T = -1), p = !0; var s = f; try { for (b(n), d = r(c); null !== d && (!(d.expirationTime > n) || e && !N());) { var o = d.callback; if ("function" === typeof o) { d.callback = null, f = d.priorityLevel; var a = o(d.expirationTime <= n); n = t.unstable_now(), "function" === typeof a ? d.callback = a : d === r(c) && i(c), b(n) } else i(c); d = r(c) } if (null !== d) var l = !0; else { var h = r(u); null !== h && P(E, h.startTime - n), l = !1 } return l } finally { d = null, f = s, p = !1 } } "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var _, x = !1, I = null, T = -1, k = 5, C = -1; function N() { return !(t.unstable_now() - C < k) } function D() { if (null !== I) { var e = t.unstable_now(); C = e; var n = !0; try { n = I(!0, e) } finally { n ? _() : (x = !1, I = null) } } else x = !1 } if ("function" === typeof w) _ = function () { w(D) }; else if ("undefined" !== typeof MessageChannel) { var A = new MessageChannel, O = A.port2; A.port1.onmessage = D, _ = function () { O.postMessage(null) } } else _ = function () { y(D, 0) }; function R(e) { I = e, x || (x = !0, _()) } function P(e, n) { T = y((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || p || (m = !0, R(S)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : k = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (f) { case 1: case 2: case 3: var t = 3; break; default: t = f }var n = f; f = t; try { return e() } finally { f = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = f; f = e; try { return t() } finally { f = n } }, t.unstable_scheduleCallback = function (e, i, s) { var o = t.unstable_now(); switch ("object" === typeof s && null !== s ? s = "number" === typeof (s = s.delay) && 0 < s ? o + s : o : s = o, e) { case 1: var a = -1; break; case 2: a = 250; break; case 5: a = 1073741823; break; case 4: a = 1e4; break; default: a = 5e3 }return e = { id: h++, callback: i, priorityLevel: e, startTime: s, expirationTime: a = s + a, sortIndex: -1 }, s > o ? (e.sortIndex = s, n(u, e), null === r(c) && e === r(u) && (g ? (v(T), T = -1) : g = !0, P(E, s - o))) : (e.sortIndex = a, n(c, e), m || p || (m = !0, R(S))), e }, t.unstable_shouldYield = N, t.unstable_wrapCallback = function (e) { var t = f; return function () { var n = f; f = t; try { return e.apply(this, arguments) } finally { f = n } } } }, 296: (e, t, n) => { e.exports = n(813) } }, t = {}; function n(r) { var i = t[r]; if (void 0 !== i) return i.exports; var s = t[r] = { exports: {} }; return e[r](s, s.exports, n), s.exports } n.m = e, (() => { var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__; n.t = function (r, i) { if (1 & i && (r = this(r)), 8 & i) return r; if ("object" === typeof r && r) { if (4 & i && r.__esModule) return r; if (16 & i && "function" === typeof r.then) return r } var s = Object.create(null); n.r(s); var o = {}; e = e || [null, t({}), t([]), t(t)]; for (var a = 2 & i && r; "object" == typeof a && !~e.indexOf(a); a = t(a))Object.getOwnPropertyNames(a).forEach((e => o[e] = () => r[e])); return o.default = () => r, n.d(s, o), s } })(), n.d = (e, t) => { for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }) }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t), t)), [])), n.u = e => "static/js/" + e + ".f9f775de.chunk.js", n.miniCssF = e => { }, n.g = function () { if ("object" === typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" === typeof window) return window } }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { var e = {}, t = "blog-site:"; n.l = (r, i, s, o) => { if (e[r]) e[r].push(i); else { var a, l; if (void 0 !== s) for (var c = document.getElementsByTagName("script"), u = 0; u < c.length; u++) { var h = c[u]; if (h.getAttribute("src") == r || h.getAttribute("data-webpack") == t + s) { a = h; break } } a || (l = !0, (a = document.createElement("script")).charset = "utf-8", a.timeout = 120, n.nc && a.setAttribute("nonce", n.nc), a.setAttribute("data-webpack", t + s), a.src = r), e[r] = [i]; var d = (t, n) => { a.onerror = a.onload = null, clearTimeout(f); var i = e[r]; if (delete e[r], a.parentNode && a.parentNode.removeChild(a), i && i.forEach((e => e(n))), t) return t(n) }, f = setTimeout(d.bind(null, void 0, { type: "timeout", target: a }), 12e4); a.onerror = d.bind(null, a.onerror), a.onload = d.bind(null, a.onload), l && document.head.appendChild(a) } } })(), n.r = e => { "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.p = "/", (() => { var e = { 179: 0 }; n.f.j = (t, r) => { var i = n.o(e, t) ? e[t] : void 0; if (0 !== i) if (i) r.push(i[2]); else { var s = new Promise(((n, r) => i = e[t] = [n, r])); r.push(i[2] = s); var o = n.p + n.u(t), a = new Error; n.l(o, (r => { if (n.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0), i)) { var s = r && ("load" === r.type ? "missing" : r.type), o = r && r.target && r.target.src; a.message = "Loading chunk " + t + " failed.\n(" + s + ": " + o + ")", a.name = "ChunkLoadError", a.type = s, a.request = o, i[1](a) } }), "chunk-" + t, t) } }; var t = (t, r) => { var i, s, o = r[0], a = r[1], l = r[2], c = 0; if (o.some((t => 0 !== e[t]))) { for (i in a) n.o(a, i) && (n.m[i] = a[i]); if (l) l(n) } for (t && t(r); c < o.length; c++)s = o[c], n.o(e, s) && e[s] && e[s][0](), e[s] = 0 }, r = self.webpackChunkblog_site = self.webpackChunkblog_site || []; r.forEach(t.bind(null, 0)), r.push = t.bind(null, r.push.bind(r)) })(), (() => { var e = {}; n.r(e), n.d(e, { FirebaseError: () => xe, SDK_VERSION: () => xt, _DEFAULT_ENTRY_NAME: () => dt, _addComponent: () => gt, _addOrOverwriteComponent: () => yt, _apps: () => pt, _clearComponents: () => Et, _components: () => mt, _getProvider: () => wt, _registerComponent: () => vt, _removeServiceInstance: () => bt, deleteApp: () => Ct, getApp: () => Tt, getApps: () => kt, initializeApp: () => It, onLog: () => Dt, registerVersion: () => Nt, setLogLevel: () => At }); var t = n(791), r = n.t(t, 2), i = n(250); const s = e => { e && e instanceof Function && n.e(787).then(n.bind(n, 787)).then((t => { let { getCLS: n, getFID: r, getFCP: i, getLCP: s, getTTFB: o } = t; n(e), r(e), i(e), s(e), o(e) })) }; function o() { return o = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, o.apply(this, arguments) } var a; !function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" }(a || (a = {})); const l = "popstate"; function c(e, t) { if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t) } function u(e, t) { if (!e) { "undefined" !== typeof console && console.warn(t); try { throw new Error(t) } catch (n) { } } } function h(e, t) { return { usr: e.state, key: e.key, idx: t } } function d(e, t, n, r) { return void 0 === n && (n = null), o({ pathname: "string" === typeof e ? e : e.pathname, search: "", hash: "" }, "string" === typeof t ? p(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function f(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function p(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function m(e, t, n, r) { void 0 === r && (r = {}); let { window: i = document.defaultView, v5Compat: s = !1 } = r, u = i.history, p = a.Pop, m = null, g = y(); function y() { return (u.state || { idx: null }).idx } function v() { p = a.Pop; let e = y(), t = null == e ? null : e - g; g = e, m && m({ action: p, location: b.location, delta: t }) } function w(e) { let t = "null" !== i.location.origin ? i.location.origin : i.location.href, n = "string" === typeof e ? e : f(e); return c(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == g && (g = 0, u.replaceState(o({}, u.state, { idx: g }), "")); let b = { get action() { return p }, get location() { return e(i, u) }, listen(e) { if (m) throw new Error("A history only accepts one active listener"); return i.addEventListener(l, v), m = e, () => { i.removeEventListener(l, v), m = null } }, createHref: e => t(i, e), createURL: w, encodeLocation(e) { let t = w(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, t) { p = a.Push; let r = d(b.location, e, t); n && n(r, e), g = y() + 1; let o = h(r, g), l = b.createHref(r); try { u.pushState(o, "", l) } catch (c) { if (c instanceof DOMException && "DataCloneError" === c.name) throw c; i.location.assign(l) } s && m && m({ action: p, location: b.location, delta: 1 }) }, replace: function (e, t) { p = a.Replace; let r = d(b.location, e, t); n && n(r, e), g = y(); let i = h(r, g), o = b.createHref(r); u.replaceState(i, "", o), s && m && m({ action: p, location: b.location, delta: 0 }) }, go: e => u.go(e) }; return b } var g; !function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" }(g || (g = {})); new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function y(e, t, n) { void 0 === n && (n = "/"); let r = A(("string" === typeof t ? p(t) : t).pathname || "/", n); if (null == r) return null; let i = v(e); !function (e) { e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n])); return n ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex))))) }(i); let s = null; for (let o = 0; null == s && o < i.length; ++o)s = C(i[o], D(r)); return s } function v(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let i = (e, i, s) => { let o = { relativePath: void 0 === s ? e.path || "" : s, caseSensitive: !0 === e.caseSensitive, childrenIndex: i, route: e }; o.relativePath.startsWith("/") && (c(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), o.relativePath = o.relativePath.slice(r.length)); let a = O([r, o.relativePath]), l = n.concat(o); e.children && e.children.length > 0 && (c(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'), v(e.children, t, l, a)), (null != e.path || e.index) && t.push({ path: a, score: k(a, e.index), routesMeta: l }) }; return e.forEach(((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of w(e.path)) i(e, t, r); else i(e, t) })), t } function w(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, i = n.endsWith("?"), s = n.replace(/\?$/, ""); if (0 === r.length) return i ? [s, ""] : [s]; let o = w(r.join("/")), a = []; return a.push(...o.map((e => "" === e ? s : [s, e].join("/")))), i && a.push(...o), a.map((t => e.startsWith("/") && "" === t ? "/" : t)) } const b = /^:\w+$/, E = 3, S = 2, _ = 1, x = 10, I = -2, T = e => "*" === e; function k(e, t) { let n = e.split("/"), r = n.length; return n.some(T) && (r += I), t && (r += S), n.filter((e => !T(e))).reduce(((e, t) => e + (b.test(t) ? E : "" === t ? _ : x)), r) } function C(e, t) { let { routesMeta: n } = e, r = {}, i = "/", s = []; for (let o = 0; o < n.length; ++o) { let e = n[o], a = o === n.length - 1, l = "/" === i ? t : t.slice(i.length) || "/", c = N({ path: e.relativePath, caseSensitive: e.caseSensitive, end: a }, l); if (!c) return null; Object.assign(r, c.params); let u = e.route; s.push({ params: r, pathname: O([i, c.pathname]), pathnameBase: R(O([i, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (i = O([i, c.pathnameBase])) } return s } function N(e, t) { "string" === typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1); void 0 === n && (n = !0); u("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, ((e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)"))); e.endsWith("*") ? (r.push({ paramName: "*" }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))"); let s = new RegExp(i, t ? void 0 : "i"); return [s, r] }(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let s = i[0], o = s.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce(((e, t, n) => { let { paramName: r, isOptional: i } = t; if ("*" === r) { let e = a[n] || ""; o = s.slice(0, s.length - e.length).replace(/(.)\/+$/, "$1") } const l = a[n]; return e[r] = i && !l ? void 0 : function (e, t) { try { return decodeURIComponent(e) } catch (n) { return u(!1, 'The value for the URL param "' + t + '" will not be decoded because the string "' + e + '" is a malformed URL segment. This is probably due to a bad percent encoding (' + n + ")."), e } }(l || "", r), e }), {}), pathname: s, pathnameBase: o, pattern: e } } function D(e) { try { return decodeURI(e) } catch (t) { return u(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function A(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } const O = e => e.join("/").replace(/\/\/+/g, "/"), R = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"); Error; function P(e) { return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e } const L = ["post", "put", "patch", "delete"], F = (new Set(L), ["get", ...L]); new Set(F), new Set([301, 302, 303, 307, 308]), new Set([307, 308]); Symbol("deferred"); function M() { return M = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, M.apply(this, arguments) } const j = t.createContext(null); const V = t.createContext(null); const B = t.createContext(null); const U = t.createContext(null); const z = t.createContext({ outlet: null, matches: [], isDataRoute: !1 }); const q = t.createContext(null); function K() { return null != t.useContext(U) } function G() { return K() || c(!1), t.useContext(U).location } function H(e, n, r) { K() || c(!1); let { navigator: i } = t.useContext(B), { matches: s } = t.useContext(z), o = s[s.length - 1], l = o ? o.params : {}, u = (o && o.pathname, o ? o.pathnameBase : "/"); o && o.route; let h, d = G(); if (n) { var f; let e = "string" === typeof n ? p(n) : n; "/" === u || (null == (f = e.pathname) ? void 0 : f.startsWith(u)) || c(!1), h = e } else h = d; let m = h.pathname || "/", g = y(e, { pathname: "/" === u ? m : m.slice(u.length) || "/" }); let v = Y(g && g.map((e => Object.assign({}, e, { params: Object.assign({}, l, e.params), pathname: O([u, i.encodeLocation ? i.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? u : O([u, i.encodeLocation ? i.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) }))), s, r); return n && v ? t.createElement(U.Provider, { value: { location: M({ pathname: "/", search: "", hash: "", state: null, key: "default" }, h), navigationType: a.Pop } }, v) : v } function Q() { let e = function () { var e; let n = t.useContext(q), r = Z(J.UseRouteError), i = ee(J.UseRouteError); if (n) return n; return null == (e = r.errors) ? void 0 : e[i] }(), n = P(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), r = e instanceof Error ? e.stack : null, i = "rgba(200,200,200, 0.5)", s = { padding: "0.5rem", backgroundColor: i }; return t.createElement(t.Fragment, null, t.createElement("h2", null, "Unexpected Application Error!"), t.createElement("h3", { style: { fontStyle: "italic" } }, n), r ? t.createElement("pre", { style: s }, r) : null, null) } const W = t.createElement(Q, null); class $ extends t.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error || t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return this.state.error ? t.createElement(z.Provider, { value: this.props.routeContext }, t.createElement(q.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function X(e) { let { routeContext: n, match: r, children: i } = e, s = t.useContext(j); return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id), t.createElement(z.Provider, { value: n }, i) } function Y(e, n, r) { var i; if (void 0 === n && (n = []), void 0 === r && (r = null), null == e) { var s; if (null == (s = r) || !s.errors) return null; e = r.matches } let o = e, a = null == (i = r) ? void 0 : i.errors; if (null != a) { let e = o.findIndex((e => e.route.id && (null == a ? void 0 : a[e.route.id]))); e >= 0 || c(!1), o = o.slice(0, Math.min(o.length, e + 1)) } return o.reduceRight(((e, i, s) => { let l = i.route.id ? null == a ? void 0 : a[i.route.id] : null, c = null; r && (c = i.route.errorElement || W); let u = n.concat(o.slice(0, s + 1)), h = () => { let n; return n = l ? c : i.route.Component ? t.createElement(i.route.Component, null) : i.route.element ? i.route.element : e, t.createElement(X, { match: i, routeContext: { outlet: e, matches: u, isDataRoute: null != r }, children: n }) }; return r && (i.route.ErrorBoundary || i.route.errorElement || 0 === s) ? t.createElement($, { location: r.location, revalidation: r.revalidation, component: c, error: l, children: h(), routeContext: { outlet: null, matches: u, isDataRoute: !0 } }) : h() }), null) } var J = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(J || {}); function Z(e) { let n = t.useContext(V); return n || c(!1), n } function ee(e) { let n = function (e) { let n = t.useContext(z); return n || c(!1), n }(), r = n.matches[n.matches.length - 1]; return r.route.id || c(!1), r.route.id } r.startTransition; function te(e) { c(!1) } function ne(e) { let { basename: n = "/", children: r = null, location: i, navigationType: s = a.Pop, navigator: o, static: l = !1 } = e; K() && c(!1); let u = n.replace(/^\/*/, "/"), h = t.useMemo((() => ({ basename: u, navigator: o, static: l })), [u, o, l]); "string" === typeof i && (i = p(i)); let { pathname: d = "/", search: f = "", hash: m = "", state: g = null, key: y = "default" } = i, v = t.useMemo((() => { let e = A(d, u); return null == e ? null : { location: { pathname: e, search: f, hash: m, state: g, key: y }, navigationType: s } }), [u, d, f, m, g, y, s]); return null == v ? null : t.createElement(B.Provider, { value: h }, t.createElement(U.Provider, { children: r, value: v })) } function re(e) { let { children: t, location: n } = e; return H(ie(t), n) } new Promise((() => { })); t.Component; function ie(e, n) { void 0 === n && (n = []); let r = []; return t.Children.forEach(e, ((e, i) => { if (!t.isValidElement(e)) return; let s = [...n, i]; if (e.type === t.Fragment) return void r.push.apply(r, ie(e.props.children, s)); e.type !== te && c(!1), e.props.index && e.props.children && c(!1); let o = { id: e.props.id || s.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (o.children = ie(e.props.children, s)), r.push(o) })), r } new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); new Map; const se = r.startTransition; function oe(e) { let { basename: n, children: r, future: i, window: s } = e, o = t.useRef(); var a; null == o.current && (o.current = (void 0 === (a = { window: s, v5Compat: !0 }) && (a = {}), m((function (e, t) { let { pathname: n, search: r, hash: i } = e.location; return d("", { pathname: n, search: r, hash: i }, t.state && t.state.usr || null, t.state && t.state.key || "default") }), (function (e, t) { return "string" === typeof t ? t : f(t) }), null, a))); let l = o.current, [c, u] = t.useState({ action: l.action, location: l.location }), { v7_startTransition: h } = i || {}, p = t.useCallback((e => { h && se ? se((() => u(e))) : u(e) }), [u, h]); return t.useLayoutEffect((() => l.listen(p)), [l, p]), t.createElement(ne, { basename: n, children: r, location: c.location, navigationType: c.action, navigator: l }) } "undefined" !== typeof window && "undefined" !== typeof window.document && window.document.createElement; var ae, le; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(ae || (ae = {})), function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" }(le || (le = {})); var ce = n(184); const ue = () => (0, ce.jsx)(ce.Fragment, { children: (0, ce.jsxs)("div", { className: "navbar", children: [(0, ce.jsx)("img", { src: "https://www.freeiconspng.com/thumbs/blogger-logo-icon-png/blogger-logo-icon-png-22.png", className: "logo", alt: "Loading your Logo" }), (0, ce.jsxs)("ul", { className: "links-container", children: [(0, ce.jsx)("li", { className: "link-item", children: (0, ce.jsx)("a", { href: "/", className: "link", children: "Home" }) }), (0, ce.jsx)("li", { className: "link-item", children: (0, ce.jsx)("a", { href: "/editor", className: "link", children: "editor" }) })] })] }) }), he = function (e) { const t = []; let n = 0; for (let r = 0; r < e.length; r++) { let i = e.charCodeAt(r); i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = i >> 6 | 192, t[n++] = 63 & i | 128) : 55296 === (64512 & i) && r + 1 < e.length && 56320 === (64512 & e.charCodeAt(r + 1)) ? (i = 65536 + ((1023 & i) << 10) + (1023 & e.charCodeAt(++r)), t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128) : (t[n++] = i >> 12 | 224, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128) } return t }, de = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: "function" === typeof atob, encodeByteArray(e, t) { if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = []; for (let i = 0; i < e.length; i += 3) { const t = e[i], s = i + 1 < e.length, o = s ? e[i + 1] : 0, a = i + 2 < e.length, l = a ? e[i + 2] : 0, c = t >> 2, u = (3 & t) << 4 | o >> 4; let h = (15 & o) << 2 | l >> 6, d = 63 & l; a || (d = 64, s || (h = 64)), r.push(n[c], n[u], n[h], n[d]) } return r.join("") }, encodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(he(e), t) }, decodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function (e) { const t = []; let n = 0, r = 0; for (; n < e.length;) { const i = e[n++]; if (i < 128) t[r++] = String.fromCharCode(i); else if (i > 191 && i < 224) { const s = e[n++]; t[r++] = String.fromCharCode((31 & i) << 6 | 63 & s) } else if (i > 239 && i < 365) { const s = ((7 & i) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536; t[r++] = String.fromCharCode(55296 + (s >> 10)), t[r++] = String.fromCharCode(56320 + (1023 & s)) } else { const s = e[n++], o = e[n++]; t[r++] = String.fromCharCode((15 & i) << 12 | (63 & s) << 6 | 63 & o) } } return t.join("") }(this.decodeStringToByteArray(e, t)) }, decodeStringToByteArray(e, t) { this.init_(); const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = []; for (let i = 0; i < e.length;) { const t = n[e.charAt(i++)], s = i < e.length ? n[e.charAt(i)] : 0; ++i; const o = i < e.length ? n[e.charAt(i)] : 64; ++i; const a = i < e.length ? n[e.charAt(i)] : 64; if (++i, null == t || null == s || null == o || null == a) throw new fe; const l = t << 2 | s >> 4; if (r.push(l), 64 !== o) { const e = s << 4 & 240 | o >> 2; if (r.push(e), 64 !== a) { const e = o << 6 & 192 | a; r.push(e) } } } return r }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e) } } }; class fe extends Error { constructor() { super(...arguments), this.name = "DecodeBase64StringError" } } const pe = function (e) { return function (e) { const t = he(e); return de.encodeByteArray(t, !0) }(e).replace(/\./g, "") }, me = function (e) { try { return de.decodeString(e, !0) } catch (t) { console.error("base64Decode failed: ", t) } return null }; function ge(e, t) { if (!(t instanceof Object)) return t; switch (t.constructor) { case Date: return new Date(t.getTime()); case Object: void 0 === e && (e = {}); break; case Array: e = []; break; default: return t }for (const n in t) t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = ge(e[n], t[n])); return e } const ye = () => function () { if ("undefined" !== typeof self) return self; if ("undefined" !== typeof window) return window; if ("undefined" !== typeof n.g) return n.g; throw new Error("Unable to locate global object.") }().__FIREBASE_DEFAULTS__, ve = () => { try { return ye() || (() => { if ("undefined" === typeof process) return; const e = { NODE_ENV: "production", PUBLIC_URL: "", WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0 }.__FIREBASE_DEFAULTS__; return e ? JSON.parse(e) : void 0 })() || (() => { if ("undefined" === typeof document) return; let e; try { e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch (n) { return } const t = e && me(e[1]); return t && JSON.parse(t) })() } catch (e) { return void console.info("Unable to get __FIREBASE_DEFAULTS__ due to: ".concat(e)) } }, we = () => { var e; return null === (e = ve()) || void 0 === e ? void 0 : e.config }; class be { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise(((e, t) => { this.resolve = e, this.reject = t })) } wrapCallback(e) { return (t, n) => { t ? this.reject(t) : this.resolve(n), "function" === typeof e && (this.promise.catch((() => { })), 1 === e.length ? e(t) : e(t, n)) } } } function Ee() { return "undefined" !== typeof navigator && "string" === typeof navigator.userAgent ? navigator.userAgent : "" } function Se() { return !function () { var e; const t = null === (e = ve()) || void 0 === e ? void 0 : e.forceEnvironment; if ("node" === t) return !0; if ("browser" === t) return !1; try { return "[object process]" === Object.prototype.toString.call(n.g.process) } catch (r) { return !1 } }() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") } function _e() { try { return "object" === typeof indexedDB } catch (e) { return !1 } } class xe extends Error { constructor(e, t, n) { super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, xe.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Ie.prototype.create) } } class Ie { constructor(e, t, n) { this.service = e, this.serviceName = t, this.errors = n } create(e) { const t = (arguments.length <= 1 ? void 0 : arguments[1]) || {}, n = "".concat(this.service, "/").concat(e), r = this.errors[e], i = r ? function (e, t) { return e.replace(Te, ((e, n) => { const r = t[n]; return null != r ? String(r) : "<".concat(n, "?>") })) }(r, t) : "Error", s = "".concat(this.serviceName, ": ").concat(i, " (").concat(n, ")."); return new xe(n, s, t) } } const Te = /\{\$([^}]+)}/g; function ke(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function Ce(e, t) { if (e === t) return !0; const n = Object.keys(e), r = Object.keys(t); for (const i of n) { if (!r.includes(i)) return !1; const n = e[i], s = t[i]; if (Ne(n) && Ne(s)) { if (!Ce(n, s)) return !1 } else if (n !== s) return !1 } for (const i of r) if (!n.includes(i)) return !1; return !0 } function Ne(e) { return null !== e && "object" === typeof e } function De(e, t) { const n = new Ae(e, t); return n.subscribe.bind(n) } class Ae { constructor(e, t) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = t, this.task.then((() => { e(this) })).catch((e => { this.error(e) })) } next(e) { this.forEachObserver((t => { t.next(e) })) } error(e) { this.forEachObserver((t => { t.error(e) })), this.close(e) } complete() { this.forEachObserver((e => { e.complete() })), this.close() } subscribe(e, t, n) { let r; if (void 0 === e && void 0 === t && void 0 === n) throw new Error("Missing Observer."); r = function (e, t) { if ("object" !== typeof e || null === e) return !1; for (const n of t) if (n in e && "function" === typeof e[n]) return !0; return !1 }(e, ["next", "error", "complete"]) ? e : { next: e, error: t, complete: n }, void 0 === r.next && (r.next = Oe), void 0 === r.error && (r.error = Oe), void 0 === r.complete && (r.complete = Oe); const i = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then((() => { try { this.finalError ? r.error(this.finalError) : r.complete() } catch (e) { } })), this.observers.push(r), i } unsubscribeOne(e) { void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this)) } forEachObserver(e) { if (!this.finalized) for (let t = 0; t < this.observers.length; t++)this.sendOne(t, e) } sendOne(e, t) { this.task.then((() => { if (void 0 !== this.observers && void 0 !== this.observers[e]) try { t(this.observers[e]) } catch (n) { "undefined" !== typeof console && console.error && console.error(n) } })) } close(e) { this.finalized || (this.finalized = !0, void 0 !== e && (this.finalError = e), this.task.then((() => { this.observers = void 0, this.onNoObservers = void 0 }))) } } function Oe() { } function Re(e) { return e && e._delegate ? e._delegate : e } class Pe { constructor(e, t, n) { this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(e) { return this.instantiationMode = e, this } setMultipleInstances(e) { return this.multipleInstances = e, this } setServiceProps(e) { return this.serviceProps = e, this } setInstanceCreatedCallback(e) { return this.onInstanceCreated = e, this } } const Le = "[DEFAULT]"; class Fe { constructor(e, t) { this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(e) { const t = this.normalizeInstanceIdentifier(e); if (!this.instancesDeferred.has(t)) { const e = new be; if (this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()) try { const n = this.getOrInitializeService({ instanceIdentifier: t }); n && e.resolve(n) } catch (n) { } } return this.instancesDeferred.get(t).promise } getImmediate(e) { var t; const n = this.normalizeInstanceIdentifier(null === e || void 0 === e ? void 0 : e.identifier), r = null !== (t = null === e || void 0 === e ? void 0 : e.optional) && void 0 !== t && t; if (!this.isInitialized(n) && !this.shouldAutoInitialize()) { if (r) return null; throw Error("Service ".concat(this.name, " is not available")) } try { return this.getOrInitializeService({ instanceIdentifier: n }) } catch (i) { if (r) return null; throw i } } getComponent() { return this.component } setComponent(e) { if (e.name !== this.name) throw Error("Mismatching Component ".concat(e.name, " for Provider ").concat(this.name, ".")); if (this.component) throw Error("Component for ".concat(this.name, " has already been provided")); if (this.component = e, this.shouldAutoInitialize()) { if (function (e) { return "EAGER" === e.instantiationMode }(e)) try { this.getOrInitializeService({ instanceIdentifier: Le }) } catch (t) { } for (const [e, n] of this.instancesDeferred.entries()) { const r = this.normalizeInstanceIdentifier(e); try { const e = this.getOrInitializeService({ instanceIdentifier: r }); n.resolve(e) } catch (t) { } } } } clearInstance() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le; this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e) } async delete() { const e = Array.from(this.instances.values()); await Promise.all([...e.filter((e => "INTERNAL" in e)).map((e => e.INTERNAL.delete())), ...e.filter((e => "_delete" in e)).map((e => e._delete()))]) } isComponentSet() { return null != this.component } isInitialized() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le; return this.instances.has(e) } getOptions() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le; return this.instancesOptions.get(e) || {} } initialize() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const { options: t = {} } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier); if (this.isInitialized(n)) throw Error("".concat(this.name, "(").concat(n, ") has already been initialized")); if (!this.isComponentSet()) throw Error("Component ".concat(this.name, " has not been registered yet")); const r = this.getOrInitializeService({ instanceIdentifier: n, options: t }); for (const [i, s] of this.instancesDeferred.entries()) { n === this.normalizeInstanceIdentifier(i) && s.resolve(r) } return r } onInit(e, t) { var n; const r = this.normalizeInstanceIdentifier(t), i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set; i.add(e), this.onInitCallbacks.set(r, i); const s = this.instances.get(r); return s && e(s, r), () => { i.delete(e) } } invokeOnInitCallbacks(e, t) { const n = this.onInitCallbacks.get(t); if (n) for (const r of n) try { r(e, t) } catch (Fm) { } } getOrInitializeService(e) { let { instanceIdentifier: t, options: n = {} } = e, r = this.instances.get(t); if (!r && this.component && (r = this.component.instanceFactory(this.container, { instanceIdentifier: (i = t, i === Le ? void 0 : i), options: n }), this.instances.set(t, r), this.instancesOptions.set(t, n), this.invokeOnInitCallbacks(r, t), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, t, r) } catch (Fm) { } var i; return r || null } normalizeInstanceIdentifier() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Le; return this.component ? this.component.multipleInstances ? e : Le : e } shouldAutoInitialize() { return !!this.component && "EXPLICIT" !== this.component.instantiationMode } } class Me { constructor(e) { this.name = e, this.providers = new Map } addComponent(e) { const t = this.getProvider(e.name); if (t.isComponentSet()) throw new Error("Component ".concat(e.name, " has already been registered with ").concat(this.name)); t.setComponent(e) } addOrOverwriteComponent(e) { this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e) } getProvider(e) { if (this.providers.has(e)) return this.providers.get(e); const t = new Fe(e, this); return this.providers.set(e, t), t } getProviders() { return Array.from(this.providers.values()) } } const je = []; var Ve; !function (e) { e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT" }(Ve || (Ve = {})); const Be = { debug: Ve.DEBUG, verbose: Ve.VERBOSE, info: Ve.INFO, warn: Ve.WARN, error: Ve.ERROR, silent: Ve.SILENT }, Ue = Ve.INFO, ze = { [Ve.DEBUG]: "log", [Ve.VERBOSE]: "log", [Ve.INFO]: "info", [Ve.WARN]: "warn", [Ve.ERROR]: "error" }, qe = function (e, t) { if (t < e.logLevel) return; const n = (new Date).toISOString(), r = ze[t]; if (!r) throw new Error("Attempted to log a message with an invalid logType (value: ".concat(t, ")")); for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)s[o - 2] = arguments[o]; console[r]("[".concat(n, "]  ").concat(e.name, ":"), ...s) }; class Ke { constructor(e) { this.name = e, this._logLevel = Ue, this._logHandler = qe, this._userLogHandler = null, je.push(this) } get logLevel() { return this._logLevel } set logLevel(e) { if (!(e in Ve)) throw new TypeError('Invalid value "'.concat(e, '" assigned to `logLevel`')); this._logLevel = e } setLogLevel(e) { this._logLevel = "string" === typeof e ? Be[e] : e } get logHandler() { return this._logHandler } set logHandler(e) { if ("function" !== typeof e) throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = e } get userLogHandler() { return this._userLogHandler } set userLogHandler(e) { this._userLogHandler = e } debug() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Ve.DEBUG, ...t), this._logHandler(this, Ve.DEBUG, ...t) } log() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Ve.VERBOSE, ...t), this._logHandler(this, Ve.VERBOSE, ...t) } info() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Ve.INFO, ...t), this._logHandler(this, Ve.INFO, ...t) } warn() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Ve.WARN, ...t), this._logHandler(this, Ve.WARN, ...t) } error() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._userLogHandler && this._userLogHandler(this, Ve.ERROR, ...t), this._logHandler(this, Ve.ERROR, ...t) } } const Ge = (e, t) => t.some((t => e instanceof t)); let He, Qe; const We = new WeakMap, $e = new WeakMap, Xe = new WeakMap, Ye = new WeakMap, Je = new WeakMap; let Ze = { get(e, t, n) { if (e instanceof IDBTransaction) { if ("done" === t) return $e.get(e); if ("objectStoreNames" === t) return e.objectStoreNames || Xe.get(e); if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]) } return nt(e[t]) }, set: (e, t, n) => (e[t] = n, !0), has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e }; function et(e) { return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (Qe || (Qe = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return e.apply(rt(this), n), nt(We.get(this)) } : function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return nt(e.apply(rt(this), n)) } : function (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; const s = e.call(rt(this), t, ...r); return Xe.set(s, t.sort ? t.sort() : [t]), nt(s) } } function tt(e) { return "function" === typeof e ? et(e) : (e instanceof IDBTransaction && function (e) { if ($e.has(e)) return; const t = new Promise(((t, n) => { const r = () => { e.removeEventListener("complete", i), e.removeEventListener("error", s), e.removeEventListener("abort", s) }, i = () => { t(), r() }, s = () => { n(e.error || new DOMException("AbortError", "AbortError")), r() }; e.addEventListener("complete", i), e.addEventListener("error", s), e.addEventListener("abort", s) })); $e.set(e, t) }(e), Ge(e, He || (He = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(e, Ze) : e) } function nt(e) { if (e instanceof IDBRequest) return function (e) { const t = new Promise(((t, n) => { const r = () => { e.removeEventListener("success", i), e.removeEventListener("error", s) }, i = () => { t(nt(e.result)), r() }, s = () => { n(e.error), r() }; e.addEventListener("success", i), e.addEventListener("error", s) })); return t.then((t => { t instanceof IDBCursor && We.set(t, e) })).catch((() => { })), Je.set(t, e), t }(e); if (Ye.has(e)) return Ye.get(e); const t = tt(e); return t !== e && (Ye.set(e, t), Je.set(t, e)), t } const rt = e => Je.get(e); const it = ["get", "getKey", "getAll", "getAllKeys", "count"], st = ["put", "add", "delete", "clear"], ot = new Map; function at(e, t) { if (!(e instanceof IDBDatabase) || t in e || "string" !== typeof t) return; if (ot.get(t)) return ot.get(t); const n = t.replace(/FromIndex$/, ""), r = t !== n, i = st.includes(n); if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !i && !it.includes(n)) return; const s = async function (e) { const t = this.transaction(e, i ? "readwrite" : "readonly"); let s = t.store; for (var o = arguments.length, a = new Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++)a[l - 1] = arguments[l]; return r && (s = s.index(a.shift())), (await Promise.all([s[n](...a), i && t.done]))[0] }; return ot.set(t, s), s } Ze = (e => ({ ...e, get: (t, n, r) => at(t, n) || e.get(t, n, r), has: (t, n) => !!at(t, n) || e.has(t, n) }))(Ze); class lt { constructor(e) { this.container = e } getPlatformInfoString() { return this.container.getProviders().map((e => { if (function (e) { const t = e.getComponent(); return "VERSION" === (null === t || void 0 === t ? void 0 : t.type) }(e)) { const t = e.getImmediate(); return "".concat(t.library, "/").concat(t.version) } return null })).filter((e => e)).join(" ") } } const ct = "@firebase/app", ut = "0.9.13", ht = new Ke("@firebase/app"), dt = "[DEFAULT]", ft = { [ct]: "fire-core", "@firebase/app-compat": "fire-core-compat", "@firebase/analytics": "fire-analytics", "@firebase/analytics-compat": "fire-analytics-compat", "@firebase/app-check": "fire-app-check", "@firebase/app-check-compat": "fire-app-check-compat", "@firebase/auth": "fire-auth", "@firebase/auth-compat": "fire-auth-compat", "@firebase/database": "fire-rtdb", "@firebase/database-compat": "fire-rtdb-compat", "@firebase/functions": "fire-fn", "@firebase/functions-compat": "fire-fn-compat", "@firebase/installations": "fire-iid", "@firebase/installations-compat": "fire-iid-compat", "@firebase/messaging": "fire-fcm", "@firebase/messaging-compat": "fire-fcm-compat", "@firebase/performance": "fire-perf", "@firebase/performance-compat": "fire-perf-compat", "@firebase/remote-config": "fire-rc", "@firebase/remote-config-compat": "fire-rc-compat", "@firebase/storage": "fire-gcs", "@firebase/storage-compat": "fire-gcs-compat", "@firebase/firestore": "fire-fst", "@firebase/firestore-compat": "fire-fst-compat", "fire-js": "fire-js", firebase: "fire-js-all" }, pt = new Map, mt = new Map; function gt(e, t) { try { e.container.addComponent(t) } catch (n) { ht.debug("Component ".concat(t.name, " failed to register with FirebaseApp ").concat(e.name), n) } } function yt(e, t) { e.container.addOrOverwriteComponent(t) } function vt(e) { const t = e.name; if (mt.has(t)) return ht.debug("There were multiple attempts to register component ".concat(t, ".")), !1; mt.set(t, e); for (const n of pt.values()) gt(n, e); return !0 } function wt(e, t) { const n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return n && n.triggerHeartbeat(), e.container.getProvider(t) } function bt(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : dt; wt(e, t).clearInstance(n) } function Et() { mt.clear() } const St = new Ie("app", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first", "bad-app-name": "Illegal App name: '{$appName}", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}." }); class _t { constructor(e, t, n) { this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new Pe("app", (() => this), "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this.checkDestroyed(), this._automaticDataCollectionEnabled = e } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(e) { this._isDeleted = e } checkDestroyed() { if (this.isDeleted) throw St.create("app-deleted", { appName: this._name }) } } const xt = "9.23.0"; function It(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e; if ("object" !== typeof t) { t = { name: t } } const r = Object.assign({ name: dt, automaticDataCollectionEnabled: !1 }, t), i = r.name; if ("string" !== typeof i || !i) throw St.create("bad-app-name", { appName: String(i) }); if (n || (n = we()), !n) throw St.create("no-options"); const s = pt.get(i); if (s) { if (Ce(n, s.options) && Ce(r, s.config)) return s; throw St.create("duplicate-app", { appName: i }) } const o = new Me(i); for (const l of mt.values()) o.addComponent(l); const a = new _t(n, r, o); return pt.set(i, a), a } function Tt() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : dt; const t = pt.get(e); if (!t && e === dt && we()) return It(); if (!t) throw St.create("no-app", { appName: e }); return t } function kt() { return Array.from(pt.values()) } async function Ct(e) { const t = e.name; pt.has(t) && (pt.delete(t), await Promise.all(e.container.getProviders().map((e => e.delete()))), e.isDeleted = !0) } function Nt(e, t, n) { var r; let i = null !== (r = ft[e]) && void 0 !== r ? r : e; n && (i += "-".concat(n)); const s = i.match(/\s|\//), o = t.match(/\s|\//); if (s || o) { const e = ['Unable to register library "'.concat(i, '" with version "').concat(t, '":')]; return s && e.push('library name "'.concat(i, '" contains illegal characters (whitespace or "/")')), s && o && e.push("and"), o && e.push('version name "'.concat(t, '" contains illegal characters (whitespace or "/")')), void ht.warn(e.join(" ")) } vt(new Pe("".concat(i, "-version"), (() => ({ library: i, version: t })), "VERSION")) } function Dt(e, t) { if (null !== e && "function" !== typeof e) throw St.create("invalid-log-argument"); !function (e, t) { for (const n of je) { let r = null; t && t.level && (r = Be[t.level]), n.userLogHandler = null === e ? null : function (t, n) { for (var i = arguments.length, s = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)s[o - 2] = arguments[o]; const a = s.map((e => { if (null == e) return null; if ("string" === typeof e) return e; if ("number" === typeof e || "boolean" === typeof e) return e.toString(); if (e instanceof Error) return e.message; try { return JSON.stringify(e) } catch (t) { return null } })).filter((e => e)).join(" "); n >= (null !== r && void 0 !== r ? r : t.logLevel) && e({ level: Ve[n].toLowerCase(), message: a, args: s, type: t.name }) } } }(e, t) } function At(e) { var t; t = e, je.forEach((e => { e.setLogLevel(t) })) } const Ot = "firebase-heartbeat-database", Rt = 1, Pt = "firebase-heartbeat-store"; let Lt = null; function Ft() { return Lt || (Lt = function (e, t) { let { blocked: n, upgrade: r, blocking: i, terminated: s } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const o = indexedDB.open(e, t), a = nt(o); return r && o.addEventListener("upgradeneeded", (e => { r(nt(o.result), e.oldVersion, e.newVersion, nt(o.transaction), e) })), n && o.addEventListener("blocked", (e => n(e.oldVersion, e.newVersion, e))), a.then((e => { s && e.addEventListener("close", (() => s())), i && e.addEventListener("versionchange", (e => i(e.oldVersion, e.newVersion, e))) })).catch((() => { })), a }(Ot, Rt, { upgrade: (e, t) => { if (0 === t) e.createObjectStore(Pt) } }).catch((e => { throw St.create("idb-open", { originalErrorMessage: e.message }) }))), Lt } async function Mt(e, t) { try { const n = (await Ft()).transaction(Pt, "readwrite"), r = n.objectStore(Pt); await r.put(t, jt(e)), await n.done } catch (n) { if (n instanceof xe) ht.warn(n.message); else { const e = St.create("idb-set", { originalErrorMessage: null === n || void 0 === n ? void 0 : n.message }); ht.warn(e.message) } } } function jt(e) { return "".concat(e.name, "!").concat(e.options.appId) } class Vt { constructor(e) { this.container = e, this._heartbeatsCache = null; const t = this.container.getProvider("app").getImmediate(); this._storage = new Ut(t), this._heartbeatsCachePromise = this._storage.read().then((e => (this._heartbeatsCache = e, e))) } async triggerHeartbeat() { const e = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), t = Bt(); if (null === this._heartbeatsCache && (this._heartbeatsCache = await this._heartbeatsCachePromise), this._heartbeatsCache.lastSentHeartbeatDate !== t && !this._heartbeatsCache.heartbeats.some((e => e.date === t))) return this._heartbeatsCache.heartbeats.push({ date: t, agent: e }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((e => { const t = new Date(e.date).valueOf(); return Date.now() - t <= 2592e6 })), this._storage.overwrite(this._heartbeatsCache) } async getHeartbeatsHeader() { if (null === this._heartbeatsCache && await this._heartbeatsCachePromise, null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length) return ""; const e = Bt(), { heartbeatsToSend: t, unsentEntries: n } = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1024; const n = []; let r = e.slice(); for (const i of e) { const e = n.find((e => e.agent === i.agent)); if (e) { if (e.dates.push(i.date), zt(n) > t) { e.dates.pop(); break } } else if (n.push({ agent: i.agent, dates: [i.date] }), zt(n) > t) { n.pop(); break } r = r.slice(1) } return { heartbeatsToSend: n, unsentEntries: r } }(this._heartbeatsCache.heartbeats), r = pe(JSON.stringify({ version: 2, heartbeats: t })); return this._heartbeatsCache.lastSentHeartbeatDate = e, n.length > 0 ? (this._heartbeatsCache.heartbeats = n, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), r } } function Bt() { return (new Date).toISOString().substring(0, 10) } class Ut { constructor(e) { this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return !!_e() && new Promise(((e, t) => { try { let n = !0; const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r); i.onsuccess = () => { i.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0) }, i.onupgradeneeded = () => { n = !1 }, i.onerror = () => { var e; t((null === (e = i.error) || void 0 === e ? void 0 : e.message) || "") } } catch (n) { t(n) } })).then((() => !0)).catch((() => !1)) } async read() { if (await this._canUseIndexedDBPromise) { const e = await async function (e) { try { const t = await Ft(); return await t.transaction(Pt).objectStore(Pt).get(jt(e)) } catch (t) { if (t instanceof xe) ht.warn(t.message); else { const e = St.create("idb-get", { originalErrorMessage: null === t || void 0 === t ? void 0 : t.message }); ht.warn(e.message) } } }(this.app); return e || { heartbeats: [] } } return { heartbeats: [] } } async overwrite(e) { var t; if (await this._canUseIndexedDBPromise) { const n = await this.read(); return Mt(this.app, { lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate, heartbeats: e.heartbeats }) } } async add(e) { var t; if (await this._canUseIndexedDBPromise) { const n = await this.read(); return Mt(this.app, { lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate, heartbeats: [...n.heartbeats, ...e.heartbeats] }) } } } function zt(e) { return pe(JSON.stringify({ version: 2, heartbeats: e })).length } var qt; qt = "", vt(new Pe("platform-logger", (e => new lt(e)), "PRIVATE")), vt(new Pe("heartbeat", (e => new Vt(e)), "PRIVATE")), Nt(ct, ut, qt), Nt(ct, ut, "esm2017"), Nt("fire-js", ""); class Kt { constructor(e, t) { this._delegate = e, this.firebase = t, gt(e, new Pe("app-compat", (() => this), "PUBLIC")), this.container = e.container } get automaticDataCollectionEnabled() { return this._delegate.automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this._delegate.automaticDataCollectionEnabled = e } get name() { return this._delegate.name } get options() { return this._delegate.options } delete() { return new Promise((e => { this._delegate.checkDestroyed(), e() })).then((() => (this.firebase.INTERNAL.removeApp(this.name), Ct(this._delegate)))) } _getService(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : dt; var n; this._delegate.checkDestroyed(); const r = this._delegate.container.getProvider(e); return r.isInitialized() || "EXPLICIT" !== (null === (n = r.getComponent()) || void 0 === n ? void 0 : n.instantiationMode) || r.initialize(), r.getImmediate({ identifier: t }) } _removeServiceInstance(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : dt; this._delegate.container.getProvider(e).clearInstance(t) } _addComponent(e) { gt(this._delegate, e) } _addOrOverwriteComponent(e) { yt(this._delegate, e) } toJSON() { return { name: this.name, automaticDataCollectionEnabled: this.automaticDataCollectionEnabled, options: this.options } } } const Gt = new Ie("app-compat", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance." }); const Ht = function t() { const n = function (t) { const n = {}, r = { __esModule: !0, initializeApp: function (e) { const i = It(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}); if (ke(n, i.name)) return n[i.name]; const s = new t(i, r); return n[i.name] = s, s }, app: i, registerVersion: Nt, setLogLevel: At, onLog: Dt, apps: null, SDK_VERSION: xt, INTERNAL: { registerComponent: function (e) { const n = e.name, s = n.replace("-compat", ""); if (vt(e) && "PUBLIC" === e.type) { const o = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i(); if ("function" !== typeof e[s]) throw Gt.create("invalid-app-argument", { appName: n }); return e[s]() }; void 0 !== e.serviceProps && ge(o, e.serviceProps), r[s] = o, t.prototype[s] = function () { const t = this._getService.bind(this, n); for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s]; return t.apply(this, e.multipleInstances ? i : []) } } return "PUBLIC" === e.type ? r[s] : null }, removeApp: function (e) { delete n[e] }, useAsService: function (e, t) { return "serverAuth" === t ? null : t }, modularAPIs: e } }; function i(e) { if (!ke(n, e = e || dt)) throw Gt.create("no-app", { appName: e }); return n[e] } return r.default = r, Object.defineProperty(r, "apps", { get: function () { return Object.keys(n).map((e => n[e])) } }), i.App = t, r }(Kt); return n.INTERNAL = Object.assign(Object.assign({}, n.INTERNAL), { createFirebaseNamespace: t, extendNamespace: function (e) { ge(n, e) }, createSubscribe: De, ErrorFactory: Ie, deepExtend: ge }), n }(), Qt = new Ke("@firebase/app-compat"); if ("object" === typeof self && self.self === self && void 0 !== self.firebase) { Qt.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  "); const e = self.firebase.SDK_VERSION; e && e.indexOf("LITE") >= 0 && Qt.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ") } const Wt = Ht; !function (e) { Nt("@firebase/app-compat", "0.2.13", e) }(); Wt.registerVersion("firebase", "9.23.0", "app-compat"); var $t, Xt = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : {}, Yt = {}, Jt = Jt || {}, Zt = Xt || self; function en(e) { var t = typeof e; return "array" == (t = "object" != t ? t : e ? Array.isArray(e) ? "array" : t : "null") || "object" == t && "number" == typeof e.length } function tn(e) { var t = typeof e; return "object" == t && null != e || "function" == t } var nn = "closure_uid_" + (1e9 * Math.random() >>> 0), rn = 0; function sn(e, t, n) { return e.call.apply(e.bind, arguments) } function on(e, t, n) { if (!e) throw Error(); if (2 < arguments.length) { var r = Array.prototype.slice.call(arguments, 2); return function () { var n = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(n, r), e.apply(t, n) } } return function () { return e.apply(t, arguments) } } function an(e, t, n) { return (an = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? sn : on).apply(null, arguments) } function ln(e, t) { var n = Array.prototype.slice.call(arguments, 1); return function () { var t = n.slice(); return t.push.apply(t, arguments), e.apply(this, t) } } function cn(e, t) { function n() { } n.prototype = t.prototype, e.$ = t.prototype, e.prototype = new n, e.prototype.constructor = e, e.ac = function (e, n, r) { for (var i = Array(arguments.length - 2), s = 2; s < arguments.length; s++)i[s - 2] = arguments[s]; return t.prototype[n].apply(e, i) } } function un() { this.s = this.s, this.o = this.o } un.prototype.s = !1, un.prototype.sa = function () { var e; !this.s && (this.s = !0, this.N(), 0) && (e = this, Object.prototype.hasOwnProperty.call(e, nn) && e[nn] || (e[nn] = ++rn)) }, un.prototype.N = function () { if (this.o) for (; this.o.length;)this.o.shift()() }; const hn = Array.prototype.indexOf ? function (e, t) { return Array.prototype.indexOf.call(e, t, void 0) } : function (e, t) { if ("string" === typeof e) return "string" !== typeof t || 1 != t.length ? -1 : e.indexOf(t, 0); for (let n = 0; n < e.length; n++)if (n in e && e[n] === t) return n; return -1 }; function dn(e) { const t = e.length; if (0 < t) { const n = Array(t); for (let r = 0; r < t; r++)n[r] = e[r]; return n } return [] } function fn(e, t) { for (let n = 1; n < arguments.length; n++) { const t = arguments[n]; if (en(t)) { const n = e.length || 0, r = t.length || 0; e.length = n + r; for (let i = 0; i < r; i++)e[n + i] = t[i] } else e.push(t) } } function pn(e, t) { this.type = e, this.g = this.target = t, this.defaultPrevented = !1 } pn.prototype.h = function () { this.defaultPrevented = !0 }; var mn = function () { if (!Zt.addEventListener || !Object.defineProperty) return !1; var e = !1, t = Object.defineProperty({}, "passive", { get: function () { e = !0 } }); try { Zt.addEventListener("test", (() => { }), t), Zt.removeEventListener("test", (() => { }), t) } catch (n) { } return e }(); function gn(e) { return /^[\s\xa0]*$/.test(e) } function yn() { var e = Zt.navigator; return e && (e = e.userAgent) ? e : "" } function vn(e) { return -1 != yn().indexOf(e) } function wn(e) { return wn[" "](e), e } wn[" "] = function () { }; var bn, En, Sn = vn("Opera"), _n = vn("Trident") || vn("MSIE"), xn = vn("Edge"), In = xn || _n, Tn = vn("Gecko") && !(-1 != yn().toLowerCase().indexOf("webkit") && !vn("Edge")) && !(vn("Trident") || vn("MSIE")) && !vn("Edge"), kn = -1 != yn().toLowerCase().indexOf("webkit") && !vn("Edge"); function Cn() { var e = Zt.document; return e ? e.documentMode : void 0 } e: { var Nn = "", Dn = function () { var e = yn(); return Tn ? /rv:([^\);]+)(\)|;)/.exec(e) : xn ? /Edge\/([\d\.]+)/.exec(e) : _n ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(e) : kn ? /WebKit\/(\S+)/.exec(e) : Sn ? /(?:Version)[ \/]?(\S+)/.exec(e) : void 0 }(); if (Dn && (Nn = Dn ? Dn[1] : ""), _n) { var An = Cn(); if (null != An && An > parseFloat(Nn)) { bn = String(An); break e } } bn = Nn } if (Zt.document && _n) { var On = Cn(); En = On || (parseInt(bn, 10) || void 0) } else En = void 0; var Rn = En; function Pn(e, t) { if (pn.call(this, e ? e.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, e) { var n = this.type = e.type, r = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null; if (this.target = e.target || e.srcElement, this.g = t, t = e.relatedTarget) { if (Tn) { e: { try { wn(t.nodeName); var i = !0; break e } catch (s) { } i = !1 } i || (t = null) } } else "mouseover" == n ? t = e.fromElement : "mouseout" == n && (t = e.toElement); this.relatedTarget = t, r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0) : (this.clientX = void 0 !== e.clientX ? e.clientX : e.pageX, this.clientY = void 0 !== e.clientY ? e.clientY : e.pageY, this.screenX = e.screenX || 0, this.screenY = e.screenY || 0), this.button = e.button, this.key = e.key || "", this.ctrlKey = e.ctrlKey, this.altKey = e.altKey, this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.pointerId = e.pointerId || 0, this.pointerType = "string" === typeof e.pointerType ? e.pointerType : Ln[e.pointerType] || "", this.state = e.state, this.i = e, e.defaultPrevented && Pn.$.h.call(this) } } cn(Pn, pn); var Ln = { 2: "touch", 3: "pen", 4: "mouse" }; Pn.prototype.h = function () { Pn.$.h.call(this); var e = this.i; e.preventDefault ? e.preventDefault() : e.returnValue = !1 }; var Fn = "closure_listenable_" + (1e6 * Math.random() | 0), Mn = 0; function jn(e, t, n, r, i) { this.listener = e, this.proxy = null, this.src = t, this.type = n, this.capture = !!r, this.la = i, this.key = ++Mn, this.fa = this.ia = !1 } function Vn(e) { e.fa = !0, e.listener = null, e.proxy = null, e.src = null, e.la = null } function Bn(e, t, n) { for (const r in e) t.call(n, e[r], r, e) } function Un(e) { const t = {}; for (const n in e) t[n] = e[n]; return t } const zn = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function qn(e, t) { let n, r; for (let i = 1; i < arguments.length; i++) { for (n in r = arguments[i], r) e[n] = r[n]; for (let t = 0; t < zn.length; t++)n = zn[t], Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]) } } function Kn(e) { this.src = e, this.g = {}, this.h = 0 } function Gn(e, t) { var n = t.type; if (n in e.g) { var r, i = e.g[n], s = hn(i, t); (r = 0 <= s) && Array.prototype.splice.call(i, s, 1), r && (Vn(t), 0 == e.g[n].length && (delete e.g[n], e.h--)) } } function Hn(e, t, n, r) { for (var i = 0; i < e.length; ++i) { var s = e[i]; if (!s.fa && s.listener == t && s.capture == !!n && s.la == r) return i } return -1 } Kn.prototype.add = function (e, t, n, r, i) { var s = e.toString(); (e = this.g[s]) || (e = this.g[s] = [], this.h++); var o = Hn(e, t, r, i); return -1 < o ? (t = e[o], n || (t.ia = !1)) : ((t = new jn(t, this.src, s, !!r, i)).ia = n, e.push(t)), t }; var Qn = "closure_lm_" + (1e6 * Math.random() | 0), Wn = {}; function $n(e, t, n, r, i) { if (r && r.once) return Yn(e, t, n, r, i); if (Array.isArray(t)) { for (var s = 0; s < t.length; s++)$n(e, t[s], n, r, i); return null } return n = ir(n), e && e[Fn] ? e.O(t, n, tn(r) ? !!r.capture : !!r, i) : Xn(e, t, n, !1, r, i) } function Xn(e, t, n, r, i, s) { if (!t) throw Error("Invalid event type"); var o = tn(i) ? !!i.capture : !!i, a = nr(e); if (a || (e[Qn] = a = new Kn(e)), (n = a.add(t, n, r, o, s)).proxy) return n; if (r = function () { function e(n) { return t.call(e.src, e.listener, n) } const t = tr; return e }(), n.proxy = r, r.src = e, r.listener = n, e.addEventListener) mn || (i = o), void 0 === i && (i = !1), e.addEventListener(t.toString(), r, i); else if (e.attachEvent) e.attachEvent(er(t.toString()), r); else { if (!e.addListener || !e.removeListener) throw Error("addEventListener and attachEvent are unavailable."); e.addListener(r) } return n } function Yn(e, t, n, r, i) { if (Array.isArray(t)) { for (var s = 0; s < t.length; s++)Yn(e, t[s], n, r, i); return null } return n = ir(n), e && e[Fn] ? e.P(t, n, tn(r) ? !!r.capture : !!r, i) : Xn(e, t, n, !0, r, i) } function Jn(e, t, n, r, i) { if (Array.isArray(t)) for (var s = 0; s < t.length; s++)Jn(e, t[s], n, r, i); else r = tn(r) ? !!r.capture : !!r, n = ir(n), e && e[Fn] ? (e = e.i, (t = String(t).toString()) in e.g && (-1 < (n = Hn(s = e.g[t], n, r, i)) && (Vn(s[n]), Array.prototype.splice.call(s, n, 1), 0 == s.length && (delete e.g[t], e.h--)))) : e && (e = nr(e)) && (t = e.g[t.toString()], e = -1, t && (e = Hn(t, n, r, i)), (n = -1 < e ? t[e] : null) && Zn(n)) } function Zn(e) { if ("number" !== typeof e && e && !e.fa) { var t = e.src; if (t && t[Fn]) Gn(t.i, e); else { var n = e.type, r = e.proxy; t.removeEventListener ? t.removeEventListener(n, r, e.capture) : t.detachEvent ? t.detachEvent(er(n), r) : t.addListener && t.removeListener && t.removeListener(r), (n = nr(t)) ? (Gn(n, e), 0 == n.h && (n.src = null, t[Qn] = null)) : Vn(e) } } } function er(e) { return e in Wn ? Wn[e] : Wn[e] = "on" + e } function tr(e, t) { if (e.fa) e = !0; else { t = new Pn(t, this); var n = e.listener, r = e.la || e.src; e.ia && Zn(e), e = n.call(r, t) } return e } function nr(e) { return (e = e[Qn]) instanceof Kn ? e : null } var rr = "__closure_events_fn_" + (1e9 * Math.random() >>> 0); function ir(e) { return "function" === typeof e ? e : (e[rr] || (e[rr] = function (t) { return e.handleEvent(t) }), e[rr]) } function sr() { un.call(this), this.i = new Kn(this), this.S = this, this.J = null } function or(e, t) { var n, r = e.J; if (r) for (n = []; r; r = r.J)n.push(r); if (e = e.S, r = t.type || t, "string" === typeof t) t = new pn(t, e); else if (t instanceof pn) t.target = t.target || e; else { var i = t; qn(t = new pn(r, e), i) } if (i = !0, n) for (var s = n.length - 1; 0 <= s; s--) { var o = t.g = n[s]; i = ar(o, r, !0, t) && i } if (i = ar(o = t.g = e, r, !0, t) && i, i = ar(o, r, !1, t) && i, n) for (s = 0; s < n.length; s++)i = ar(o = t.g = n[s], r, !1, t) && i } function ar(e, t, n, r) { if (!(t = e.i.g[String(t)])) return !0; t = t.concat(); for (var i = !0, s = 0; s < t.length; ++s) { var o = t[s]; if (o && !o.fa && o.capture == n) { var a = o.listener, l = o.la || o.src; o.ia && Gn(e.i, o), i = !1 !== a.call(l, r) && i } } return i && !r.defaultPrevented } cn(sr, un), sr.prototype[Fn] = !0, sr.prototype.removeEventListener = function (e, t, n, r) { Jn(this, e, t, n, r) }, sr.prototype.N = function () { if (sr.$.N.call(this), this.i) { var e, t = this.i; for (e in t.g) { for (var n = t.g[e], r = 0; r < n.length; r++)Vn(n[r]); delete t.g[e], t.h-- } } this.J = null }, sr.prototype.O = function (e, t, n, r) { return this.i.add(String(e), t, !1, n, r) }, sr.prototype.P = function (e, t, n, r) { return this.i.add(String(e), t, !0, n, r) }; var lr = Zt.JSON.stringify; function cr() { var e = gr; let t = null; return e.g && (t = e.g, e.g = e.g.next, e.g || (e.h = null), t.next = null), t } var ur = new class { constructor(e, t) { this.i = e, this.j = t, this.h = 0, this.g = null } get() { let e; return 0 < this.h ? (this.h--, e = this.g, this.g = e.next, e.next = null) : e = this.i(), e } }((() => new hr), (e => e.reset())); class hr { constructor() { this.next = this.g = this.h = null } set(e, t) { this.h = e, this.g = t, this.next = null } reset() { this.next = this.g = this.h = null } } function dr(e) { var t = 1; e = e.split(":"); const n = []; for (; 0 < t && e.length;)n.push(e.shift()), t--; return e.length && n.push(e.join(":")), n } function fr(e) { Zt.setTimeout((() => { throw e }), 0) } let pr, mr = !1, gr = new class { constructor() { this.h = this.g = null } add(e, t) { const n = ur.get(); n.set(e, t), this.h ? this.h.next = n : this.g = n, this.h = n } }, yr = () => { const e = Zt.Promise.resolve(void 0); pr = () => { e.then(vr) } }; var vr = () => { for (var e; e = cr();) { try { e.h.call(e.g) } catch (n) { fr(n) } var t = ur; t.j(e), 100 > t.h && (t.h++, e.next = t.g, t.g = e) } mr = !1 }; function wr(e, t) { sr.call(this), this.h = e || 1, this.g = t || Zt, this.j = an(this.qb, this), this.l = Date.now() } function br(e) { e.ga = !1, e.T && (e.g.clearTimeout(e.T), e.T = null) } function Er(e, t, n) { if ("function" === typeof e) n && (e = an(e, n)); else { if (!e || "function" != typeof e.handleEvent) throw Error("Invalid listener argument"); e = an(e.handleEvent, e) } return 2147483647 < Number(t) ? -1 : Zt.setTimeout(e, t || 0) } function Sr(e) { e.g = Er((() => { e.g = null, e.i && (e.i = !1, Sr(e)) }), e.j); const t = e.h; e.h = null, e.m.apply(null, t) } cn(wr, sr), ($t = wr.prototype).ga = !1, $t.T = null, $t.qb = function () { if (this.ga) { var e = Date.now() - this.l; 0 < e && e < .8 * this.h ? this.T = this.g.setTimeout(this.j, this.h - e) : (this.T && (this.g.clearTimeout(this.T), this.T = null), or(this, "tick"), this.ga && (br(this), this.start())) } }, $t.start = function () { this.ga = !0, this.T || (this.T = this.g.setTimeout(this.j, this.h), this.l = Date.now()) }, $t.N = function () { wr.$.N.call(this), br(this), delete this.g }; class _r extends un { constructor(e, t) { super(), this.m = e, this.j = t, this.h = null, this.i = !1, this.g = null } l(e) { this.h = arguments, this.g ? this.i = !0 : Sr(this) } N() { super.N(), this.g && (Zt.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function xr(e) { un.call(this), this.h = e, this.g = {} } cn(xr, un); var Ir = []; function Tr(e, t, n, r) { Array.isArray(n) || (n && (Ir[0] = n.toString()), n = Ir); for (var i = 0; i < n.length; i++) { var s = $n(t, n[i], r || e.handleEvent, !1, e.h || e); if (!s) break; e.g[s.key] = s } } function kr(e) { Bn(e.g, (function (e, t) { this.g.hasOwnProperty(t) && Zn(e) }), e), e.g = {} } function Cr() { this.g = !0 } function Nr(e, t, n, r) { e.info((function () { return "XMLHTTP TEXT (" + t + "): " + function (e, t) { if (!e.g) return t; if (!t) return null; try { var n = JSON.parse(t); if (n) for (e = 0; e < n.length; e++)if (Array.isArray(n[e])) { var r = n[e]; if (!(2 > r.length)) { var i = r[1]; if (Array.isArray(i) && !(1 > i.length)) { var s = i[0]; if ("noop" != s && "stop" != s && "close" != s) for (var o = 1; o < i.length; o++)i[o] = "" } } } return lr(n) } catch (a) { return t } }(e, n) + (r ? " " + r : "") })) } xr.prototype.N = function () { xr.$.N.call(this), kr(this) }, xr.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }, Cr.prototype.Ea = function () { this.g = !1 }, Cr.prototype.info = function () { }; var Dr = {}, Ar = null; function Or() { return Ar = Ar || new sr } function Rr(e) { pn.call(this, Dr.Ta, e) } function Pr(e) { const t = Or(); or(t, new Rr(t)) } function Lr(e, t) { pn.call(this, Dr.STAT_EVENT, e), this.stat = t } function Fr(e) { const t = Or(); or(t, new Lr(t, e)) } function Mr(e, t) { pn.call(this, Dr.Ua, e), this.size = t } function jr(e, t) { if ("function" !== typeof e) throw Error("Fn must not be null and must be a function"); return Zt.setTimeout((function () { e() }), t) } Dr.Ta = "serverreachability", cn(Rr, pn), Dr.STAT_EVENT = "statevent", cn(Lr, pn), Dr.Ua = "timingevent", cn(Mr, pn); var Vr = { NO_ERROR: 0, rb: 1, Eb: 2, Db: 3, yb: 4, Cb: 5, Fb: 6, Qa: 7, TIMEOUT: 8, Ib: 9 }, Br = { wb: "complete", Sb: "success", Ra: "error", Qa: "abort", Kb: "ready", Lb: "readystatechange", TIMEOUT: "timeout", Gb: "incrementaldata", Jb: "progress", zb: "downloadprogress", $b: "uploadprogress" }; function Ur() { } function zr(e) { return e.h || (e.h = e.i()) } function qr() { } Ur.prototype.h = null; var Kr, Gr = { OPEN: "a", vb: "b", Ra: "c", Hb: "d" }; function Hr() { pn.call(this, "d") } function Qr() { pn.call(this, "c") } function Wr() { } function $r(e, t, n, r) { this.l = e, this.j = t, this.m = n, this.W = r || 1, this.U = new xr(this), this.P = Yr, e = In ? 125 : void 0, this.V = new wr(e), this.I = null, this.i = !1, this.s = this.A = this.v = this.L = this.G = this.Y = this.B = null, this.F = [], this.g = null, this.C = 0, this.o = this.u = null, this.ca = -1, this.J = !1, this.O = 0, this.M = null, this.ba = this.K = this.aa = this.S = !1, this.h = new Xr } function Xr() { this.i = null, this.g = "", this.h = !1 } cn(Hr, pn), cn(Qr, pn), cn(Wr, Ur), Wr.prototype.g = function () { return new XMLHttpRequest }, Wr.prototype.i = function () { return {} }, Kr = new Wr; var Yr = 45e3, Jr = {}, Zr = {}; function ei(e, t, n) { e.L = 1, e.v = wi(pi(t)), e.s = n, e.S = !0, ti(e, null) } function ti(e, t) { e.G = Date.now(), si(e), e.A = pi(e.v); var n = e.A, r = e.W; Array.isArray(r) || (r = [String(r)]), Oi(n.i, "t", r), e.C = 0, n = e.l.J, e.h = new Xr, e.g = Rs(e.l, n ? t : null, !e.s), 0 < e.O && (e.M = new _r(an(e.Pa, e, e.g), e.O)), Tr(e.U, e.g, "readystatechange", e.nb), t = e.I ? Un(e.I) : {}, e.s ? (e.u || (e.u = "POST"), t["Content-Type"] = "application/x-www-form-urlencoded", e.g.ha(e.A, e.u, e.s, t)) : (e.u = "GET", e.g.ha(e.A, e.u, null, t)), Pr(), function (e, t, n, r, i, s) { e.info((function () { if (e.g) if (s) for (var o = "", a = s.split("&"), l = 0; l < a.length; l++) { var c = a[l].split("="); if (1 < c.length) { var u = c[0]; c = c[1]; var h = u.split("_"); o = 2 <= h.length && "type" == h[1] ? o + (u + "=") + c + "&" : o + (u + "=redacted&") } } else o = null; else o = s; return "XMLHTTP REQ (" + r + ") [attempt " + i + "]: " + t + "\n" + n + "\n" + o })) }(e.j, e.u, e.A, e.m, e.W, e.s) } function ni(e) { return !!e.g && ("GET" == e.u && 2 != e.L && e.l.Ha) } function ri(e, t, n) { let r, i = !0; for (; !e.J && e.C < n.length;) { if (r = ii(e, n), r == Zr) { 4 == t && (e.o = 4, Fr(14), i = !1), Nr(e.j, e.m, null, "[Incomplete Response]"); break } if (r == Jr) { e.o = 4, Fr(15), Nr(e.j, e.m, n, "[Invalid Chunk]"), i = !1; break } Nr(e.j, e.m, r, null), ui(e, r) } ni(e) && r != Zr && r != Jr && (e.h.g = "", e.C = 0), 4 != t || 0 != n.length || e.h.h || (e.o = 1, Fr(16), i = !1), e.i = e.i && i, i ? 0 < n.length && !e.ba && (e.ba = !0, (t = e.l).g == e && t.ca && !t.M && (t.l.info("Great, no buffering proxy detected. Bytes received: " + n.length), Is(t), t.M = !0, Fr(11))) : (Nr(e.j, e.m, n, "[Invalid Chunked Response]"), ci(e), li(e)) } function ii(e, t) { var n = e.C, r = t.indexOf("\n", n); return -1 == r ? Zr : (n = Number(t.substring(n, r)), isNaN(n) ? Jr : (r += 1) + n > t.length ? Zr : (t = t.slice(r, r + n), e.C = r + n, t)) } function si(e) { e.Y = Date.now() + e.P, oi(e, e.P) } function oi(e, t) { if (null != e.B) throw Error("WatchDog timer not null"); e.B = jr(an(e.lb, e), t) } function ai(e) { e.B && (Zt.clearTimeout(e.B), e.B = null) } function li(e) { 0 == e.l.H || e.J || Cs(e.l, e) } function ci(e) { ai(e); var t = e.M; t && "function" == typeof t.sa && t.sa(), e.M = null, br(e.V), kr(e.U), e.g && (t = e.g, e.g = null, t.abort(), t.sa()) } function ui(e, t) { try { var n = e.l; if (0 != n.H && (n.g == e || Vi(n.i, e))) if (!e.K && Vi(n.i, e) && 3 == n.H) { try { var r = n.Ja.g.parse(t) } catch (c) { r = null } if (Array.isArray(r) && 3 == r.length) { var i = r; if (0 == i[0]) { e: if (!n.u) { if (n.g) { if (!(n.g.G + 3e3 < e.G)) break e; ks(n), ys(n) } xs(n), Fr(18) } } else n.Fa = i[1], 0 < n.Fa - n.V && 37500 > i[2] && n.G && 0 == n.A && !n.v && (n.v = jr(an(n.ib, n), 6e3)); if (1 >= ji(n.i) && n.oa) { try { n.oa() } catch (c) { } n.oa = void 0 } } else Ds(n, 11) } else if ((e.K || n.g == e) && ks(n), !gn(t)) for (i = n.Ja.g.parse(t), t = 0; t < i.length; t++) { let c = i[t]; if (n.V = c[0], c = c[1], 2 == n.H) if ("c" == c[0]) { n.K = c[1], n.pa = c[2]; const t = c[3]; null != t && (n.ra = t, n.l.info("VER=" + n.ra)); const i = c[4]; null != i && (n.Ga = i, n.l.info("SVER=" + n.Ga)); const u = c[5]; null != u && "number" === typeof u && 0 < u && (r = 1.5 * u, n.L = r, n.l.info("backChannelRequestTimeoutMs_=" + r)), r = n; const h = e.g; if (h) { const e = h.g ? h.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (e) { var s = r.i; s.g || -1 == e.indexOf("spdy") && -1 == e.indexOf("quic") && -1 == e.indexOf("h2") || (s.j = s.l, s.g = new Set, s.h && (Bi(s, s.h), s.h = null)) } if (r.F) { const e = h.g ? h.g.getResponseHeader("X-HTTP-Session-Id") : null; e && (r.Da = e, vi(r.I, r.F, e)) } } n.H = 3, n.h && n.h.Ba(), n.ca && (n.S = Date.now() - e.G, n.l.info("Handshake RTT: " + n.S + "ms")); var o = e; if ((r = n).wa = Os(r, r.J ? r.pa : null, r.Y), o.K) { Ui(r.i, o); var a = o, l = r.L; l && a.setTimeout(l), a.B && (ai(a), si(a)), r.g = o } else _s(r); 0 < n.j.length && ws(n) } else "stop" != c[0] && "close" != c[0] || Ds(n, 7); else 3 == n.H && ("stop" == c[0] || "close" == c[0] ? "stop" == c[0] ? Ds(n, 7) : gs(n) : "noop" != c[0] && n.h && n.h.Aa(c), n.A = 0) } Pr() } catch (c) { } } function hi(e, t) { if (e.forEach && "function" == typeof e.forEach) e.forEach(t, void 0); else if (en(e) || "string" === typeof e) Array.prototype.forEach.call(e, t, void 0); else for (var n = function (e) { if (e.ta && "function" == typeof e.ta) return e.ta(); if (!e.Z || "function" != typeof e.Z) { if ("undefined" !== typeof Map && e instanceof Map) return Array.from(e.keys()); if (!("undefined" !== typeof Set && e instanceof Set)) { if (en(e) || "string" === typeof e) { var t = []; e = e.length; for (var n = 0; n < e; n++)t.push(n); return t } t = [], n = 0; for (const r in e) t[n++] = r; return t } } }(e), r = function (e) { if (e.Z && "function" == typeof e.Z) return e.Z(); if ("undefined" !== typeof Map && e instanceof Map || "undefined" !== typeof Set && e instanceof Set) return Array.from(e.values()); if ("string" === typeof e) return e.split(""); if (en(e)) { for (var t = [], n = e.length, r = 0; r < n; r++)t.push(e[r]); return t } for (r in t = [], n = 0, e) t[n++] = e[r]; return t }(e), i = r.length, s = 0; s < i; s++)t.call(void 0, r[s], n && n[s], e) } ($t = $r.prototype).setTimeout = function (e) { this.P = e }, $t.nb = function (e) { e = e.target; const t = this.M; t && 3 == us(e) ? t.l() : this.Pa(e) }, $t.Pa = function (e) { try { if (e == this.g) e: { const u = us(this.g); var t = this.g.Ia(); this.g.da(); if (!(3 > u) && (3 != u || In || this.g && (this.h.h || this.g.ja() || hs(this.g)))) { this.J || 4 != u || 7 == t || Pr(), ai(this); var n = this.g.da(); this.ca = n; t: if (ni(this)) { var r = hs(this.g); e = ""; var i = r.length, s = 4 == us(this.g); if (!this.h.i) { if ("undefined" === typeof TextDecoder) { ci(this), li(this); var o = ""; break t } this.h.i = new Zt.TextDecoder } for (t = 0; t < i; t++)this.h.h = !0, e += this.h.i.decode(r[t], { stream: s && t == i - 1 }); r.splice(0, i), this.h.g += e, this.C = 0, o = this.h.g } else o = this.g.ja(); if (this.i = 200 == n, function (e, t, n, r, i, s, o) { e.info((function () { return "XMLHTTP RESP (" + r + ") [ attempt " + i + "]: " + t + "\n" + n + "\n" + s + " " + o })) }(this.j, this.u, this.A, this.m, this.W, u, n), this.i) { if (this.aa && !this.K) { t: { if (this.g) { var a, l = this.g; if ((a = l.g ? l.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !gn(a)) { var c = a; break t } } c = null } if (!(n = c)) { this.i = !1, this.o = 3, Fr(12), ci(this), li(this); break e } Nr(this.j, this.m, n, "Initial handshake response via X-HTTP-Initial-Response"), this.K = !0, ui(this, n) } this.S ? (ri(this, u, o), In && this.i && 3 == u && (Tr(this.U, this.V, "tick", this.mb), this.V.start())) : (Nr(this.j, this.m, o, null), ui(this, o)), 4 == u && ci(this), this.i && !this.J && (4 == u ? Cs(this.l, this) : (this.i = !1, si(this))) } else (function (e) { const t = {}; e = (e.g && 2 <= us(e) && e.g.getAllResponseHeaders() || "").split("\r\n"); for (let r = 0; r < e.length; r++) { if (gn(e[r])) continue; var n = dr(e[r]); const i = n[0]; if ("string" !== typeof (n = n[1])) continue; n = n.trim(); const s = t[i] || []; t[i] = s, s.push(n) } !function (e, t) { for (const n in e) t.call(void 0, e[n], n, e) }(t, (function (e) { return e.join(", ") })) })(this.g), 400 == n && 0 < o.indexOf("Unknown SID") ? (this.o = 3, Fr(12)) : (this.o = 0, Fr(13)), ci(this), li(this) } } } catch (u) { } }, $t.mb = function () { if (this.g) { var e = us(this.g), t = this.g.ja(); this.C < t.length && (ai(this), ri(this, e, t), this.i && 4 != e && si(this)) } }, $t.cancel = function () { this.J = !0, ci(this) }, $t.lb = function () { this.B = null; const e = Date.now(); 0 <= e - this.Y ? (function (e, t) { e.info((function () { return "TIMEOUT: " + t })) }(this.j, this.A), 2 != this.L && (Pr(), Fr(17)), ci(this), this.o = 2, li(this)) : oi(this, this.Y - e) }; var di = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"); function fi(e) { if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = !1, e instanceof fi) { this.h = e.h, mi(this, e.j), this.s = e.s, this.g = e.g, gi(this, e.m), this.l = e.l; var t = e.i, n = new Ci; n.i = t.i, t.g && (n.g = new Map(t.g), n.h = t.h), yi(this, n), this.o = e.o } else e && (t = String(e).match(di)) ? (this.h = !1, mi(this, t[1] || "", !0), this.s = bi(t[2] || ""), this.g = bi(t[3] || "", !0), gi(this, t[4]), this.l = bi(t[5] || "", !0), yi(this, t[6] || "", !0), this.o = bi(t[7] || "")) : (this.h = !1, this.i = new Ci(null, this.h)) } function pi(e) { return new fi(e) } function mi(e, t, n) { e.j = n ? bi(t, !0) : t, e.j && (e.j = e.j.replace(/:$/, "")) } function gi(e, t) { if (t) { if (t = Number(t), isNaN(t) || 0 > t) throw Error("Bad port number " + t); e.m = t } else e.m = null } function yi(e, t, n) { t instanceof Ci ? (e.i = t, function (e, t) { t && !e.j && (Ni(e), e.i = null, e.g.forEach((function (e, t) { var n = t.toLowerCase(); t != n && (Di(this, t), Oi(this, n, e)) }), e)), e.j = t }(e.i, e.h)) : (n || (t = Ei(t, Ti)), e.i = new Ci(t, e.h)) } function vi(e, t, n) { e.i.set(t, n) } function wi(e) { return vi(e, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), e } function bi(e, t) { return e ? t ? decodeURI(e.replace(/%25/g, "%2525")) : decodeURIComponent(e) : "" } function Ei(e, t, n) { return "string" === typeof e ? (e = encodeURI(e).replace(t, Si), n && (e = e.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), e) : null } function Si(e) { return "%" + ((e = e.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & e).toString(16) } fi.prototype.toString = function () { var e = [], t = this.j; t && e.push(Ei(t, _i, !0), ":"); var n = this.g; return (n || "file" == t) && (e.push("//"), (t = this.s) && e.push(Ei(t, _i, !0), "@"), e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (n = this.m) && e.push(":", String(n))), (n = this.l) && (this.g && "/" != n.charAt(0) && e.push("/"), e.push(Ei(n, "/" == n.charAt(0) ? Ii : xi, !0))), (n = this.i.toString()) && e.push("?", n), (n = this.o) && e.push("#", Ei(n, ki)), e.join("") }; var _i = /[#\/\?@]/g, xi = /[#\?:]/g, Ii = /[#\?]/g, Ti = /[#\?@]/g, ki = /#/g; function Ci(e, t) { this.h = this.g = null, this.i = e || null, this.j = !!t } function Ni(e) { e.g || (e.g = new Map, e.h = 0, e.i && function (e, t) { if (e) { e = e.split("&"); for (var n = 0; n < e.length; n++) { var r = e[n].indexOf("="), i = null; if (0 <= r) { var s = e[n].substring(0, r); i = e[n].substring(r + 1) } else s = e[n]; t(s, i ? decodeURIComponent(i.replace(/\+/g, " ")) : "") } } }(e.i, (function (t, n) { e.add(decodeURIComponent(t.replace(/\+/g, " ")), n) }))) } function Di(e, t) { Ni(e), t = Ri(e, t), e.g.has(t) && (e.i = null, e.h -= e.g.get(t).length, e.g.delete(t)) } function Ai(e, t) { return Ni(e), t = Ri(e, t), e.g.has(t) } function Oi(e, t, n) { Di(e, t), 0 < n.length && (e.i = null, e.g.set(Ri(e, t), dn(n)), e.h += n.length) } function Ri(e, t) { return t = String(t), e.j && (t = t.toLowerCase()), t } ($t = Ci.prototype).add = function (e, t) { Ni(this), this.i = null, e = Ri(this, e); var n = this.g.get(e); return n || this.g.set(e, n = []), n.push(t), this.h += 1, this }, $t.forEach = function (e, t) { Ni(this), this.g.forEach((function (n, r) { n.forEach((function (n) { e.call(t, n, r, this) }), this) }), this) }, $t.ta = function () { Ni(this); const e = Array.from(this.g.values()), t = Array.from(this.g.keys()), n = []; for (let r = 0; r < t.length; r++) { const i = e[r]; for (let e = 0; e < i.length; e++)n.push(t[r]) } return n }, $t.Z = function (e) { Ni(this); let t = []; if ("string" === typeof e) Ai(this, e) && (t = t.concat(this.g.get(Ri(this, e)))); else { e = Array.from(this.g.values()); for (let n = 0; n < e.length; n++)t = t.concat(e[n]) } return t }, $t.set = function (e, t) { return Ni(this), this.i = null, Ai(this, e = Ri(this, e)) && (this.h -= this.g.get(e).length), this.g.set(e, [t]), this.h += 1, this }, $t.get = function (e, t) { return e && 0 < (e = this.Z(e)).length ? String(e[0]) : t }, $t.toString = function () { if (this.i) return this.i; if (!this.g) return ""; const e = [], t = Array.from(this.g.keys()); for (var n = 0; n < t.length; n++) { var r = t[n]; const s = encodeURIComponent(String(r)), o = this.Z(r); for (r = 0; r < o.length; r++) { var i = s; "" !== o[r] && (i += "=" + encodeURIComponent(String(o[r]))), e.push(i) } } return this.i = e.join("&") }; var Pi = class { constructor(e, t) { this.g = e, this.map = t } }; function Li(e) { this.l = e || Fi, Zt.PerformanceNavigationTiming ? e = 0 < (e = Zt.performance.getEntriesByType("navigation")).length && ("hq" == e[0].nextHopProtocol || "h2" == e[0].nextHopProtocol) : e = !!(Zt.g && Zt.g.Ka && Zt.g.Ka() && Zt.g.Ka().ec), this.j = e ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = [] } var Fi = 10; function Mi(e) { return !!e.h || !!e.g && e.g.size >= e.j } function ji(e) { return e.h ? 1 : e.g ? e.g.size : 0 } function Vi(e, t) { return e.h ? e.h == t : !!e.g && e.g.has(t) } function Bi(e, t) { e.g ? e.g.add(t) : e.h = t } function Ui(e, t) { e.h && e.h == t ? e.h = null : e.g && e.g.has(t) && e.g.delete(t) } function zi(e) { if (null != e.h) return e.i.concat(e.h.F); if (null != e.g && 0 !== e.g.size) { let t = e.i; for (const n of e.g.values()) t = t.concat(n.F); return t } return dn(e.i) } Li.prototype.cancel = function () { if (this.i = zi(this), this.h) this.h.cancel(), this.h = null; else if (this.g && 0 !== this.g.size) { for (const e of this.g.values()) e.cancel(); this.g.clear() } }; var qi, Ki = class { stringify(e) { return Zt.JSON.stringify(e, void 0) } parse(e) { return Zt.JSON.parse(e, void 0) } }; function Gi() { this.g = new Ki } function Hi(e, t, n) { const r = n || ""; try { hi(e, (function (e, n) { let i = e; tn(e) && (i = lr(e)), t.push(r + n + "=" + encodeURIComponent(i)) })) } catch (i) { throw t.push(r + "type=" + encodeURIComponent("_badmap")), i } } function Qi(e, t, n, r, i) { try { t.onload = null, t.onerror = null, t.onabort = null, t.ontimeout = null, i(r) } catch (s) { } } function Wi(e) { this.l = e.fc || null, this.j = e.ob || !1 } function $i(e, t) { sr.call(this), this.F = e, this.u = t, this.m = void 0, this.readyState = Xi, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null } cn(Wi, Ur), Wi.prototype.g = function () { return new $i(this.l, this.j) }, Wi.prototype.i = (qi = {}, function () { return qi }), cn($i, sr); var Xi = 0; function Yi(e) { e.j.read().then(e.Xa.bind(e)).catch(e.ka.bind(e)) } function Ji(e) { e.readyState = 4, e.l = null, e.j = null, e.A = null, Zi(e) } function Zi(e) { e.onreadystatechange && e.onreadystatechange.call(e) } ($t = $i.prototype).open = function (e, t) { if (this.readyState != Xi) throw this.abort(), Error("Error reopening a connection"); this.C = e, this.B = t, this.readyState = 1, Zi(this) }, $t.send = function (e) { if (1 != this.readyState) throw this.abort(), Error("need to call open() first. "); this.g = !0; const t = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 }; e && (t.body = e), (this.F || Zt).fetch(new Request(this.B, t)).then(this.$a.bind(this), this.ka.bind(this)) }, $t.abort = function () { this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch((() => { })), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = !1, Ji(this)), this.readyState = Xi }, $t.$a = function (e) { if (this.g && (this.l = e, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = e.headers, this.readyState = 2, Zi(this)), this.g && (this.readyState = 3, Zi(this), this.g))) if ("arraybuffer" === this.responseType) e.arrayBuffer().then(this.Ya.bind(this), this.ka.bind(this)); else if ("undefined" !== typeof Zt.ReadableStream && "body" in e) { if (this.j = e.body.getReader(), this.u) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.A = new TextDecoder; Yi(this) } else e.text().then(this.Za.bind(this), this.ka.bind(this)) }, $t.Xa = function (e) { if (this.g) { if (this.u && e.value) this.response.push(e.value); else if (!this.u) { var t = e.value ? e.value : new Uint8Array(0); (t = this.A.decode(t, { stream: !e.done })) && (this.response = this.responseText += t) } e.done ? Ji(this) : Zi(this), 3 == this.readyState && Yi(this) } }, $t.Za = function (e) { this.g && (this.response = this.responseText = e, Ji(this)) }, $t.Ya = function (e) { this.g && (this.response = e, Ji(this)) }, $t.ka = function () { this.g && Ji(this) }, $t.setRequestHeader = function (e, t) { this.v.append(e, t) }, $t.getResponseHeader = function (e) { return this.h && this.h.get(e.toLowerCase()) || "" }, $t.getAllResponseHeaders = function () { if (!this.h) return ""; const e = [], t = this.h.entries(); for (var n = t.next(); !n.done;)n = n.value, e.push(n[0] + ": " + n[1]), n = t.next(); return e.join("\r\n") }, Object.defineProperty($i.prototype, "withCredentials", { get: function () { return "include" === this.m }, set: function (e) { this.m = e ? "include" : "same-origin" } }); var es = Zt.JSON.parse; function ts(e) { sr.call(this), this.headers = new Map, this.u = e || null, this.h = !1, this.C = this.g = null, this.I = "", this.m = 0, this.j = "", this.l = this.G = this.v = this.F = !1, this.B = 0, this.A = null, this.K = ns, this.L = this.M = !1 } cn(ts, sr); var ns = "", rs = /^https?$/i, is = ["POST", "PUT"]; function ss(e, t) { e.h = !1, e.g && (e.l = !0, e.g.abort(), e.l = !1), e.j = t, e.m = 5, os(e), ls(e) } function os(e) { e.F || (e.F = !0, or(e, "complete"), or(e, "error")) } function as(e) { if (e.h && "undefined" != typeof Jt && (!e.C[1] || 4 != us(e) || 2 != e.da())) if (e.v && 4 == us(e)) Er(e.La, 0, e); else if (or(e, "readystatechange"), 4 == us(e)) { e.h = !1; try { const a = e.da(); e: switch (a) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var t = !0; break e; default: t = !1 }var n; if (!(n = t)) { var r; if (r = 0 === a) { var i = String(e.I).match(di)[1] || null; !i && Zt.self && Zt.self.location && (i = Zt.self.location.protocol.slice(0, -1)), r = !rs.test(i ? i.toLowerCase() : "") } n = r } if (n) or(e, "complete"), or(e, "success"); else { e.m = 6; try { var s = 2 < us(e) ? e.g.statusText : "" } catch (o) { s = "" } e.j = s + " [" + e.da() + "]", os(e) } } finally { ls(e) } } } function ls(e, t) { if (e.g) { cs(e); const r = e.g, i = e.C[0] ? () => { } : null; e.g = null, e.C = null, t || or(e, "ready"); try { r.onreadystatechange = i } catch (n) { } } } function cs(e) { e.g && e.L && (e.g.ontimeout = null), e.A && (Zt.clearTimeout(e.A), e.A = null) } function us(e) { return e.g ? e.g.readyState : 0 } function hs(e) { try { if (!e.g) return null; if ("response" in e.g) return e.g.response; switch (e.K) { case ns: case "text": return e.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in e.g) return e.g.mozResponseArrayBuffer }return null } catch (yo) { return null } } function ds(e) { let t = ""; return Bn(e, (function (e, n) { t += n, t += ":", t += e, t += "\r\n" })), t } function fs(e, t, n) { e: { for (r in n) { var r = !1; break e } r = !0 } r || (n = ds(n), "string" === typeof e ? null != n && encodeURIComponent(String(n)) : vi(e, t, n)) } function ps(e, t, n) { return n && n.internalChannelParams && n.internalChannelParams[e] || t } function ms(e) { this.Ga = 0, this.j = [], this.l = new Cr, this.pa = this.wa = this.I = this.Y = this.g = this.Da = this.F = this.na = this.o = this.U = this.s = null, this.fb = this.W = 0, this.cb = ps("failFast", !1, e), this.G = this.v = this.u = this.m = this.h = null, this.aa = !0, this.Fa = this.V = -1, this.ba = this.A = this.C = 0, this.ab = ps("baseRetryDelayMs", 5e3, e), this.hb = ps("retryDelaySeedMs", 1e4, e), this.eb = ps("forwardChannelMaxRetries", 2, e), this.xa = ps("forwardChannelRequestTimeoutMs", 2e4, e), this.va = e && e.xmlHttpFactory || void 0, this.Ha = e && e.dc || !1, this.L = void 0, this.J = e && e.supportsCrossDomainXhr || !1, this.K = "", this.i = new Li(e && e.concurrentRequestLimit), this.Ja = new Gi, this.P = e && e.fastHandshake || !1, this.O = e && e.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.bb = e && e.bc || !1, e && e.Ea && this.l.Ea(), e && e.forceLongPolling && (this.aa = !1), this.ca = !this.P && this.aa && e && e.detectBufferingProxy || !1, this.qa = void 0, e && e.longPollingTimeout && 0 < e.longPollingTimeout && (this.qa = e.longPollingTimeout), this.oa = void 0, this.S = 0, this.M = !1, this.ma = this.B = null } function gs(e) { if (vs(e), 3 == e.H) { var t = e.W++, n = pi(e.I); if (vi(n, "SID", e.K), vi(n, "RID", t), vi(n, "TYPE", "terminate"), Es(e, n), (t = new $r(e, e.l, t)).L = 2, t.v = wi(pi(n)), n = !1, Zt.navigator && Zt.navigator.sendBeacon) try { n = Zt.navigator.sendBeacon(t.v.toString(), "") } catch (r) { } !n && Zt.Image && ((new Image).src = t.v, n = !0), n || (t.g = Rs(t.l, null), t.g.ha(t.v)), t.G = Date.now(), si(t) } As(e) } function ys(e) { e.g && (Is(e), e.g.cancel(), e.g = null) } function vs(e) { ys(e), e.u && (Zt.clearTimeout(e.u), e.u = null), ks(e), e.i.cancel(), e.m && ("number" === typeof e.m && Zt.clearTimeout(e.m), e.m = null) } function ws(e) { if (!Mi(e.i) && !e.m) { e.m = !0; var t = e.Na; pr || yr(), mr || (pr(), mr = !0), gr.add(t, e), e.C = 0 } } function bs(e, t) { var n; n = t ? t.m : e.W++; const r = pi(e.I); vi(r, "SID", e.K), vi(r, "RID", n), vi(r, "AID", e.V), Es(e, r), e.o && e.s && fs(r, e.o, e.s), n = new $r(e, e.l, n, e.C + 1), null === e.o && (n.I = e.s), t && (e.j = t.F.concat(e.j)), t = Ss(e, n, 1e3), n.setTimeout(Math.round(.5 * e.xa) + Math.round(.5 * e.xa * Math.random())), Bi(e.i, n), ei(n, r, t) } function Es(e, t) { e.na && Bn(e.na, (function (e, n) { vi(t, n, e) })), e.h && hi({}, (function (e, n) { vi(t, n, e) })) } function Ss(e, t, n) { n = Math.min(e.j.length, n); var r = e.h ? an(e.h.Va, e.h, e) : null; e: { var i = e.j; let t = -1; for (; ;) { const e = ["count=" + n]; -1 == t ? 0 < n ? (t = i[0].g, e.push("ofs=" + t)) : t = 0 : e.push("ofs=" + t); let s = !0; for (let o = 0; o < n; o++) { let n = i[o].g; const a = i[o].map; if (n -= t, 0 > n) t = Math.max(0, i[o].g - 100), s = !1; else try { Hi(a, e, "req" + n + "_") } catch (Co) { r && r(a) } } if (s) { r = e.join("&"); break e } } } return e = e.j.splice(0, n), t.F = e, r } function _s(e) { if (!e.g && !e.u) { e.ba = 1; var t = e.Ma; pr || yr(), mr || (pr(), mr = !0), gr.add(t, e), e.A = 0 } } function xs(e) { return !(e.g || e.u || 3 <= e.A) && (e.ba++, e.u = jr(an(e.Ma, e), Ns(e, e.A)), e.A++, !0) } function Is(e) { null != e.B && (Zt.clearTimeout(e.B), e.B = null) } function Ts(e) { e.g = new $r(e, e.l, "rpc", e.ba), null === e.o && (e.g.I = e.s), e.g.O = 0; var t = pi(e.wa); vi(t, "RID", "rpc"), vi(t, "SID", e.K), vi(t, "AID", e.V), vi(t, "CI", e.G ? "0" : "1"), !e.G && e.qa && vi(t, "TO", e.qa), vi(t, "TYPE", "xmlhttp"), Es(e, t), e.o && e.s && fs(t, e.o, e.s), e.L && e.g.setTimeout(e.L); var n = e.g; e = e.pa, n.L = 1, n.v = wi(pi(t)), n.s = null, n.S = !0, ti(n, e) } function ks(e) { null != e.v && (Zt.clearTimeout(e.v), e.v = null) } function Cs(e, t) { var n = null; if (e.g == t) { ks(e), Is(e), e.g = null; var r = 2 } else { if (!Vi(e.i, t)) return; n = t.F, Ui(e.i, t), r = 1 } if (0 != e.H) if (t.i) if (1 == r) { n = t.s ? t.s.length : 0, t = Date.now() - t.G; var i = e.C; or(r = Or(), new Mr(r, n)), ws(e) } else _s(e); else if (3 == (i = t.o) || 0 == i && 0 < t.ca || !(1 == r && function (e, t) { return !(ji(e.i) >= e.i.j - (e.m ? 1 : 0)) && (e.m ? (e.j = t.F.concat(e.j), !0) : !(1 == e.H || 2 == e.H || e.C >= (e.cb ? 0 : e.eb)) && (e.m = jr(an(e.Na, e, t), Ns(e, e.C)), e.C++, !0)) }(e, t) || 2 == r && xs(e))) switch (n && 0 < n.length && (t = e.i, t.i = t.i.concat(n)), i) { case 1: Ds(e, 5); break; case 4: Ds(e, 10); break; case 3: Ds(e, 6); break; default: Ds(e, 2) } } function Ns(e, t) { let n = e.ab + Math.floor(Math.random() * e.hb); return e.isActive() || (n *= 2), n * t } function Ds(e, t) { if (e.l.info("Error code " + t), 2 == t) { var n = null; e.h && (n = null); var r = an(e.pb, e); n || (n = new fi("//www.google.com/images/cleardot.gif"), Zt.location && "http" == Zt.location.protocol || mi(n, "https"), wi(n)), function (e, t) { const n = new Cr; if (Zt.Image) { const r = new Image; r.onload = ln(Qi, n, r, "TestLoadImage: loaded", !0, t), r.onerror = ln(Qi, n, r, "TestLoadImage: error", !1, t), r.onabort = ln(Qi, n, r, "TestLoadImage: abort", !1, t), r.ontimeout = ln(Qi, n, r, "TestLoadImage: timeout", !1, t), Zt.setTimeout((function () { r.ontimeout && r.ontimeout() }), 1e4), r.src = e } else t(!1) }(n.toString(), r) } else Fr(2); e.H = 0, e.h && e.h.za(t), As(e), vs(e) } function As(e) { if (e.H = 0, e.ma = [], e.h) { const t = zi(e.i); 0 == t.length && 0 == e.j.length || (fn(e.ma, t), fn(e.ma, e.j), e.i.i.length = 0, dn(e.j), e.j.length = 0), e.h.ya() } } function Os(e, t, n) { var r = n instanceof fi ? pi(n) : new fi(n); if ("" != r.g) t && (r.g = t + "." + r.g), gi(r, r.m); else { var i = Zt.location; r = i.protocol, t = t ? t + "." + i.hostname : i.hostname, i = +i.port; var s = new fi(null); r && mi(s, r), t && (s.g = t), i && gi(s, i), n && (s.l = n), r = s } return n = e.F, t = e.Da, n && t && vi(r, n, t), vi(r, "VER", e.ra), Es(e, r), r } function Rs(e, t, n) { if (t && !e.J) throw Error("Can't create secondary domain capable XhrIo object."); return (t = n && e.Ha && !e.va ? new ts(new Wi({ ob: !0 })) : new ts(e.va)).Oa(e.J), t } function Ps() { } function Ls() { if (_n && !(10 <= Number(Rn))) throw Error("Environmental error: no available transport.") } function Fs(e, t) { sr.call(this), this.g = new ms(t), this.l = e, this.h = t && t.messageUrlParams || null, e = t && t.messageHeaders || null, t && t.clientProtocolHeaderRequired && (e ? e["X-Client-Protocol"] = "webchannel" : e = { "X-Client-Protocol": "webchannel" }), this.g.s = e, e = t && t.initMessageHeaders || null, t && t.messageContentType && (e ? e["X-WebChannel-Content-Type"] = t.messageContentType : e = { "X-WebChannel-Content-Type": t.messageContentType }), t && t.Ca && (e ? e["X-WebChannel-Client-Profile"] = t.Ca : e = { "X-WebChannel-Client-Profile": t.Ca }), this.g.U = e, (e = t && t.cc) && !gn(e) && (this.g.o = e), this.A = t && t.supportsCrossDomainXhr || !1, this.v = t && t.sendRawJson || !1, (t = t && t.httpSessionIdParam) && !gn(t) && (this.g.F = t, null !== (e = this.h) && t in e && (t in (e = this.h) && delete e[t])), this.j = new Vs(this) } function Ms(e) { Hr.call(this), e.__headers__ && (this.headers = e.__headers__, this.statusCode = e.__status__, delete e.__headers__, delete e.__status__); var t = e.__sm__; if (t) { e: { for (const n in t) { e = n; break e } e = void 0 } (this.i = e) && (e = this.i, t = null !== t && e in t ? t[e] : void 0), this.data = t } else this.data = e } function js() { Qr.call(this), this.status = 1 } function Vs(e) { this.g = e } function Bs() { this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.m = Array(this.blockSize), this.i = this.h = 0, this.reset() } function Us(e, t, n) { n || (n = 0); var r = Array(16); if ("string" === typeof t) for (var i = 0; 16 > i; ++i)r[i] = t.charCodeAt(n++) | t.charCodeAt(n++) << 8 | t.charCodeAt(n++) << 16 | t.charCodeAt(n++) << 24; else for (i = 0; 16 > i; ++i)r[i] = t[n++] | t[n++] << 8 | t[n++] << 16 | t[n++] << 24; t = e.g[0], n = e.g[1], i = e.g[2]; var s = e.g[3], o = t + (s ^ n & (i ^ s)) + r[0] + 3614090360 & 4294967295; o = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = (n = (i = (s = (t = n + (o << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[1] + 3905402710 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[2] + 606105819 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[3] + 3250441966 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (s ^ n & (i ^ s)) + r[4] + 4118548399 & 4294967295) << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[5] + 1200080426 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[6] + 2821735955 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[7] + 4249261313 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (s ^ n & (i ^ s)) + r[8] + 1770035416 & 4294967295) << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[9] + 2336552879 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[10] + 4294925233 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[11] + 2304563134 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (s ^ n & (i ^ s)) + r[12] + 1804603682 & 4294967295) << 7 & 4294967295 | o >>> 25)) + ((o = s + (i ^ t & (n ^ i)) + r[13] + 4254626195 & 4294967295) << 12 & 4294967295 | o >>> 20)) + ((o = i + (n ^ s & (t ^ n)) + r[14] + 2792965006 & 4294967295) << 17 & 4294967295 | o >>> 15)) + ((o = n + (t ^ i & (s ^ t)) + r[15] + 1236535329 & 4294967295) << 22 & 4294967295 | o >>> 10)) + ((o = t + (i ^ s & (n ^ i)) + r[1] + 4129170786 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[6] + 3225465664 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[11] + 643717713 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[0] + 3921069994 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (i ^ s & (n ^ i)) + r[5] + 3593408605 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[10] + 38016083 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[15] + 3634488961 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[4] + 3889429448 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (i ^ s & (n ^ i)) + r[9] + 568446438 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[14] + 3275163606 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[3] + 4107603335 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[8] + 1163531501 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (i ^ s & (n ^ i)) + r[13] + 2850285829 & 4294967295) << 5 & 4294967295 | o >>> 27)) + ((o = s + (n ^ i & (t ^ n)) + r[2] + 4243563512 & 4294967295) << 9 & 4294967295 | o >>> 23)) + ((o = i + (t ^ n & (s ^ t)) + r[7] + 1735328473 & 4294967295) << 14 & 4294967295 | o >>> 18)) + ((o = n + (s ^ t & (i ^ s)) + r[12] + 2368359562 & 4294967295) << 20 & 4294967295 | o >>> 12)) + ((o = t + (n ^ i ^ s) + r[5] + 4294588738 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[8] + 2272392833 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[11] + 1839030562 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[14] + 4259657740 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (n ^ i ^ s) + r[1] + 2763975236 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[4] + 1272893353 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[7] + 4139469664 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[10] + 3200236656 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (n ^ i ^ s) + r[13] + 681279174 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[0] + 3936430074 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[3] + 3572445317 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[6] + 76029189 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (n ^ i ^ s) + r[9] + 3654602809 & 4294967295) << 4 & 4294967295 | o >>> 28)) + ((o = s + (t ^ n ^ i) + r[12] + 3873151461 & 4294967295) << 11 & 4294967295 | o >>> 21)) + ((o = i + (s ^ t ^ n) + r[15] + 530742520 & 4294967295) << 16 & 4294967295 | o >>> 16)) + ((o = n + (i ^ s ^ t) + r[2] + 3299628645 & 4294967295) << 23 & 4294967295 | o >>> 9)) + ((o = t + (i ^ (n | ~s)) + r[0] + 4096336452 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[7] + 1126891415 & 4294967295) << 10 & 4294967295 | o >>> 22)) + ((o = i + (t ^ (s | ~n)) + r[14] + 2878612391 & 4294967295) << 15 & 4294967295 | o >>> 17)) + ((o = n + (s ^ (i | ~t)) + r[5] + 4237533241 & 4294967295) << 21 & 4294967295 | o >>> 11)) + ((o = t + (i ^ (n | ~s)) + r[12] + 1700485571 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[3] + 2399980690 & 4294967295) << 10 & 4294967295 | o >>> 22)) + ((o = i + (t ^ (s | ~n)) + r[10] + 4293915773 & 4294967295) << 15 & 4294967295 | o >>> 17)) + ((o = n + (s ^ (i | ~t)) + r[1] + 2240044497 & 4294967295) << 21 & 4294967295 | o >>> 11)) + ((o = t + (i ^ (n | ~s)) + r[8] + 1873313359 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[15] + 4264355552 & 4294967295) << 10 & 4294967295 | o >>> 22)) + ((o = i + (t ^ (s | ~n)) + r[6] + 2734768916 & 4294967295) << 15 & 4294967295 | o >>> 17)) + ((o = n + (s ^ (i | ~t)) + r[13] + 1309151649 & 4294967295) << 21 & 4294967295 | o >>> 11)) + ((s = (t = n + ((o = t + (i ^ (n | ~s)) + r[4] + 4149444226 & 4294967295) << 6 & 4294967295 | o >>> 26)) + ((o = s + (n ^ (t | ~i)) + r[11] + 3174756917 & 4294967295) << 10 & 4294967295 | o >>> 22)) ^ ((i = s + ((o = i + (t ^ (s | ~n)) + r[2] + 718787259 & 4294967295) << 15 & 4294967295 | o >>> 17)) | ~t)) + r[9] + 3951481745 & 4294967295, e.g[0] = e.g[0] + t & 4294967295, e.g[1] = e.g[1] + (i + (o << 21 & 4294967295 | o >>> 11)) & 4294967295, e.g[2] = e.g[2] + i & 4294967295, e.g[3] = e.g[3] + s & 4294967295 } function zs(e, t) { this.h = t; for (var n = [], r = !0, i = e.length - 1; 0 <= i; i--) { var s = 0 | e[i]; r && s == t || (n[i] = s, r = !1) } this.g = n } ($t = ts.prototype).Oa = function (e) { this.M = e }, $t.ha = function (e, t, n, r) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.I + "; newUri=" + e); t = t ? t.toUpperCase() : "GET", this.I = e, this.j = "", this.m = 0, this.F = !1, this.h = !0, this.g = this.u ? this.u.g() : Kr.g(), this.C = this.u ? zr(this.u) : zr(Kr), this.g.onreadystatechange = an(this.La, this); try { this.G = !0, this.g.open(t, String(e), !0), this.G = !1 } catch (s) { return void ss(this, s) } if (e = n || "", n = new Map(this.headers), r) if (Object.getPrototypeOf(r) === Object.prototype) for (var i in r) n.set(i, r[i]); else { if ("function" !== typeof r.keys || "function" !== typeof r.get) throw Error("Unknown input type for opt_headers: " + String(r)); for (const e of r.keys()) n.set(e, r.get(e)) } r = Array.from(n.keys()).find((e => "content-type" == e.toLowerCase())), i = Zt.FormData && e instanceof Zt.FormData, !(0 <= hn(is, t)) || r || i || n.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); for (const [o, a] of n) this.g.setRequestHeader(o, a); this.K && (this.g.responseType = this.K), "withCredentials" in this.g && this.g.withCredentials !== this.M && (this.g.withCredentials = this.M); try { cs(this), 0 < this.B && ((this.L = function (e) { return _n && "number" === typeof e.timeout && void 0 !== e.ontimeout }(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = an(this.ua, this)) : this.A = Er(this.ua, this.B, this)), this.v = !0, this.g.send(e), this.v = !1 } catch (s) { ss(this, s) } }, $t.ua = function () { "undefined" != typeof Jt && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, or(this, "timeout"), this.abort(8)) }, $t.abort = function (e) { this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = e || 7, or(this, "complete"), or(this, "abort"), ls(this)) }, $t.N = function () { this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), ls(this, !0)), ts.$.N.call(this) }, $t.La = function () { this.s || (this.G || this.v || this.l ? as(this) : this.kb()) }, $t.kb = function () { as(this) }, $t.isActive = function () { return !!this.g }, $t.da = function () { try { return 2 < us(this) ? this.g.status : -1 } catch (qi) { return -1 } }, $t.ja = function () { try { return this.g ? this.g.responseText : "" } catch (qi) { return "" } }, $t.Wa = function (e) { if (this.g) { var t = this.g.responseText; return e && 0 == t.indexOf(e) && (t = t.substring(e.length)), es(t) } }, $t.Ia = function () { return this.m }, $t.Sa = function () { return "string" === typeof this.j ? this.j : String(this.j) }, ($t = ms.prototype).ra = 8, $t.H = 1, $t.Na = function (e) { if (this.m) if (this.m = null, 1 == this.H) { if (!e) { this.W = Math.floor(1e5 * Math.random()), e = this.W++; const i = new $r(this, this.l, e); let s = this.s; if (this.U && (s ? (s = Un(s), qn(s, this.U)) : s = this.U), null !== this.o || this.O || (i.I = s, s = null), this.P) e: { for (var t = 0, n = 0; n < this.j.length; n++) { var r = this.j[n]; if (void 0 === (r = "__data__" in r.map && "string" === typeof (r = r.map.__data__) ? r.length : void 0)) break; if (4096 < (t += r)) { t = n; break e } if (4096 === t || n === this.j.length - 1) { t = n + 1; break e } } t = 1e3 } else t = 1e3; t = Ss(this, i, t), vi(n = pi(this.I), "RID", e), vi(n, "CVER", 22), this.F && vi(n, "X-HTTP-Session-Id", this.F), Es(this, n), s && (this.O ? t = "headers=" + encodeURIComponent(String(ds(s))) + "&" + t : this.o && fs(n, this.o, s)), Bi(this.i, i), this.bb && vi(n, "TYPE", "init"), this.P ? (vi(n, "$req", t), vi(n, "SID", "null"), i.aa = !0, ei(i, n, null)) : ei(i, n, t), this.H = 2 } } else 3 == this.H && (e ? bs(this, e) : 0 == this.j.length || Mi(this.i) || bs(this)) }, $t.Ma = function () { if (this.u = null, Ts(this), this.ca && !(this.M || null == this.g || 0 >= this.S)) { var e = 2 * this.S; this.l.info("BP detection timer enabled: " + e), this.B = jr(an(this.jb, this), e) } }, $t.jb = function () { this.B && (this.B = null, this.l.info("BP detection timeout reached."), this.l.info("Buffering proxy detected and switch to long-polling!"), this.G = !1, this.M = !0, Fr(10), ys(this), Ts(this)) }, $t.ib = function () { null != this.v && (this.v = null, ys(this), xs(this), Fr(19)) }, $t.pb = function (e) { e ? (this.l.info("Successfully pinged google.com"), Fr(2)) : (this.l.info("Failed to ping google.com"), Fr(1)) }, $t.isActive = function () { return !!this.h && this.h.isActive(this) }, ($t = Ps.prototype).Ba = function () { }, $t.Aa = function () { }, $t.za = function () { }, $t.ya = function () { }, $t.isActive = function () { return !0 }, $t.Va = function () { }, Ls.prototype.g = function (e, t) { return new Fs(e, t) }, cn(Fs, sr), Fs.prototype.m = function () { this.g.h = this.j, this.A && (this.g.J = !0); var e = this.g, t = this.l, n = this.h || void 0; Fr(0), e.Y = t, e.na = n || {}, e.G = e.aa, e.I = Os(e, null, e.Y), ws(e) }, Fs.prototype.close = function () { gs(this.g) }, Fs.prototype.u = function (e) { var t = this.g; if ("string" === typeof e) { var n = {}; n.__data__ = e, e = n } else this.v && ((n = {}).__data__ = lr(e), e = n); t.j.push(new Pi(t.fb++, e)), 3 == t.H && ws(t) }, Fs.prototype.N = function () { this.g.h = null, delete this.j, gs(this.g), delete this.g, Fs.$.N.call(this) }, cn(Ms, Hr), cn(js, Qr), cn(Vs, Ps), Vs.prototype.Ba = function () { or(this.g, "a") }, Vs.prototype.Aa = function (e) { or(this.g, new Ms(e)) }, Vs.prototype.za = function (e) { or(this.g, new js) }, Vs.prototype.ya = function () { or(this.g, "b") }, cn(Bs, (function () { this.blockSize = -1 })), Bs.prototype.reset = function () { this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.i = this.h = 0 }, Bs.prototype.j = function (e, t) { void 0 === t && (t = e.length); for (var n = t - this.blockSize, r = this.m, i = this.h, s = 0; s < t;) { if (0 == i) for (; s <= n;)Us(this, e, s), s += this.blockSize; if ("string" === typeof e) { for (; s < t;)if (r[i++] = e.charCodeAt(s++), i == this.blockSize) { Us(this, r), i = 0; break } } else for (; s < t;)if (r[i++] = e[s++], i == this.blockSize) { Us(this, r), i = 0; break } } this.h = i, this.i += t }, Bs.prototype.l = function () { var e = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h); e[0] = 128; for (var t = 1; t < e.length - 8; ++t)e[t] = 0; var n = 8 * this.i; for (t = e.length - 8; t < e.length; ++t)e[t] = 255 & n, n /= 256; for (this.j(e), e = Array(16), t = n = 0; 4 > t; ++t)for (var r = 0; 32 > r; r += 8)e[n++] = this.g[t] >>> r & 255; return e }; var qs = {}; function Ks(e) { return -128 <= e && 128 > e ? function (e, t) { var n = qs; return Object.prototype.hasOwnProperty.call(n, e) ? n[e] : n[e] = t(e) }(e, (function (e) { return new zs([0 | e], 0 > e ? -1 : 0) })) : new zs([0 | e], 0 > e ? -1 : 0) } function Gs(e) { if (isNaN(e) || !isFinite(e)) return Qs; if (0 > e) return Js(Gs(-e)); for (var t = [], n = 1, r = 0; e >= n; r++)t[r] = e / n | 0, n *= Hs; return new zs(t, 0) } var Hs = 4294967296, Qs = Ks(0), Ws = Ks(1), $s = Ks(16777216); function Xs(e) { if (0 != e.h) return !1; for (var t = 0; t < e.g.length; t++)if (0 != e.g[t]) return !1; return !0 } function Ys(e) { return -1 == e.h } function Js(e) { for (var t = e.g.length, n = [], r = 0; r < t; r++)n[r] = ~e.g[r]; return new zs(n, ~e.h).add(Ws) } function Zs(e, t) { return e.add(Js(t)) } function eo(e, t) { for (; (65535 & e[t]) != e[t];)e[t + 1] += e[t] >>> 16, e[t] &= 65535, t++ } function to(e, t) { this.g = e, this.h = t } function no(e, t) { if (Xs(t)) throw Error("division by zero"); if (Xs(e)) return new to(Qs, Qs); if (Ys(e)) return t = no(Js(e), t), new to(Js(t.g), Js(t.h)); if (Ys(t)) return t = no(e, Js(t)), new to(Js(t.g), t.h); if (30 < e.g.length) { if (Ys(e) || Ys(t)) throw Error("slowDivide_ only works with positive integers."); for (var n = Ws, r = t; 0 >= r.X(e);)n = ro(n), r = ro(r); var i = io(n, 1), s = io(r, 1); for (r = io(r, 2), n = io(n, 2); !Xs(r);) { var o = s.add(r); 0 >= o.X(e) && (i = i.add(n), s = o), r = io(r, 1), n = io(n, 1) } return t = Zs(e, i.R(t)), new to(i, t) } for (i = Qs; 0 <= e.X(t);) { for (n = Math.max(1, Math.floor(e.ea() / t.ea())), r = 48 >= (r = Math.ceil(Math.log(n) / Math.LN2)) ? 1 : Math.pow(2, r - 48), o = (s = Gs(n)).R(t); Ys(o) || 0 < o.X(e);)o = (s = Gs(n -= r)).R(t); Xs(s) && (s = Ws), i = i.add(s), e = Zs(e, o) } return new to(i, e) } function ro(e) { for (var t = e.g.length + 1, n = [], r = 0; r < t; r++)n[r] = e.D(r) << 1 | e.D(r - 1) >>> 31; return new zs(n, e.h) } function io(e, t) { var n = t >> 5; t %= 32; for (var r = e.g.length - n, i = [], s = 0; s < r; s++)i[s] = 0 < t ? e.D(s + n) >>> t | e.D(s + n + 1) << 32 - t : e.D(s + n); return new zs(i, e.h) } ($t = zs.prototype).ea = function () { if (Ys(this)) return -Js(this).ea(); for (var e = 0, t = 1, n = 0; n < this.g.length; n++) { var r = this.D(n); e += (0 <= r ? r : Hs + r) * t, t *= Hs } return e }, $t.toString = function (e) { if (2 > (e = e || 10) || 36 < e) throw Error("radix out of range: " + e); if (Xs(this)) return "0"; if (Ys(this)) return "-" + Js(this).toString(e); for (var t = Gs(Math.pow(e, 6)), n = this, r = ""; ;) { var i = no(n, t).g, s = ((0 < (n = Zs(n, i.R(t))).g.length ? n.g[0] : n.h) >>> 0).toString(e); if (Xs(n = i)) return s + r; for (; 6 > s.length;)s = "0" + s; r = s + r } }, $t.D = function (e) { return 0 > e ? 0 : e < this.g.length ? this.g[e] : this.h }, $t.X = function (e) { return Ys(e = Zs(this, e)) ? -1 : Xs(e) ? 0 : 1 }, $t.abs = function () { return Ys(this) ? Js(this) : this }, $t.add = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0, i = 0; i <= t; i++) { var s = r + (65535 & this.D(i)) + (65535 & e.D(i)), o = (s >>> 16) + (this.D(i) >>> 16) + (e.D(i) >>> 16); r = o >>> 16, s &= 65535, o &= 65535, n[i] = o << 16 | s } return new zs(n, -2147483648 & n[n.length - 1] ? -1 : 0) }, $t.R = function (e) { if (Xs(this) || Xs(e)) return Qs; if (Ys(this)) return Ys(e) ? Js(this).R(Js(e)) : Js(Js(this).R(e)); if (Ys(e)) return Js(this.R(Js(e))); if (0 > this.X($s) && 0 > e.X($s)) return Gs(this.ea() * e.ea()); for (var t = this.g.length + e.g.length, n = [], r = 0; r < 2 * t; r++)n[r] = 0; for (r = 0; r < this.g.length; r++)for (var i = 0; i < e.g.length; i++) { var s = this.D(r) >>> 16, o = 65535 & this.D(r), a = e.D(i) >>> 16, l = 65535 & e.D(i); n[2 * r + 2 * i] += o * l, eo(n, 2 * r + 2 * i), n[2 * r + 2 * i + 1] += s * l, eo(n, 2 * r + 2 * i + 1), n[2 * r + 2 * i + 1] += o * a, eo(n, 2 * r + 2 * i + 1), n[2 * r + 2 * i + 2] += s * a, eo(n, 2 * r + 2 * i + 2) } for (r = 0; r < t; r++)n[r] = n[2 * r + 1] << 16 | n[2 * r]; for (r = t; r < 2 * t; r++)n[r] = 0; return new zs(n, 0) }, $t.gb = function (e) { return no(this, e).h }, $t.and = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0; r < t; r++)n[r] = this.D(r) & e.D(r); return new zs(n, this.h & e.h) }, $t.or = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0; r < t; r++)n[r] = this.D(r) | e.D(r); return new zs(n, this.h | e.h) }, $t.xor = function (e) { for (var t = Math.max(this.g.length, e.g.length), n = [], r = 0; r < t; r++)n[r] = this.D(r) ^ e.D(r); return new zs(n, this.h ^ e.h) }, Ls.prototype.createWebChannel = Ls.prototype.g, Fs.prototype.send = Fs.prototype.u, Fs.prototype.open = Fs.prototype.m, Fs.prototype.close = Fs.prototype.close, Vr.NO_ERROR = 0, Vr.TIMEOUT = 8, Vr.HTTP_ERROR = 6, Br.COMPLETE = "complete", qr.EventType = Gr, Gr.OPEN = "a", Gr.CLOSE = "b", Gr.ERROR = "c", Gr.MESSAGE = "d", sr.prototype.listen = sr.prototype.O, ts.prototype.listenOnce = ts.prototype.P, ts.prototype.getLastError = ts.prototype.Sa, ts.prototype.getLastErrorCode = ts.prototype.Ia, ts.prototype.getStatus = ts.prototype.da, ts.prototype.getResponseJson = ts.prototype.Wa, ts.prototype.getResponseText = ts.prototype.ja, ts.prototype.send = ts.prototype.ha, ts.prototype.setWithCredentials = ts.prototype.Oa, Bs.prototype.digest = Bs.prototype.l, Bs.prototype.reset = Bs.prototype.reset, Bs.prototype.update = Bs.prototype.j, zs.prototype.add = zs.prototype.add, zs.prototype.multiply = zs.prototype.R, zs.prototype.modulo = zs.prototype.gb, zs.prototype.compare = zs.prototype.X, zs.prototype.toNumber = zs.prototype.ea, zs.prototype.toString = zs.prototype.toString, zs.prototype.getBits = zs.prototype.D, zs.fromNumber = Gs, zs.fromString = function e(t, n) { if (0 == t.length) throw Error("number format error: empty string"); if (2 > (n = n || 10) || 36 < n) throw Error("radix out of range: " + n); if ("-" == t.charAt(0)) return Js(e(t.substring(1), n)); if (0 <= t.indexOf("-")) throw Error('number format error: interior "-" character'); for (var r = Gs(Math.pow(n, 8)), i = Qs, s = 0; s < t.length; s += 8) { var o = Math.min(8, t.length - s), a = parseInt(t.substring(s, s + o), n); 8 > o ? (o = Gs(Math.pow(n, o)), i = i.R(o).add(Gs(a))) : i = (i = i.R(r)).add(Gs(a)) } return i }; var so = Yt.createWebChannelTransport = function () { return new Ls }, oo = Yt.getStatEventTarget = function () { return Or() }, ao = Yt.ErrorCode = Vr, lo = Yt.EventType = Br, co = Yt.Event = Dr, uo = Yt.Stat = { xb: 0, Ab: 1, Bb: 2, Ub: 3, Zb: 4, Wb: 5, Xb: 6, Vb: 7, Tb: 8, Yb: 9, PROXY: 10, NOPROXY: 11, Rb: 12, Nb: 13, Ob: 14, Mb: 15, Pb: 16, Qb: 17, tb: 18, sb: 19, ub: 20 }, ho = Yt.FetchXmlHttpFactory = Wi, fo = Yt.WebChannel = qr, po = Yt.XhrIo = ts, mo = Yt.Md5 = Bs, go = Yt.Integer = zs; const yo = "@firebase/firestore"; class vo { constructor(e) { this.uid = e } isAuthenticated() { return null != this.uid } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(e) { return e.uid === this.uid } } vo.UNAUTHENTICATED = new vo(null), vo.GOOGLE_CREDENTIALS = new vo("google-credentials-uid"), vo.FIRST_PARTY = new vo("first-party-uid"), vo.MOCK_USER = new vo("mock-user"); let wo = "9.23.0"; const bo = new Ke("@firebase/firestore"); function Eo() { return bo.logLevel } function So(e) { if (bo.logLevel <= Ve.DEBUG) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n.map(Io); bo.debug("Firestore (".concat(wo, "): ").concat(e), ...i) } } function _o(e) { if (bo.logLevel <= Ve.ERROR) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n.map(Io); bo.error("Firestore (".concat(wo, "): ").concat(e), ...i) } } function xo(e) { if (bo.logLevel <= Ve.WARN) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; const i = n.map(Io); bo.warn("Firestore (".concat(wo, "): ").concat(e), ...i) } } function Io(e) { if ("string" == typeof e) return e; try { return t = e, JSON.stringify(t) } catch (t) { return e } var t } function To() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Unexpected state"; const t = "FIRESTORE (".concat(wo, ") INTERNAL ASSERTION FAILED: ") + e; throw _o(t), new Error(t) } function ko(e, t) { e || To() } function Co(e, t) { return e } const No = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class Do extends xe { constructor(e, t) { super(e, t), this.code = e, this.message = t, this.toString = () => "".concat(this.name, ": [code=").concat(this.code, "]: ").concat(this.message) } } class Ao { constructor() { this.promise = new Promise(((e, t) => { this.resolve = e, this.reject = t })) } } class Oo { constructor(e, t) { this.user = t, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", "Bearer ".concat(e)) } } class Ro { getToken() { return Promise.resolve(null) } invalidateToken() { } start(e, t) { e.enqueueRetryable((() => t(vo.UNAUTHENTICATED))) } shutdown() { } } class Po { constructor(e) { this.token = e, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(e, t) { this.changeListener = t, e.enqueueRetryable((() => t(this.token.user))) } shutdown() { this.changeListener = null } } class Lo { constructor(e) { this.t = e, this.currentUser = vo.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(e, t) { let n = this.i; const r = e => this.i !== n ? (n = this.i, t(e)) : Promise.resolve(); let i = new Ao; this.o = () => { this.i++, this.currentUser = this.u(), i.resolve(), i = new Ao, e.enqueueRetryable((() => r(this.currentUser))) }; const s = () => { const t = i; e.enqueueRetryable((async () => { await t.promise, await r(this.currentUser) })) }, o = e => { So("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = e, this.auth.addAuthTokenListener(this.o), s() }; this.t.onInit((e => o(e))), setTimeout((() => { if (!this.auth) { const e = this.t.getImmediate({ optional: !0 }); e ? o(e) : (So("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new Ao) } }), 0), s() } getToken() { const e = this.i, t = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then((t => this.i !== e ? (So("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : t ? (ko("string" == typeof t.accessToken), new Oo(t.accessToken, this.currentUser)) : null)) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.auth.removeAuthTokenListener(this.o) } u() { const e = this.auth && this.auth.getUid(); return ko(null === e || "string" == typeof e), new vo(e) } } class Fo { constructor(e, t, n) { this.h = e, this.l = t, this.m = n, this.type = "FirstParty", this.user = vo.FIRST_PARTY, this.g = new Map } p() { return this.m ? this.m() : null } get headers() { this.g.set("X-Goog-AuthUser", this.h); const e = this.p(); return e && this.g.set("Authorization", e), this.l && this.g.set("X-Goog-Iam-Authorization-Token", this.l), this.g } } class Mo { constructor(e, t, n) { this.h = e, this.l = t, this.m = n } getToken() { return Promise.resolve(new Fo(this.h, this.l, this.m)) } start(e, t) { e.enqueueRetryable((() => t(vo.FIRST_PARTY))) } shutdown() { } invalidateToken() { } } class jo { constructor(e) { this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class Vo { constructor(e) { this.I = e, this.forceRefresh = !1, this.appCheck = null, this.T = null } start(e, t) { const n = e => { null != e.error && So("FirebaseAppCheckTokenProvider", "Error getting App Check token; using placeholder token instead. Error: ".concat(e.error.message)); const n = e.token !== this.T; return this.T = e.token, So("FirebaseAppCheckTokenProvider", "Received ".concat(n ? "new" : "existing", " token.")), n ? t(e.token) : Promise.resolve() }; this.o = t => { e.enqueueRetryable((() => n(t))) }; const r = e => { So("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = e, this.appCheck.addTokenListener(this.o) }; this.I.onInit((e => r(e))), setTimeout((() => { if (!this.appCheck) { const e = this.I.getImmediate({ optional: !0 }); e ? r(e) : So("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }), 0) } getToken() { const e = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then((e => e ? (ko("string" == typeof e.token), this.T = e.token, new jo(e.token)) : null)) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.appCheck.removeTokenListener(this.o) } } function Bo(e) { const t = "undefined" != typeof self && (self.crypto || self.msCrypto), n = new Uint8Array(e); if (t && "function" == typeof t.getRandomValues) t.getRandomValues(n); else for (let r = 0; r < e; r++)n[r] = Math.floor(256 * Math.random()); return n } class Uo { static A() { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = 62 * Math.floor(256 / 62); let n = ""; for (; n.length < 20;) { const r = Bo(40); for (let i = 0; i < r.length; ++i)n.length < 20 && r[i] < t && (n += e.charAt(r[i] % 62)) } return n } } function zo(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function qo(e, t, n) { return e.length === t.length && e.every(((e, r) => n(e, t[r]))) } function Ko(e) { return e + "\0" } class Go { constructor(e, t) { if (this.seconds = e, this.nanoseconds = t, t < 0) throw new Do(No.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (t >= 1e9) throw new Do(No.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (e < -62135596800) throw new Do(No.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e); if (e >= 253402300800) throw new Do(No.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e) } static now() { return Go.fromMillis(Date.now()) } static fromDate(e) { return Go.fromMillis(e.getTime()) } static fromMillis(e) { const t = Math.floor(e / 1e3), n = Math.floor(1e6 * (e - 1e3 * t)); return new Go(t, n) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / 1e6 } _compareTo(e) { return this.seconds === e.seconds ? zo(this.nanoseconds, e.nanoseconds) : zo(this.seconds, e.seconds) } isEqual(e) { return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { seconds: this.seconds, nanoseconds: this.nanoseconds } } valueOf() { const e = this.seconds - -62135596800; return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } } class Ho { constructor(e) { this.timestamp = e } static fromTimestamp(e) { return new Ho(e) } static min() { return new Ho(new Go(0, 0)) } static max() { return new Ho(new Go(253402300799, 999999999)) } compareTo(e) { return this.timestamp._compareTo(e.timestamp) } isEqual(e) { return this.timestamp.isEqual(e.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } } class Qo { constructor(e, t, n) { void 0 === t ? t = 0 : t > e.length && To(), void 0 === n ? n = e.length - t : n > e.length - t && To(), this.segments = e, this.offset = t, this.len = n } get length() { return this.len } isEqual(e) { return 0 === Qo.comparator(this, e) } child(e) { const t = this.segments.slice(this.offset, this.limit()); return e instanceof Qo ? e.forEach((e => { t.push(e) })) : t.push(e), this.construct(t) } limit() { return this.offset + this.length } popFirst(e) { return e = void 0 === e ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(e) { return this.segments[this.offset + e] } isEmpty() { return 0 === this.length } isPrefixOf(e) { if (e.length < this.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } isImmediateParentOf(e) { if (this.length + 1 !== e.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } forEach(e) { for (let t = this.offset, n = this.limit(); t < n; t++)e(this.segments[t]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(e, t) { const n = Math.min(e.length, t.length); for (let r = 0; r < n; r++) { const n = e.get(r), i = t.get(r); if (n < i) return -1; if (n > i) return 1 } return e.length < t.length ? -1 : e.length > t.length ? 1 : 0 } } class Wo extends Qo { construct(e, t, n) { return new Wo(e, t, n) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } static fromString() { const e = []; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; for (const i of n) { if (i.indexOf("//") >= 0) throw new Do(No.INVALID_ARGUMENT, "Invalid segment (".concat(i, "). Paths must not contain // in them.")); e.push(...i.split("/").filter((e => e.length > 0))) } return new Wo(e) } static emptyPath() { return new Wo([]) } } const $o = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class Xo extends Qo { construct(e, t, n) { return new Xo(e, t, n) } static isValidIdentifier(e) { return $o.test(e) } canonicalString() { return this.toArray().map((e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Xo.isValidIdentifier(e) || (e = "`" + e + "`"), e))).join(".") } toString() { return this.canonicalString() } isKeyField() { return 1 === this.length && "__name__" === this.get(0) } static keyField() { return new Xo(["__name__"]) } static fromServerFormat(e) { const t = []; let n = "", r = 0; const i = () => { if (0 === n.length) throw new Do(No.INVALID_ARGUMENT, "Invalid field path (".concat(e, "). Paths must not be empty, begin with '.', end with '.', or contain '..'")); t.push(n), n = "" }; let s = !1; for (; r < e.length;) { const t = e[r]; if ("\\" === t) { if (r + 1 === e.length) throw new Do(No.INVALID_ARGUMENT, "Path has trailing escape character: " + e); const t = e[r + 1]; if ("\\" !== t && "." !== t && "`" !== t) throw new Do(No.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e); n += t, r += 2 } else "`" === t ? (s = !s, r++) : "." !== t || s ? (n += t, r++) : (i(), r++) } if (i(), s) throw new Do(No.INVALID_ARGUMENT, "Unterminated ` in path: " + e); return new Xo(t) } static emptyPath() { return new Xo([]) } } class Yo { constructor(e) { this.path = e } static fromPath(e) { return new Yo(Wo.fromString(e)) } static fromName(e) { return new Yo(Wo.fromString(e).popFirst(5)) } static empty() { return new Yo(Wo.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(e) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === e } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(e) { return null !== e && 0 === Wo.comparator(this.path, e.path) } toString() { return this.path.toString() } static comparator(e, t) { return Wo.comparator(e.path, t.path) } static isDocumentKey(e) { return e.length % 2 == 0 } static fromSegments(e) { return new Yo(new Wo(e.slice())) } } class Jo { constructor(e, t, n, r) { this.indexId = e, this.collectionGroup = t, this.fields = n, this.indexState = r } } function Zo(e) { return e.fields.find((e => 2 === e.kind)) } function ea(e) { return e.fields.filter((e => 2 !== e.kind)) } Jo.UNKNOWN_ID = -1; class ta { constructor(e, t) { this.fieldPath = e, this.kind = t } } class na { constructor(e, t) { this.sequenceNumber = e, this.offset = t } static empty() { return new na(0, sa.min()) } } function ra(e, t) { const n = e.toTimestamp().seconds, r = e.toTimestamp().nanoseconds + 1, i = Ho.fromTimestamp(1e9 === r ? new Go(n + 1, 0) : new Go(n, r)); return new sa(i, Yo.empty(), t) } function ia(e) { return new sa(e.readTime, e.key, -1) } class sa { constructor(e, t, n) { this.readTime = e, this.documentKey = t, this.largestBatchId = n } static min() { return new sa(Ho.min(), Yo.empty(), -1) } static max() { return new sa(Ho.max(), Yo.empty(), -1) } } function oa(e, t) { let n = e.readTime.compareTo(t.readTime); return 0 !== n ? n : (n = Yo.comparator(e.documentKey, t.documentKey), 0 !== n ? n : zo(e.largestBatchId, t.largestBatchId)) } const aa = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class la { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(e) { this.onCommittedListeners.push(e) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach((e => e())) } } async function ca(e) { if (e.code !== No.FAILED_PRECONDITION || e.message !== aa) throw e; So("LocalStore", "Unexpectedly lost primary lease") } class ua { constructor(e) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e((e => { this.isDone = !0, this.result = e, this.nextCallback && this.nextCallback(e) }), (e => { this.isDone = !0, this.error = e, this.catchCallback && this.catchCallback(e) })) } catch(e) { return this.next(void 0, e) } next(e, t) { return this.callbackAttached && To(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new ua(((n, r) => { this.nextCallback = t => { this.wrapSuccess(e, t).next(n, r) }, this.catchCallback = e => { this.wrapFailure(t, e).next(n, r) } })) } toPromise() { return new Promise(((e, t) => { this.next(e, t) })) } wrapUserFunction(e) { try { const t = e(); return t instanceof ua ? t : ua.resolve(t) } catch (e) { return ua.reject(e) } } wrapSuccess(e, t) { return e ? this.wrapUserFunction((() => e(t))) : ua.resolve(t) } wrapFailure(e, t) { return e ? this.wrapUserFunction((() => e(t))) : ua.reject(t) } static resolve(e) { return new ua(((t, n) => { t(e) })) } static reject(e) { return new ua(((t, n) => { n(e) })) } static waitFor(e) { return new ua(((t, n) => { let r = 0, i = 0, s = !1; e.forEach((e => { ++r, e.next((() => { ++i, s && i === r && t() }), (e => n(e))) })), s = !0, i === r && t() })) } static or(e) { let t = ua.resolve(!1); for (const n of e) t = t.next((e => e ? ua.resolve(e) : n())); return t } static forEach(e, t) { const n = []; return e.forEach(((e, r) => { n.push(t.call(this, e, r)) })), this.waitFor(n) } static mapArray(e, t) { return new ua(((n, r) => { const i = e.length, s = new Array(i); let o = 0; for (let a = 0; a < i; a++) { const l = a; t(e[l]).next((e => { s[l] = e, ++o, o === i && n(s) }), (e => r(e))) } })) } static doWhile(e, t) { return new ua(((n, r) => { const i = () => { !0 === e() ? t().next((() => { i() }), r) : n() }; i() })) } } class ha { constructor(e, t) { this.action = e, this.transaction = t, this.aborted = !1, this.v = new Ao, this.transaction.oncomplete = () => { this.v.resolve() }, this.transaction.onabort = () => { t.error ? this.v.reject(new pa(e, t.error)) : this.v.resolve() }, this.transaction.onerror = t => { const n = wa(t.target.error); this.v.reject(new pa(e, n)) } } static open(e, t, n, r) { try { return new ha(t, e.transaction(r, n)) } catch (e) { throw new pa(t, e) } } get R() { return this.v.promise } abort(e) { e && this.v.reject(e), this.aborted || (So("SimpleDb", "Aborting transaction:", e ? e.message : "Client-initiated abort"), this.aborted = !0, this.transaction.abort()) } P() { const e = this.transaction; this.aborted || "function" != typeof e.commit || e.commit() } store(e) { const t = this.transaction.objectStore(e); return new ga(t) } } class da { constructor(e, t, n) { this.name = e, this.version = t, this.V = n, 12.2 === da.S(Ee()) && _o("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.") } static delete(e) { return So("SimpleDb", "Removing database:", e), ya(window.indexedDB.deleteDatabase(e)).toPromise() } static D() { if (!_e()) return !1; if (da.C()) return !0; const e = Ee(), t = da.S(e), n = 0 < t && t < 10, r = da.N(e), i = 0 < r && r < 4.5; return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || n || i) } static C() { var e; return "undefined" != typeof process && "YES" === (null === (e = { NODE_ENV: "production", PUBLIC_URL: "", WDS_SOCKET_HOST: void 0, WDS_SOCKET_PATH: void 0, WDS_SOCKET_PORT: void 0, FAST_REFRESH: !0 }) || void 0 === e ? void 0 : e.k) } static M(e, t) { return e.store(t) } static S(e) { const t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = t ? t[1].split("_").slice(0, 2).join(".") : "-1"; return Number(n) } static N(e) { const t = e.match(/Android ([\d.]+)/i), n = t ? t[1].split(".").slice(0, 2).join(".") : "-1"; return Number(n) } async $(e) { return this.db || (So("SimpleDb", "Opening database:", this.name), this.db = await new Promise(((t, n) => { const r = indexedDB.open(this.name, this.version); r.onsuccess = e => { const n = e.target.result; t(n) }, r.onblocked = () => { n(new pa(e, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.")) }, r.onerror = t => { const r = t.target.error; "VersionError" === r.name ? n(new Do(No.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === r.name ? n(new Do(No.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + r)) : n(new pa(e, r)) }, r.onupgradeneeded = e => { So("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', e.oldVersion); const t = e.target.result; this.V.O(t, r.transaction, e.oldVersion, this.version).next((() => { So("SimpleDb", "Database upgrade to version " + this.version + " complete") })) } }))), this.F && (this.db.onversionchange = e => this.F(e)), this.db } B(e) { this.F = e, this.db && (this.db.onversionchange = t => e(t)) } async runTransaction(e, t, n, r) { const i = "readonly" === t; let s = 0; for (; ;) { ++s; try { this.db = await this.$(e); const t = ha.open(this.db, e, i ? "readonly" : "readwrite", n), s = r(t).next((e => (t.P(), e))).catch((e => (t.abort(e), ua.reject(e)))).toPromise(); return s.catch((() => { })), await t.R, s } catch (e) { const t = e, n = "FirebaseError" !== t.name && s < 3; if (So("SimpleDb", "Transaction failed with error:", t.message, "Retrying:", n), this.close(), !n) return Promise.reject(t) } } } close() { this.db && this.db.close(), this.db = void 0 } } class fa { constructor(e) { this.L = e, this.q = !1, this.U = null } get isDone() { return this.q } get K() { return this.U } set cursor(e) { this.L = e } done() { this.q = !0 } G(e) { this.U = e } delete() { return ya(this.L.delete()) } } class pa extends Do { constructor(e, t) { super(No.UNAVAILABLE, "IndexedDB transaction '".concat(e, "' failed: ").concat(t)), this.name = "IndexedDbTransactionError" } } function ma(e) { return "IndexedDbTransactionError" === e.name } class ga { constructor(e) { this.store = e } put(e, t) { let n; return void 0 !== t ? (So("SimpleDb", "PUT", this.store.name, e, t), n = this.store.put(t, e)) : (So("SimpleDb", "PUT", this.store.name, "<auto-key>", e), n = this.store.put(e)), ya(n) } add(e) { return So("SimpleDb", "ADD", this.store.name, e, e), ya(this.store.add(e)) } get(e) { return ya(this.store.get(e)).next((t => (void 0 === t && (t = null), So("SimpleDb", "GET", this.store.name, e, t), t))) } delete(e) { return So("SimpleDb", "DELETE", this.store.name, e), ya(this.store.delete(e)) } count() { return So("SimpleDb", "COUNT", this.store.name), ya(this.store.count()) } j(e, t) { const n = this.options(e, t); if (n.index || "function" != typeof this.store.getAll) { const e = this.cursor(n), t = []; return this.W(e, ((e, n) => { t.push(n) })).next((() => t)) } { const e = this.store.getAll(n.range); return new ua(((t, n) => { e.onerror = e => { n(e.target.error) }, e.onsuccess = e => { t(e.target.result) } })) } } H(e, t) { const n = this.store.getAll(e, null === t ? void 0 : t); return new ua(((e, t) => { n.onerror = e => { t(e.target.error) }, n.onsuccess = t => { e(t.target.result) } })) } J(e, t) { So("SimpleDb", "DELETE ALL", this.store.name); const n = this.options(e, t); n.Y = !1; const r = this.cursor(n); return this.W(r, ((e, t, n) => n.delete())) } X(e, t) { let n; t ? n = e : (n = {}, t = e); const r = this.cursor(n); return this.W(r, t) } Z(e) { const t = this.cursor({}); return new ua(((n, r) => { t.onerror = e => { const t = wa(e.target.error); r(t) }, t.onsuccess = t => { const r = t.target.result; r ? e(r.primaryKey, r.value).next((e => { e ? r.continue() : n() })) : n() } })) } W(e, t) { const n = []; return new ua(((r, i) => { e.onerror = e => { i(e.target.error) }, e.onsuccess = e => { const i = e.target.result; if (!i) return void r(); const s = new fa(i), o = t(i.primaryKey, i.value, s); if (o instanceof ua) { const e = o.catch((e => (s.done(), ua.reject(e)))); n.push(e) } s.isDone ? r() : null === s.K ? i.continue() : i.continue(s.K) } })).next((() => ua.waitFor(n))) } options(e, t) { let n; return void 0 !== e && ("string" == typeof e ? n = e : t = e), { index: n, range: t } } cursor(e) { let t = "next"; if (e.reverse && (t = "prev"), e.index) { const n = this.store.index(e.index); return e.Y ? n.openKeyCursor(e.range, t) : n.openCursor(e.range, t) } return this.store.openCursor(e.range, t) } } function ya(e) { return new ua(((t, n) => { e.onsuccess = e => { const n = e.target.result; t(n) }, e.onerror = e => { const t = wa(e.target.error); n(t) } })) } let va = !1; function wa(e) { const t = da.S(Ee()); if (t >= 12.2 && t < 13) { const t = "An internal error was encountered in the Indexed Database server"; if (e.message.indexOf(t) >= 0) { const e = new Do("internal", "IOS_INDEXEDDB_BUG1: IndexedDb has thrown '".concat(t, "'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.")); return va || (va = !0, setTimeout((() => { throw e }), 0)), e } } return e } class ba { constructor(e, t) { this.asyncQueue = e, this.tt = t, this.task = null } start() { this.et(15e3) } stop() { this.task && (this.task.cancel(), this.task = null) } get started() { return null !== this.task } et(e) { So("IndexBackiller", "Scheduled in ".concat(e, "ms")), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", e, (async () => { this.task = null; try { So("IndexBackiller", "Documents written: ".concat(await this.tt.nt())) } catch (e) { ma(e) ? So("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", e) : await ca(e) } await this.et(6e4) })) } } class Ea { constructor(e, t) { this.localStore = e, this.persistence = t } async nt() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50; return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", (t => this.st(t, e))) } st(e, t) { const n = new Set; let r = t, i = !0; return ua.doWhile((() => !0 === i && r > 0), (() => this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next((t => { if (null !== t && !n.has(t)) return So("IndexBackiller", "Processing collection: ".concat(t)), this.it(e, t, r).next((e => { r -= e, n.add(t) })); i = !1 })))).next((() => t - r)) } it(e, t, n) { return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, t).next((r => this.localStore.localDocuments.getNextDocuments(e, t, r, n).next((n => { const i = n.changes; return this.localStore.indexManager.updateIndexEntries(e, i).next((() => this.rt(r, n))).next((n => (So("IndexBackiller", "Updating offset: ".concat(n)), this.localStore.indexManager.updateCollectionGroup(e, t, n)))).next((() => i.size)) })))) } rt(e, t) { let n = e; return t.changes.forEach(((e, t) => { const r = ia(t); oa(r, n) > 0 && (n = r) })), new sa(n.readTime, n.documentKey, Math.max(t.batchId, e.largestBatchId)) } } class Sa { constructor(e, t) { this.previousValue = e, t && (t.sequenceNumberHandler = e => this.ot(e), this.ut = e => t.writeSequenceNumber(e)) } ot(e) { return this.previousValue = Math.max(e, this.previousValue), this.previousValue } next() { const e = ++this.previousValue; return this.ut && this.ut(e), e } } function _a(e) { return null == e } function xa(e) { return 0 === e && 1 / e == -1 / 0 } function Ia(e) { return "number" == typeof e && Number.isInteger(e) && !xa(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER } function Ta(e) { let t = ""; for (let n = 0; n < e.length; n++)t.length > 0 && (t = Ca(t)), t = ka(e.get(n), t); return Ca(t) } function ka(e, t) { let n = t; const r = e.length; for (let i = 0; i < r; i++) { const t = e.charAt(i); switch (t) { case "\0": n += "\x01\x10"; break; case "\x01": n += "\x01\x11"; break; default: n += t } } return n } function Ca(e) { return e + "\x01\x01" } function Na(e) { const t = e.length; if (ko(t >= 2), 2 === t) return ko("\x01" === e.charAt(0) && "\x01" === e.charAt(1)), Wo.emptyPath(); const n = t - 2, r = []; let i = ""; for (let s = 0; s < t;) { const t = e.indexOf("\x01", s); switch ((t < 0 || t > n) && To(), e.charAt(t + 1)) { case "\x01": const n = e.substring(s, t); let o; 0 === i.length ? o = n : (i += n, o = i, i = ""), r.push(o); break; case "\x10": i += e.substring(s, t), i += "\0"; break; case "\x11": i += e.substring(s, t + 1); break; default: To() }s = t + 2 } return new Wo(r) } Sa.ct = -1; const Da = ["userId", "batchId"]; function Aa(e, t) { return [e, Ta(t)] } function Oa(e, t, n) { return [e, Ta(t), n] } const Ra = {}, Pa = ["prefixPath", "collectionGroup", "readTime", "documentId"], La = ["prefixPath", "collectionGroup", "documentId"], Fa = ["collectionGroup", "readTime", "prefixPath", "documentId"], Ma = ["canonicalId", "targetId"], ja = ["targetId", "path"], Va = ["path", "targetId"], Ba = ["collectionId", "parent"], Ua = ["indexId", "uid"], za = ["uid", "sequenceNumber"], qa = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"], Ka = ["indexId", "uid", "orderedDocumentKey"], Ga = ["userId", "collectionPath", "documentId"], Ha = ["userId", "collectionPath", "largestBatchId"], Qa = ["userId", "collectionGroup", "largestBatchId"], Wa = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"], $a = [...Wa, "documentOverlays"], Xa = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"], Ya = Xa, Ja = [...Ya, "indexConfiguration", "indexState", "indexEntries"]; class Za extends la { constructor(e, t) { super(), this.ht = e, this.currentSequenceNumber = t } } function el(e, t) { const n = Co(e); return da.M(n.ht, t) } function tl(e) { let t = 0; for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++; return t } function nl(e, t) { for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n]) } function rl(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } class il { constructor(e, t) { this.comparator = e, this.root = t || ol.EMPTY } insert(e, t) { return new il(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, ol.BLACK, null, null)) } remove(e) { return new il(this.comparator, this.root.remove(e, this.comparator).copy(null, null, ol.BLACK, null, null)) } get(e) { let t = this.root; for (; !t.isEmpty();) { const n = this.comparator(e, t.key); if (0 === n) return t.value; n < 0 ? t = t.left : n > 0 && (t = t.right) } return null } indexOf(e) { let t = 0, n = this.root; for (; !n.isEmpty();) { const r = this.comparator(e, n.key); if (0 === r) return t + n.left.size; r < 0 ? n = n.left : (t += n.left.size + 1, n = n.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(e) { return this.root.inorderTraversal(e) } forEach(e) { this.inorderTraversal(((t, n) => (e(t, n), !1))) } toString() { const e = []; return this.inorderTraversal(((t, n) => (e.push("".concat(t, ":").concat(n)), !1))), "{".concat(e.join(", "), "}") } reverseTraversal(e) { return this.root.reverseTraversal(e) } getIterator() { return new sl(this.root, null, this.comparator, !1) } getIteratorFrom(e) { return new sl(this.root, e, this.comparator, !1) } getReverseIterator() { return new sl(this.root, null, this.comparator, !0) } getReverseIteratorFrom(e) { return new sl(this.root, e, this.comparator, !0) } } class sl { constructor(e, t, n, r) { this.isReverse = r, this.nodeStack = []; let i = 1; for (; !e.isEmpty();)if (i = t ? n(e.key, t) : 1, t && r && (i *= -1), i < 0) e = this.isReverse ? e.left : e.right; else { if (0 === i) { this.nodeStack.push(e); break } this.nodeStack.push(e), e = this.isReverse ? e.right : e.left } } getNext() { let e = this.nodeStack.pop(); const t = { key: e.key, value: e.value }; if (this.isReverse) for (e = e.left; !e.isEmpty();)this.nodeStack.push(e), e = e.right; else for (e = e.right; !e.isEmpty();)this.nodeStack.push(e), e = e.left; return t } hasNext() { return this.nodeStack.length > 0 } peek() { if (0 === this.nodeStack.length) return null; const e = this.nodeStack[this.nodeStack.length - 1]; return { key: e.key, value: e.value } } } class ol { constructor(e, t, n, r, i) { this.key = e, this.value = t, this.color = null != n ? n : ol.RED, this.left = null != r ? r : ol.EMPTY, this.right = null != i ? i : ol.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(e, t, n, r, i) { return new ol(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right) } isEmpty() { return !1 } inorderTraversal(e) { return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e) } reverseTraversal(e) { return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(e, t, n) { let r = this; const i = n(e, r.key); return r = i < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === i ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n)), r.fixUp() } removeMin() { if (this.left.isEmpty()) return ol.EMPTY; let e = this; return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp() } remove(e, t) { let n, r = this; if (t(e, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(e, t), null); else { if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === t(e, r.key)) { if (r.right.isEmpty()) return ol.EMPTY; n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin()) } r = r.copy(null, null, null, null, r.right.remove(e, t)) } return r.fixUp() } isRed() { return this.color } fixUp() { let e = this; return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e } moveRedLeft() { let e = this.colorFlip(); return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e } moveRedRight() { let e = this.colorFlip(); return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e } rotateLeft() { const e = this.copy(null, null, ol.RED, null, this.right.left); return this.right.copy(null, null, this.color, e, null) } rotateRight() { const e = this.copy(null, null, ol.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, e) } colorFlip() { const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, e, t) } checkMaxDepth() { const e = this.check(); return Math.pow(2, e) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed()) throw To(); if (this.right.isRed()) throw To(); const e = this.left.check(); if (e !== this.right.check()) throw To(); return e + (this.isRed() ? 0 : 1) } } ol.EMPTY = null, ol.RED = !0, ol.BLACK = !1, ol.EMPTY = new class { constructor() { this.size = 0 } get key() { throw To() } get value() { throw To() } get color() { throw To() } get left() { throw To() } get right() { throw To() } copy(e, t, n, r, i) { return this } insert(e, t, n) { return new ol(e, t) } remove(e, t) { return this } isEmpty() { return !0 } inorderTraversal(e) { return !1 } reverseTraversal(e) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } }; class al { constructor(e) { this.comparator = e, this.data = new il(this.comparator) } has(e) { return null !== this.data.get(e) } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(e) { return this.data.indexOf(e) } forEach(e) { this.data.inorderTraversal(((t, n) => (e(t), !1))) } forEachInRange(e, t) { const n = this.data.getIteratorFrom(e[0]); for (; n.hasNext();) { const r = n.getNext(); if (this.comparator(r.key, e[1]) >= 0) return; t(r.key) } } forEachWhile(e, t) { let n; for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext();)if (!e(n.getNext().key)) return } firstAfterOrEqual(e) { const t = this.data.getIteratorFrom(e); return t.hasNext() ? t.getNext().key : null } getIterator() { return new ll(this.data.getIterator()) } getIteratorFrom(e) { return new ll(this.data.getIteratorFrom(e)) } add(e) { return this.copy(this.data.remove(e).insert(e, !0)) } delete(e) { return this.has(e) ? this.copy(this.data.remove(e)) : this } isEmpty() { return this.data.isEmpty() } unionWith(e) { let t = this; return t.size < e.size && (t = e, e = this), e.forEach((e => { t = t.add(e) })), t } isEqual(e) { if (!(e instanceof al)) return !1; if (this.size !== e.size) return !1; const t = this.data.getIterator(), n = e.data.getIterator(); for (; t.hasNext();) { const e = t.getNext().key, r = n.getNext().key; if (0 !== this.comparator(e, r)) return !1 } return !0 } toArray() { const e = []; return this.forEach((t => { e.push(t) })), e } toString() { const e = []; return this.forEach((t => e.push(t))), "SortedSet(" + e.toString() + ")" } copy(e) { const t = new al(this.comparator); return t.data = e, t } } class ll { constructor(e) { this.iter = e } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } } function cl(e) { return e.hasNext() ? e.getNext() : void 0 } class ul { constructor(e) { this.fields = e, e.sort(Xo.comparator) } static empty() { return new ul([]) } unionWith(e) { let t = new al(Xo.comparator); for (const n of this.fields) t = t.add(n); for (const n of e) t = t.add(n); return new ul(t.toArray()) } covers(e) { for (const t of this.fields) if (t.isPrefixOf(e)) return !0; return !1 } isEqual(e) { return qo(this.fields, e.fields, ((e, t) => e.isEqual(t))) } } class hl extends Error { constructor() { super(...arguments), this.name = "Base64DecodeError" } } class dl { constructor(e) { this.binaryString = e } static fromBase64String(e) { const t = function (e) { try { return atob(e) } catch (e) { throw "undefined" != typeof DOMException && e instanceof DOMException ? new hl("Invalid base64 string: " + e) : e } }(e); return new dl(t) } static fromUint8Array(e) { const t = function (e) { let t = ""; for (let n = 0; n < e.length; ++n)t += String.fromCharCode(e[n]); return t }(e); return new dl(t) } [Symbol.iterator]() { let e = 0; return { next: () => e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return e = this.binaryString, btoa(e); var e } toUint8Array() { return function (e) { const t = new Uint8Array(e.length); for (let n = 0; n < e.length; n++)t[n] = e.charCodeAt(n); return t }(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(e) { return zo(this.binaryString, e.binaryString) } isEqual(e) { return this.binaryString === e.binaryString } } dl.EMPTY_BYTE_STRING = new dl(""); const fl = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function pl(e) { if (ko(!!e), "string" == typeof e) { let t = 0; const n = fl.exec(e); if (ko(!!n), n[1]) { let e = n[1]; e = (e + "000000000").substr(0, 9), t = Number(e) } const r = new Date(e); return { seconds: Math.floor(r.getTime() / 1e3), nanos: t } } return { seconds: ml(e.seconds), nanos: ml(e.nanos) } } function ml(e) { return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0 } function gl(e) { return "string" == typeof e ? dl.fromBase64String(e) : dl.fromUint8Array(e) } function yl(e) { var t, n; return "server_timestamp" === (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue) } function vl(e) { const t = e.mapValue.fields.__previous_value__; return yl(t) ? vl(t) : t } function wl(e) { const t = pl(e.mapValue.fields.__local_write_time__.timestampValue); return new Go(t.seconds, t.nanos) } class bl { constructor(e, t, n, r, i, s, o, a, l) { this.databaseId = e, this.appId = t, this.persistenceKey = n, this.host = r, this.ssl = i, this.forceLongPolling = s, this.autoDetectLongPolling = o, this.longPollingOptions = a, this.useFetchStreams = l } } class El { constructor(e, t) { this.projectId = e, this.database = t || "(default)" } static empty() { return new El("", "") } get isDefaultDatabase() { return "(default)" === this.database } isEqual(e) { return e instanceof El && e.projectId === this.projectId && e.database === this.database } } const Sl = { mapValue: { fields: { __type__: { stringValue: "__max__" } } } }, _l = { nullValue: "NULL_VALUE" }; function xl(e) { return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? yl(e) ? 4 : jl(e) ? 9007199254740991 : 10 : To() } function Il(e, t) { if (e === t) return !0; const n = xl(e); if (n !== xl(t)) return !1; switch (n) { case 0: case 9007199254740991: return !0; case 1: return e.booleanValue === t.booleanValue; case 4: return wl(e).isEqual(wl(t)); case 3: return function (e, t) { if ("string" == typeof e.timestampValue && "string" == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length) return e.timestampValue === t.timestampValue; const n = pl(e.timestampValue), r = pl(t.timestampValue); return n.seconds === r.seconds && n.nanos === r.nanos }(e, t); case 5: return e.stringValue === t.stringValue; case 6: return function (e, t) { return gl(e.bytesValue).isEqual(gl(t.bytesValue)) }(e, t); case 7: return e.referenceValue === t.referenceValue; case 8: return function (e, t) { return ml(e.geoPointValue.latitude) === ml(t.geoPointValue.latitude) && ml(e.geoPointValue.longitude) === ml(t.geoPointValue.longitude) }(e, t); case 2: return function (e, t) { if ("integerValue" in e && "integerValue" in t) return ml(e.integerValue) === ml(t.integerValue); if ("doubleValue" in e && "doubleValue" in t) { const n = ml(e.doubleValue), r = ml(t.doubleValue); return n === r ? xa(n) === xa(r) : isNaN(n) && isNaN(r) } return !1 }(e, t); case 9: return qo(e.arrayValue.values || [], t.arrayValue.values || [], Il); case 10: return function (e, t) { const n = e.mapValue.fields || {}, r = t.mapValue.fields || {}; if (tl(n) !== tl(r)) return !1; for (const i in n) if (n.hasOwnProperty(i) && (void 0 === r[i] || !Il(n[i], r[i]))) return !1; return !0 }(e, t); default: return To() } } function Tl(e, t) { return void 0 !== (e.values || []).find((e => Il(e, t))) } function kl(e, t) { if (e === t) return 0; const n = xl(e), r = xl(t); if (n !== r) return zo(n, r); switch (n) { case 0: case 9007199254740991: return 0; case 1: return zo(e.booleanValue, t.booleanValue); case 2: return function (e, t) { const n = ml(e.integerValue || e.doubleValue), r = ml(t.integerValue || t.doubleValue); return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? isNaN(r) ? 0 : -1 : 1 }(e, t); case 3: return Cl(e.timestampValue, t.timestampValue); case 4: return Cl(wl(e), wl(t)); case 5: return zo(e.stringValue, t.stringValue); case 6: return function (e, t) { const n = gl(e), r = gl(t); return n.compareTo(r) }(e.bytesValue, t.bytesValue); case 7: return function (e, t) { const n = e.split("/"), r = t.split("/"); for (let i = 0; i < n.length && i < r.length; i++) { const e = zo(n[i], r[i]); if (0 !== e) return e } return zo(n.length, r.length) }(e.referenceValue, t.referenceValue); case 8: return function (e, t) { const n = zo(ml(e.latitude), ml(t.latitude)); return 0 !== n ? n : zo(ml(e.longitude), ml(t.longitude)) }(e.geoPointValue, t.geoPointValue); case 9: return function (e, t) { const n = e.values || [], r = t.values || []; for (let i = 0; i < n.length && i < r.length; ++i) { const e = kl(n[i], r[i]); if (e) return e } return zo(n.length, r.length) }(e.arrayValue, t.arrayValue); case 10: return function (e, t) { if (e === Sl.mapValue && t === Sl.mapValue) return 0; if (e === Sl.mapValue) return 1; if (t === Sl.mapValue) return -1; const n = e.fields || {}, r = Object.keys(n), i = t.fields || {}, s = Object.keys(i); r.sort(), s.sort(); for (let o = 0; o < r.length && o < s.length; ++o) { const e = zo(r[o], s[o]); if (0 !== e) return e; const t = kl(n[r[o]], i[s[o]]); if (0 !== t) return t } return zo(r.length, s.length) }(e.mapValue, t.mapValue); default: throw To() } } function Cl(e, t) { if ("string" == typeof e && "string" == typeof t && e.length === t.length) return zo(e, t); const n = pl(e), r = pl(t), i = zo(n.seconds, r.seconds); return 0 !== i ? i : zo(n.nanos, r.nanos) } function Nl(e) { return Dl(e) } function Dl(e) { return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? function (e) { const t = pl(e); return "time(".concat(t.seconds, ",").concat(t.nanos, ")") }(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? gl(e.bytesValue).toBase64() : "referenceValue" in e ? (n = e.referenceValue, Yo.fromName(n).toString()) : "geoPointValue" in e ? "geo(".concat((t = e.geoPointValue).latitude, ",").concat(t.longitude, ")") : "arrayValue" in e ? function (e) { let t = "[", n = !0; for (const r of e.values || []) n ? n = !1 : t += ",", t += Dl(r); return t + "]" }(e.arrayValue) : "mapValue" in e ? function (e) { const t = Object.keys(e.fields || {}).sort(); let n = "{", r = !0; for (const i of t) r ? r = !1 : n += ",", n += "".concat(i, ":").concat(Dl(e.fields[i])); return n + "}" }(e.mapValue) : To(); var t, n } function Al(e, t) { return { referenceValue: "projects/".concat(e.projectId, "/databases/").concat(e.database, "/documents/").concat(t.path.canonicalString()) } } function Ol(e) { return !!e && "integerValue" in e } function Rl(e) { return !!e && "arrayValue" in e } function Pl(e) { return !!e && "nullValue" in e } function Ll(e) { return !!e && "doubleValue" in e && isNaN(Number(e.doubleValue)) } function Fl(e) { return !!e && "mapValue" in e } function Ml(e) { if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) }; if (e.timestampValue && "object" == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) }; if (e.mapValue) { const t = { mapValue: { fields: {} } }; return nl(e.mapValue.fields, ((e, n) => t.mapValue.fields[e] = Ml(n))), t } if (e.arrayValue) { const t = { arrayValue: { values: [] } }; for (let n = 0; n < (e.arrayValue.values || []).length; ++n)t.arrayValue.values[n] = Ml(e.arrayValue.values[n]); return t } return Object.assign({}, e) } function jl(e) { return "__max__" === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue } function Vl(e) { return "nullValue" in e ? _l : "booleanValue" in e ? { booleanValue: !1 } : "integerValue" in e || "doubleValue" in e ? { doubleValue: NaN } : "timestampValue" in e ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "stringValue" in e ? { stringValue: "" } : "bytesValue" in e ? { bytesValue: "" } : "referenceValue" in e ? Al(El.empty(), Yo.empty()) : "geoPointValue" in e ? { geoPointValue: { latitude: -90, longitude: -180 } } : "arrayValue" in e ? { arrayValue: {} } : "mapValue" in e ? { mapValue: {} } : To() } function Bl(e) { return "nullValue" in e ? { booleanValue: !1 } : "booleanValue" in e ? { doubleValue: NaN } : "integerValue" in e || "doubleValue" in e ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "timestampValue" in e ? { stringValue: "" } : "stringValue" in e ? { bytesValue: "" } : "bytesValue" in e ? Al(El.empty(), Yo.empty()) : "referenceValue" in e ? { geoPointValue: { latitude: -90, longitude: -180 } } : "geoPointValue" in e ? { arrayValue: {} } : "arrayValue" in e ? { mapValue: {} } : "mapValue" in e ? Sl : To() } function Ul(e, t) { const n = kl(e.value, t.value); return 0 !== n ? n : e.inclusive && !t.inclusive ? -1 : !e.inclusive && t.inclusive ? 1 : 0 } function zl(e, t) { const n = kl(e.value, t.value); return 0 !== n ? n : e.inclusive && !t.inclusive ? 1 : !e.inclusive && t.inclusive ? -1 : 0 } class ql { constructor(e) { this.value = e } static empty() { return new ql({ mapValue: {} }) } field(e) { if (e.isEmpty()) return this.value; { let t = this.value; for (let n = 0; n < e.length - 1; ++n)if (t = (t.mapValue.fields || {})[e.get(n)], !Fl(t)) return null; return t = (t.mapValue.fields || {})[e.lastSegment()], t || null } } set(e, t) { this.getFieldsMap(e.popLast())[e.lastSegment()] = Ml(t) } setAll(e) { let t = Xo.emptyPath(), n = {}, r = []; e.forEach(((e, i) => { if (!t.isImmediateParentOf(i)) { const e = this.getFieldsMap(t); this.applyChanges(e, n, r), n = {}, r = [], t = i.popLast() } e ? n[i.lastSegment()] = Ml(e) : r.push(i.lastSegment()) })); const i = this.getFieldsMap(t); this.applyChanges(i, n, r) } delete(e) { const t = this.field(e.popLast()); Fl(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()] } isEqual(e) { return Il(this.value, e.value) } getFieldsMap(e) { let t = this.value; t.mapValue.fields || (t.mapValue = { fields: {} }); for (let n = 0; n < e.length; ++n) { let r = t.mapValue.fields[e.get(n)]; Fl(r) && r.mapValue.fields || (r = { mapValue: { fields: {} } }, t.mapValue.fields[e.get(n)] = r), t = r } return t.mapValue.fields } applyChanges(e, t, n) { nl(t, ((t, n) => e[t] = n)); for (const r of n) delete e[r] } clone() { return new ql(Ml(this.value)) } } function Kl(e) { const t = []; return nl(e.fields, ((e, n) => { const r = new Xo([e]); if (Fl(n)) { const e = Kl(n.mapValue).fields; if (0 === e.length) t.push(r); else for (const n of e) t.push(r.child(n)) } else t.push(r) })), new ul(t) } class Gl { constructor(e, t, n, r, i, s, o) { this.key = e, this.documentType = t, this.version = n, this.readTime = r, this.createTime = i, this.data = s, this.documentState = o } static newInvalidDocument(e) { return new Gl(e, 0, Ho.min(), Ho.min(), Ho.min(), ql.empty(), 0) } static newFoundDocument(e, t, n, r) { return new Gl(e, 1, t, Ho.min(), n, r, 0) } static newNoDocument(e, t) { return new Gl(e, 2, t, Ho.min(), Ho.min(), ql.empty(), 0) } static newUnknownDocument(e, t) { return new Gl(e, 3, t, Ho.min(), Ho.min(), ql.empty(), 2) } convertToFoundDocument(e, t) { return !this.createTime.isEqual(Ho.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this } convertToNoDocument(e) { return this.version = e, this.documentType = 2, this.data = ql.empty(), this.documentState = 0, this } convertToUnknownDocument(e) { return this.version = e, this.documentType = 3, this.data = ql.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this.version = Ho.min(), this } setReadTime(e) { return this.readTime = e, this } get hasLocalMutations() { return 1 === this.documentState } get hasCommittedMutations() { return 2 === this.documentState } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return 0 !== this.documentType } isFoundDocument() { return 1 === this.documentType } isNoDocument() { return 2 === this.documentType } isUnknownDocument() { return 3 === this.documentType } isEqual(e) { return e instanceof Gl && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data) } mutableCopy() { return new Gl(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState) } toString() { return "Document(".concat(this.key, ", ").concat(this.version, ", ").concat(JSON.stringify(this.data.value), ", {createTime: ").concat(this.createTime, "}), {documentType: ").concat(this.documentType, "}), {documentState: ").concat(this.documentState, "})") } } class Hl { constructor(e, t) { this.position = e, this.inclusive = t } } function Ql(e, t, n) { let r = 0; for (let i = 0; i < e.position.length; i++) { const s = t[i], o = e.position[i]; if (r = s.field.isKeyField() ? Yo.comparator(Yo.fromName(o.referenceValue), n.key) : kl(o, n.data.field(s.field)), "desc" === s.dir && (r *= -1), 0 !== r) break } return r } function Wl(e, t) { if (null === e) return null === t; if (null === t) return !1; if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1; for (let n = 0; n < e.position.length; n++)if (!Il(e.position[n], t.position[n])) return !1; return !0 } class $l { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc"; this.field = e, this.dir = t } } function Xl(e, t) { return e.dir === t.dir && e.field.isEqual(t.field) } class Yl { } class Jl extends Yl { constructor(e, t, n) { super(), this.field = e, this.op = t, this.value = n } static create(e, t, n) { return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, n) : new lc(e, t, n) : "array-contains" === t ? new dc(e, n) : "in" === t ? new fc(e, n) : "not-in" === t ? new pc(e, n) : "array-contains-any" === t ? new mc(e, n) : new Jl(e, t, n) } static createKeyFieldInFilter(e, t, n) { return "in" === t ? new cc(e, n) : new uc(e, n) } matches(e) { const t = e.data.field(this.field); return "!=" === this.op ? null !== t && this.matchesComparison(kl(t, this.value)) : null !== t && xl(this.value) === xl(t) && this.matchesComparison(kl(t, this.value)) } matchesComparison(e) { switch (this.op) { case "<": return e < 0; case "<=": return e <= 0; case "==": return 0 === e; case "!=": return 0 !== e; case ">": return e > 0; case ">=": return e >= 0; default: return To() } } isInequality() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } getFlattenedFilters() { return [this] } getFilters() { return [this] } getFirstInequalityField() { return this.isInequality() ? this.field : null } } class Zl extends Yl { constructor(e, t) { super(), this.filters = e, this.op = t, this.lt = null } static create(e, t) { return new Zl(e, t) } matches(e) { return ec(this) ? void 0 === this.filters.find((t => !t.matches(e))) : void 0 !== this.filters.find((t => t.matches(e))) } getFlattenedFilters() { return null !== this.lt || (this.lt = this.filters.reduce(((e, t) => e.concat(t.getFlattenedFilters())), [])), this.lt } getFilters() { return Object.assign([], this.filters) } getFirstInequalityField() { const e = this.ft((e => e.isInequality())); return null !== e ? e.field : null } ft(e) { for (const t of this.getFlattenedFilters()) if (e(t)) return t; return null } } function ec(e) { return "and" === e.op } function tc(e) { return "or" === e.op } function nc(e) { return rc(e) && ec(e) } function rc(e) { for (const t of e.filters) if (t instanceof Zl) return !1; return !0 } function ic(e) { if (e instanceof Jl) return e.field.canonicalString() + e.op.toString() + Nl(e.value); if (nc(e)) return e.filters.map((e => ic(e))).join(","); { const t = e.filters.map((e => ic(e))).join(","); return "".concat(e.op, "(").concat(t, ")") } } function sc(e, t) { return e instanceof Jl ? function (e, t) { return t instanceof Jl && e.op === t.op && e.field.isEqual(t.field) && Il(e.value, t.value) }(e, t) : e instanceof Zl ? function (e, t) { return t instanceof Zl && e.op === t.op && e.filters.length === t.filters.length && e.filters.reduce(((e, n, r) => e && sc(n, t.filters[r])), !0) }(e, t) : void To() } function oc(e, t) { const n = e.filters.concat(t); return Zl.create(n, e.op) } function ac(e) { return e instanceof Jl ? function (e) { return "".concat(e.field.canonicalString(), " ").concat(e.op, " ").concat(Nl(e.value)) }(e) : e instanceof Zl ? function (e) { return e.op.toString() + " {" + e.getFilters().map(ac).join(" ,") + "}" }(e) : "Filter" } class lc extends Jl { constructor(e, t, n) { super(e, t, n), this.key = Yo.fromName(n.referenceValue) } matches(e) { const t = Yo.comparator(e.key, this.key); return this.matchesComparison(t) } } class cc extends Jl { constructor(e, t) { super(e, "in", t), this.keys = hc("in", t) } matches(e) { return this.keys.some((t => t.isEqual(e.key))) } } class uc extends Jl { constructor(e, t) { super(e, "not-in", t), this.keys = hc("not-in", t) } matches(e) { return !this.keys.some((t => t.isEqual(e.key))) } } function hc(e, t) { var n; return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((e => Yo.fromName(e.referenceValue))) } class dc extends Jl { constructor(e, t) { super(e, "array-contains", t) } matches(e) { const t = e.data.field(this.field); return Rl(t) && Tl(t.arrayValue, this.value) } } class fc extends Jl { constructor(e, t) { super(e, "in", t) } matches(e) { const t = e.data.field(this.field); return null !== t && Tl(this.value.arrayValue, t) } } class pc extends Jl { constructor(e, t) { super(e, "not-in", t) } matches(e) { if (Tl(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const t = e.data.field(this.field); return null !== t && !Tl(this.value.arrayValue, t) } } class mc extends Jl { constructor(e, t) { super(e, "array-contains-any", t) } matches(e) { const t = e.data.field(this.field); return !(!Rl(t) || !t.arrayValue.values) && t.arrayValue.values.some((e => Tl(this.value.arrayValue, e))) } } class gc { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null; this.path = e, this.collectionGroup = t, this.orderBy = n, this.filters = r, this.limit = i, this.startAt = s, this.endAt = o, this.dt = null } } function yc(e) { return new gc(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null) } function vc(e) { const t = Co(e); if (null === t.dt) { let e = t.path.canonicalString(); null !== t.collectionGroup && (e += "|cg:" + t.collectionGroup), e += "|f:", e += t.filters.map((e => ic(e))).join(","), e += "|ob:", e += t.orderBy.map((e => function (e) { return e.field.canonicalString() + e.dir }(e))).join(","), _a(t.limit) || (e += "|l:", e += t.limit), t.startAt && (e += "|lb:", e += t.startAt.inclusive ? "b:" : "a:", e += t.startAt.position.map((e => Nl(e))).join(",")), t.endAt && (e += "|ub:", e += t.endAt.inclusive ? "a:" : "b:", e += t.endAt.position.map((e => Nl(e))).join(",")), t.dt = e } return t.dt } function wc(e, t) { if (e.limit !== t.limit) return !1; if (e.orderBy.length !== t.orderBy.length) return !1; for (let n = 0; n < e.orderBy.length; n++)if (!Xl(e.orderBy[n], t.orderBy[n])) return !1; if (e.filters.length !== t.filters.length) return !1; for (let n = 0; n < e.filters.length; n++)if (!sc(e.filters[n], t.filters[n])) return !1; return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!Wl(e.startAt, t.startAt) && Wl(e.endAt, t.endAt) } function bc(e) { return Yo.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length } function Ec(e, t) { return e.filters.filter((e => e instanceof Jl && e.field.isEqual(t))) } function Sc(e, t, n) { let r = _l, i = !0; for (const s of Ec(e, t)) { let e = _l, t = !0; switch (s.op) { case "<": case "<=": e = Vl(s.value); break; case "==": case "in": case ">=": e = s.value; break; case ">": e = s.value, t = !1; break; case "!=": case "not-in": e = _l }Ul({ value: r, inclusive: i }, { value: e, inclusive: t }) < 0 && (r = e, i = t) } if (null !== n) for (let s = 0; s < e.orderBy.length; ++s)if (e.orderBy[s].field.isEqual(t)) { const e = n.position[s]; Ul({ value: r, inclusive: i }, { value: e, inclusive: n.inclusive }) < 0 && (r = e, i = n.inclusive); break } return { value: r, inclusive: i } } function _c(e, t, n) { let r = Sl, i = !0; for (const s of Ec(e, t)) { let e = Sl, t = !0; switch (s.op) { case ">=": case ">": e = Bl(s.value), t = !1; break; case "==": case "in": case "<=": e = s.value; break; case "<": e = s.value, t = !1; break; case "!=": case "not-in": e = Sl }zl({ value: r, inclusive: i }, { value: e, inclusive: t }) > 0 && (r = e, i = t) } if (null !== n) for (let s = 0; s < e.orderBy.length; ++s)if (e.orderBy[s].field.isEqual(t)) { const e = n.position[s]; zl({ value: r, inclusive: i }, { value: e, inclusive: n.inclusive }) > 0 && (r = e, i = n.inclusive); break } return { value: r, inclusive: i } } class xc { constructor(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "F", o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; this.path = e, this.collectionGroup = t, this.explicitOrderBy = n, this.filters = r, this.limit = i, this.limitType = s, this.startAt = o, this.endAt = a, this.wt = null, this._t = null, this.startAt, this.endAt } } function Ic(e, t, n, r, i, s, o, a) { return new xc(e, t, n, r, i, s, o, a) } function Tc(e) { return new xc(e) } function kc(e) { return 0 === e.filters.length && null === e.limit && null == e.startAt && null == e.endAt && (0 === e.explicitOrderBy.length || 1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField()) } function Cc(e) { return e.explicitOrderBy.length > 0 ? e.explicitOrderBy[0].field : null } function Nc(e) { for (const t of e.filters) { const e = t.getFirstInequalityField(); if (null !== e) return e } return null } function Dc(e) { return null !== e.collectionGroup } function Ac(e) { const t = Co(e); if (null === t.wt) { t.wt = []; const e = Nc(t), n = Cc(t); if (null !== e && null === n) e.isKeyField() || t.wt.push(new $l(e)), t.wt.push(new $l(Xo.keyField(), "asc")); else { let e = !1; for (const n of t.explicitOrderBy) t.wt.push(n), n.field.isKeyField() && (e = !0); if (!e) { const e = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc"; t.wt.push(new $l(Xo.keyField(), e)) } } } return t.wt } function Oc(e) { const t = Co(e); if (!t._t) if ("F" === t.limitType) t._t = yc(t.path, t.collectionGroup, Ac(t), t.filters, t.limit, t.startAt, t.endAt); else { const e = []; for (const i of Ac(t)) { const t = "desc" === i.dir ? "asc" : "desc"; e.push(new $l(i.field, t)) } const n = t.endAt ? new Hl(t.endAt.position, t.endAt.inclusive) : null, r = t.startAt ? new Hl(t.startAt.position, t.startAt.inclusive) : null; t._t = yc(t.path, t.collectionGroup, e, t.filters, t.limit, n, r) } return t._t } function Rc(e, t) { t.getFirstInequalityField(), Nc(e); const n = e.filters.concat([t]); return new xc(e.path, e.collectionGroup, e.explicitOrderBy.slice(), n, e.limit, e.limitType, e.startAt, e.endAt) } function Pc(e, t, n) { return new xc(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt) } function Lc(e, t) { return wc(Oc(e), Oc(t)) && e.limitType === t.limitType } function Fc(e) { return "".concat(vc(Oc(e)), "|lt:").concat(e.limitType) } function Mc(e) { return "Query(target=".concat(function (e) { let t = e.path.canonicalString(); return null !== e.collectionGroup && (t += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (t += ", filters: [".concat(e.filters.map((e => ac(e))).join(", "), "]")), _a(e.limit) || (t += ", limit: " + e.limit), e.orderBy.length > 0 && (t += ", orderBy: [".concat(e.orderBy.map((e => function (e) { return "".concat(e.field.canonicalString(), " (").concat(e.dir, ")") }(e))).join(", "), "]")), e.startAt && (t += ", startAt: ", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map((e => Nl(e))).join(",")), e.endAt && (t += ", endAt: ", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map((e => Nl(e))).join(",")), "Target(".concat(t, ")") }(Oc(e)), "; limitType=").concat(e.limitType, ")") } function jc(e, t) { return t.isFoundDocument() && function (e, t) { const n = t.key.path; return null !== e.collectionGroup ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(n) : Yo.isDocumentKey(e.path) ? e.path.isEqual(n) : e.path.isImmediateParentOf(n) }(e, t) && function (e, t) { for (const n of Ac(e)) if (!n.field.isKeyField() && null === t.data.field(n.field)) return !1; return !0 }(e, t) && function (e, t) { for (const n of e.filters) if (!n.matches(t)) return !1; return !0 }(e, t) && function (e, t) { return !(e.startAt && !function (e, t, n) { const r = Ql(e, t, n); return e.inclusive ? r <= 0 : r < 0 }(e.startAt, Ac(e), t)) && !(e.endAt && !function (e, t, n) { const r = Ql(e, t, n); return e.inclusive ? r >= 0 : r > 0 }(e.endAt, Ac(e), t)) }(e, t) } function Vc(e) { return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2)) } function Bc(e) { return (t, n) => { let r = !1; for (const i of Ac(e)) { const e = Uc(i, t, n); if (0 !== e) return e; r = r || i.field.isKeyField() } return 0 } } function Uc(e, t, n) { const r = e.field.isKeyField() ? Yo.comparator(t.key, n.key) : function (e, t, n) { const r = t.data.field(e), i = n.data.field(e); return null !== r && null !== i ? kl(r, i) : To() }(e.field, t, n); switch (e.dir) { case "asc": return r; case "desc": return -1 * r; default: return To() } } class zc { constructor(e, t) { this.mapKeyFn = e, this.equalsFn = t, this.inner = {}, this.innerSize = 0 } get(e) { const t = this.mapKeyFn(e), n = this.inner[t]; if (void 0 !== n) for (const [r, i] of n) if (this.equalsFn(r, e)) return i } has(e) { return void 0 !== this.get(e) } set(e, t) { const n = this.mapKeyFn(e), r = this.inner[n]; if (void 0 === r) return this.inner[n] = [[e, t]], void this.innerSize++; for (let i = 0; i < r.length; i++)if (this.equalsFn(r[i][0], e)) return void (r[i] = [e, t]); r.push([e, t]), this.innerSize++ } delete(e) { const t = this.mapKeyFn(e), n = this.inner[t]; if (void 0 === n) return !1; for (let r = 0; r < n.length; r++)if (this.equalsFn(n[r][0], e)) return 1 === n.length ? delete this.inner[t] : n.splice(r, 1), this.innerSize--, !0; return !1 } forEach(e) { nl(this.inner, ((t, n) => { for (const [r, i] of n) e(r, i) })) } isEmpty() { return rl(this.inner) } size() { return this.innerSize } } const qc = new il(Yo.comparator); function Kc() { return qc } const Gc = new il(Yo.comparator); function Hc() { let e = Gc; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; for (const i of n) e = e.insert(i.key, i); return e } function Qc(e) { let t = Gc; return e.forEach(((e, n) => t = t.insert(e, n.overlayedDocument))), t } function Wc() { return Xc() } function $c() { return Xc() } function Xc() { return new zc((e => e.toString()), ((e, t) => e.isEqual(t))) } const Yc = new il(Yo.comparator), Jc = new al(Yo.comparator); function Zc() { let e = Jc; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; for (const i of n) e = e.add(i); return e } const eu = new al(zo); function tu() { return eu } function nu(e, t) { if (e.useProto3Json) { if (isNaN(t)) return { doubleValue: "NaN" }; if (t === 1 / 0) return { doubleValue: "Infinity" }; if (t === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: xa(t) ? "-0" : t } } function ru(e) { return { integerValue: "" + e } } function iu(e, t) { return Ia(t) ? ru(t) : nu(e, t) } class su { constructor() { this._ = void 0 } } function ou(e, t, n) { return e instanceof cu ? function (e, t) { const n = { fields: { __type__: { stringValue: "server_timestamp" }, __local_write_time__: { timestampValue: { seconds: e.seconds, nanos: e.nanoseconds } } } }; return t && yl(t) && (t = vl(t)), t && (n.fields.__previous_value__ = t), { mapValue: n } }(n, t) : e instanceof uu ? hu(e, t) : e instanceof du ? fu(e, t) : function (e, t) { const n = lu(e, t), r = mu(n) + mu(e.gt); return Ol(n) && Ol(e.gt) ? ru(r) : nu(e.serializer, r) }(e, t) } function au(e, t, n) { return e instanceof uu ? hu(e, t) : e instanceof du ? fu(e, t) : n } function lu(e, t) { return e instanceof pu ? Ol(n = t) || function (e) { return !!e && "doubleValue" in e }(n) ? t : { integerValue: 0 } : null; var n } class cu extends su { } class uu extends su { constructor(e) { super(), this.elements = e } } function hu(e, t) { const n = gu(t); for (const r of e.elements) n.some((e => Il(e, r))) || n.push(r); return { arrayValue: { values: n } } } class du extends su { constructor(e) { super(), this.elements = e } } function fu(e, t) { let n = gu(t); for (const r of e.elements) n = n.filter((e => !Il(e, r))); return { arrayValue: { values: n } } } class pu extends su { constructor(e, t) { super(), this.serializer = e, this.gt = t } } function mu(e) { return ml(e.integerValue || e.doubleValue) } function gu(e) { return Rl(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [] } class yu { constructor(e, t) { this.field = e, this.transform = t } } class vu { constructor(e, t) { this.version = e, this.transformResults = t } } class wu { constructor(e, t) { this.updateTime = e, this.exists = t } static none() { return new wu } static exists(e) { return new wu(void 0, e) } static updateTime(e) { return new wu(e) } get isNone() { return void 0 === this.updateTime && void 0 === this.exists } isEqual(e) { return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime) } } function bu(e, t) { return void 0 !== e.updateTime ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : void 0 === e.exists || e.exists === t.isFoundDocument() } class Eu { } function Su(e, t) { if (!e.hasLocalMutations || t && 0 === t.fields.length) return null; if (null === t) return e.isNoDocument() ? new Ou(e.key, wu.none()) : new ku(e.key, e.data, wu.none()); { const n = e.data, r = ql.empty(); let i = new al(Xo.comparator); for (let e of t.fields) if (!i.has(e)) { let t = n.field(e); null === t && e.length > 1 && (e = e.popLast(), t = n.field(e)), null === t ? r.delete(e) : r.set(e, t), i = i.add(e) } return new Cu(e.key, r, new ul(i.toArray()), wu.none()) } } function _u(e, t, n) { e instanceof ku ? function (e, t, n) { const r = e.value.clone(), i = Du(e.fieldTransforms, t, n.transformResults); r.setAll(i), t.convertToFoundDocument(n.version, r).setHasCommittedMutations() }(e, t, n) : e instanceof Cu ? function (e, t, n) { if (!bu(e.precondition, t)) return void t.convertToUnknownDocument(n.version); const r = Du(e.fieldTransforms, t, n.transformResults), i = t.data; i.setAll(Nu(e)), i.setAll(r), t.convertToFoundDocument(n.version, i).setHasCommittedMutations() }(e, t, n) : function (e, t, n) { t.convertToNoDocument(n.version).setHasCommittedMutations() }(0, t, n) } function xu(e, t, n, r) { return e instanceof ku ? function (e, t, n, r) { if (!bu(e.precondition, t)) return n; const i = e.value.clone(), s = Au(e.fieldTransforms, r, t); return i.setAll(s), t.convertToFoundDocument(t.version, i).setHasLocalMutations(), null }(e, t, n, r) : e instanceof Cu ? function (e, t, n, r) { if (!bu(e.precondition, t)) return n; const i = Au(e.fieldTransforms, r, t), s = t.data; return s.setAll(Nu(e)), s.setAll(i), t.convertToFoundDocument(t.version, s).setHasLocalMutations(), null === n ? null : n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map((e => e.field))) }(e, t, n, r) : function (e, t, n) { return bu(e.precondition, t) ? (t.convertToNoDocument(t.version).setHasLocalMutations(), null) : n }(e, t, n) } function Iu(e, t) { let n = null; for (const r of e.fieldTransforms) { const e = t.data.field(r.field), i = lu(r.transform, e || null); null != i && (null === n && (n = ql.empty()), n.set(r.field, i)) } return n || null } function Tu(e, t) { return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && !!function (e, t) { return void 0 === e && void 0 === t || !(!e || !t) && qo(e, t, ((e, t) => function (e, t) { return e.field.isEqual(t.field) && function (e, t) { return e instanceof uu && t instanceof uu || e instanceof du && t instanceof du ? qo(e.elements, t.elements, Il) : e instanceof pu && t instanceof pu ? Il(e.gt, t.gt) : e instanceof cu && t instanceof cu }(e.transform, t.transform) }(e, t))) }(e.fieldTransforms, t.fieldTransforms) && (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)) } class ku extends Eu { constructor(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : []; super(), this.key = e, this.value = t, this.precondition = n, this.fieldTransforms = r, this.type = 0 } getFieldMask() { return null } } class Cu extends Eu { constructor(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : []; super(), this.key = e, this.data = t, this.fieldMask = n, this.precondition = r, this.fieldTransforms = i, this.type = 1 } getFieldMask() { return this.fieldMask } } function Nu(e) { const t = new Map; return e.fieldMask.fields.forEach((n => { if (!n.isEmpty()) { const r = e.data.field(n); t.set(n, r) } })), t } function Du(e, t, n) { const r = new Map; ko(e.length === n.length); for (let i = 0; i < n.length; i++) { const s = e[i], o = s.transform, a = t.data.field(s.field); r.set(s.field, au(o, a, n[i])) } return r } function Au(e, t, n) { const r = new Map; for (const i of e) { const e = i.transform, s = n.data.field(i.field); r.set(i.field, ou(e, s, t)) } return r } class Ou extends Eu { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [] } getFieldMask() { return null } } class Ru extends Eu { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [] } getFieldMask() { return null } } class Pu { constructor(e, t, n, r) { this.batchId = e, this.localWriteTime = t, this.baseMutations = n, this.mutations = r } applyToRemoteDocument(e, t) { const n = t.mutationResults; for (let r = 0; r < this.mutations.length; r++) { const t = this.mutations[r]; t.key.isEqual(e.key) && _u(t, e, n[r]) } } applyToLocalView(e, t) { for (const n of this.baseMutations) n.key.isEqual(e.key) && (t = xu(n, e, t, this.localWriteTime)); for (const n of this.mutations) n.key.isEqual(e.key) && (t = xu(n, e, t, this.localWriteTime)); return t } applyToLocalDocumentSet(e, t) { const n = $c(); return this.mutations.forEach((r => { const i = e.get(r.key), s = i.overlayedDocument; let o = this.applyToLocalView(s, i.mutatedFields); o = t.has(r.key) ? null : o; const a = Su(s, o); null !== a && n.set(r.key, a), s.isValidDocument() || s.convertToNoDocument(Ho.min()) })), n } keys() { return this.mutations.reduce(((e, t) => e.add(t.key)), Zc()) } isEqual(e) { return this.batchId === e.batchId && qo(this.mutations, e.mutations, ((e, t) => Tu(e, t))) && qo(this.baseMutations, e.baseMutations, ((e, t) => Tu(e, t))) } } class Lu { constructor(e, t, n, r) { this.batch = e, this.commitVersion = t, this.mutationResults = n, this.docVersions = r } static from(e, t, n) { ko(e.mutations.length === n.length); let r = Yc; const i = e.mutations; for (let s = 0; s < i.length; s++)r = r.insert(i[s].key, n[s].version); return new Lu(e, t, n, r) } } class Fu { constructor(e, t) { this.largestBatchId = e, this.mutation = t } getKey() { return this.mutation.key } isEqual(e) { return null !== e && this.mutation === e.mutation } toString() { return "Overlay{\n      largestBatchId: ".concat(this.largestBatchId, ",\n      mutation: ").concat(this.mutation.toString(), "\n    }") } } class Mu { constructor(e, t) { this.count = e, this.unchangedNames = t } } var ju, Vu; function Bu(e) { switch (e) { default: return To(); case No.CANCELLED: case No.UNKNOWN: case No.DEADLINE_EXCEEDED: case No.RESOURCE_EXHAUSTED: case No.INTERNAL: case No.UNAVAILABLE: case No.UNAUTHENTICATED: return !1; case No.INVALID_ARGUMENT: case No.NOT_FOUND: case No.ALREADY_EXISTS: case No.PERMISSION_DENIED: case No.FAILED_PRECONDITION: case No.ABORTED: case No.OUT_OF_RANGE: case No.UNIMPLEMENTED: case No.DATA_LOSS: return !0 } } function Uu(e) { if (void 0 === e) return _o("GRPC error has no .code"), No.UNKNOWN; switch (e) { case ju.OK: return No.OK; case ju.CANCELLED: return No.CANCELLED; case ju.UNKNOWN: return No.UNKNOWN; case ju.DEADLINE_EXCEEDED: return No.DEADLINE_EXCEEDED; case ju.RESOURCE_EXHAUSTED: return No.RESOURCE_EXHAUSTED; case ju.INTERNAL: return No.INTERNAL; case ju.UNAVAILABLE: return No.UNAVAILABLE; case ju.UNAUTHENTICATED: return No.UNAUTHENTICATED; case ju.INVALID_ARGUMENT: return No.INVALID_ARGUMENT; case ju.NOT_FOUND: return No.NOT_FOUND; case ju.ALREADY_EXISTS: return No.ALREADY_EXISTS; case ju.PERMISSION_DENIED: return No.PERMISSION_DENIED; case ju.FAILED_PRECONDITION: return No.FAILED_PRECONDITION; case ju.ABORTED: return No.ABORTED; case ju.OUT_OF_RANGE: return No.OUT_OF_RANGE; case ju.UNIMPLEMENTED: return No.UNIMPLEMENTED; case ju.DATA_LOSS: return No.DATA_LOSS; default: return To() } } (Vu = ju || (ju = {}))[Vu.OK = 0] = "OK", Vu[Vu.CANCELLED = 1] = "CANCELLED", Vu[Vu.UNKNOWN = 2] = "UNKNOWN", Vu[Vu.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Vu[Vu.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Vu[Vu.NOT_FOUND = 5] = "NOT_FOUND", Vu[Vu.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Vu[Vu.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Vu[Vu.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Vu[Vu.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Vu[Vu.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Vu[Vu.ABORTED = 10] = "ABORTED", Vu[Vu.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Vu[Vu.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Vu[Vu.INTERNAL = 13] = "INTERNAL", Vu[Vu.UNAVAILABLE = 14] = "UNAVAILABLE", Vu[Vu.DATA_LOSS = 15] = "DATA_LOSS"; class zu { constructor() { this.onExistenceFilterMismatchCallbacks = new Map } static get instance() { return qu } static getOrCreateInstance() { return null === qu && (qu = new zu), qu } onExistenceFilterMismatch(e) { const t = Symbol(); return this.onExistenceFilterMismatchCallbacks.set(t, e), () => this.onExistenceFilterMismatchCallbacks.delete(t) } notifyOnExistenceFilterMismatch(e) { this.onExistenceFilterMismatchCallbacks.forEach((t => t(e))) } } let qu = null; function Ku() { return new TextEncoder } const Gu = new go([4294967295, 4294967295], 0); function Hu(e) { const t = Ku().encode(e), n = new mo; return n.update(t), new Uint8Array(n.digest()) } function Qu(e) { const t = new DataView(e.buffer), n = t.getUint32(0, !0), r = t.getUint32(4, !0), i = t.getUint32(8, !0), s = t.getUint32(12, !0); return [new go([n, r], 0), new go([i, s], 0)] } class Wu { constructor(e, t, n) { if (this.bitmap = e, this.padding = t, this.hashCount = n, t < 0 || t >= 8) throw new $u("Invalid padding: ".concat(t)); if (n < 0) throw new $u("Invalid hash count: ".concat(n)); if (e.length > 0 && 0 === this.hashCount) throw new $u("Invalid hash count: ".concat(n)); if (0 === e.length && 0 !== t) throw new $u("Invalid padding when bitmap length is 0: ".concat(t)); this.It = 8 * e.length - t, this.Tt = go.fromNumber(this.It) } Et(e, t, n) { let r = e.add(t.multiply(go.fromNumber(n))); return 1 === r.compare(Gu) && (r = new go([r.getBits(0), r.getBits(1)], 0)), r.modulo(this.Tt).toNumber() } At(e) { return 0 != (this.bitmap[Math.floor(e / 8)] & 1 << e % 8) } vt(e) { if (0 === this.It) return !1; const t = Hu(e), [n, r] = Qu(t); for (let i = 0; i < this.hashCount; i++) { const e = this.Et(n, r, i); if (!this.At(e)) return !1 } return !0 } static create(e, t, n) { const r = e % 8 == 0 ? 0 : 8 - e % 8, i = new Uint8Array(Math.ceil(e / 8)), s = new Wu(i, r, t); return n.forEach((e => s.insert(e))), s } insert(e) { if (0 === this.It) return; const t = Hu(e), [n, r] = Qu(t); for (let i = 0; i < this.hashCount; i++) { const e = this.Et(n, r, i); this.Rt(e) } } Rt(e) { const t = Math.floor(e / 8), n = e % 8; this.bitmap[t] |= 1 << n } } class $u extends Error { constructor() { super(...arguments), this.name = "BloomFilterError" } } class Xu { constructor(e, t, n, r, i) { this.snapshotVersion = e, this.targetChanges = t, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i } static createSynthesizedRemoteEventForCurrentChange(e, t, n) { const r = new Map; return r.set(e, Yu.createSynthesizedTargetChangeForCurrentChange(e, t, n)), new Xu(Ho.min(), r, new il(zo), Kc(), Zc()) } } class Yu { constructor(e, t, n, r, i) { this.resumeToken = e, this.current = t, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i } static createSynthesizedTargetChangeForCurrentChange(e, t, n) { return new Yu(n, t, Zc(), Zc(), Zc()) } } class Ju { constructor(e, t, n, r) { this.Pt = e, this.removedTargetIds = t, this.key = n, this.bt = r } } class Zu { constructor(e, t) { this.targetId = e, this.Vt = t } } class eh { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : dl.EMPTY_BYTE_STRING, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; this.state = e, this.targetIds = t, this.resumeToken = n, this.cause = r } } class th { constructor() { this.St = 0, this.Dt = ih(), this.Ct = dl.EMPTY_BYTE_STRING, this.xt = !1, this.Nt = !0 } get current() { return this.xt } get resumeToken() { return this.Ct } get kt() { return 0 !== this.St } get Mt() { return this.Nt } $t(e) { e.approximateByteSize() > 0 && (this.Nt = !0, this.Ct = e) } Ot() { let e = Zc(), t = Zc(), n = Zc(); return this.Dt.forEach(((r, i) => { switch (i) { case 0: e = e.add(r); break; case 2: t = t.add(r); break; case 1: n = n.add(r); break; default: To() } })), new Yu(this.Ct, this.xt, e, t, n) } Ft() { this.Nt = !1, this.Dt = ih() } Bt(e, t) { this.Nt = !0, this.Dt = this.Dt.insert(e, t) } Lt(e) { this.Nt = !0, this.Dt = this.Dt.remove(e) } qt() { this.St += 1 } Ut() { this.St -= 1 } Kt() { this.Nt = !0, this.xt = !0 } } class nh { constructor(e) { this.Gt = e, this.Qt = new Map, this.jt = Kc(), this.zt = rh(), this.Wt = new il(zo) } Ht(e) { for (const t of e.Pt) e.bt && e.bt.isFoundDocument() ? this.Jt(t, e.bt) : this.Yt(t, e.key, e.bt); for (const t of e.removedTargetIds) this.Yt(t, e.key, e.bt) } Xt(e) { this.forEachTarget(e, (t => { const n = this.Zt(t); switch (e.state) { case 0: this.te(t) && n.$t(e.resumeToken); break; case 1: n.Ut(), n.kt || n.Ft(), n.$t(e.resumeToken); break; case 2: n.Ut(), n.kt || this.removeTarget(t); break; case 3: this.te(t) && (n.Kt(), n.$t(e.resumeToken)); break; case 4: this.te(t) && (this.ee(t), n.$t(e.resumeToken)); break; default: To() } })) } forEachTarget(e, t) { e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.Qt.forEach(((e, n) => { this.te(n) && t(n) })) } ne(e) { var t; const n = e.targetId, r = e.Vt.count, i = this.se(n); if (i) { const s = i.target; if (bc(s)) if (0 === r) { const e = new Yo(s.path); this.Yt(n, e, Gl.newNoDocument(e, Ho.min())) } else ko(1 === r); else { const i = this.ie(n); if (i !== r) { const r = this.re(e, i); if (0 !== r) { this.ee(n); const e = 2 === r ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch"; this.Wt = this.Wt.insert(n, e) } null === (t = zu.instance) || void 0 === t || t.notifyOnExistenceFilterMismatch(function (e, t, n) { var r, i, s, o, a, l; const c = { localCacheCount: t, existenceFilterCount: n.count }, u = n.unchangedNames; return u && (c.bloomFilter = { applied: 0 === e, hashCount: null !== (r = null == u ? void 0 : u.hashCount) && void 0 !== r ? r : 0, bitmapLength: null !== (o = null === (s = null === (i = null == u ? void 0 : u.bits) || void 0 === i ? void 0 : i.bitmap) || void 0 === s ? void 0 : s.length) && void 0 !== o ? o : 0, padding: null !== (l = null === (a = null == u ? void 0 : u.bits) || void 0 === a ? void 0 : a.padding) && void 0 !== l ? l : 0 }), c }(r, i, e.Vt)) } } } } re(e, t) { const { unchangedNames: n, count: r } = e.Vt; if (!n || !n.bits) return 1; const { bits: { bitmap: i = "", padding: s = 0 }, hashCount: o = 0 } = n; let a, l; try { a = gl(i).toUint8Array() } catch (e) { if (e instanceof hl) return xo("Decoding the base64 bloom filter in existence filter failed (" + e.message + "); ignoring the bloom filter and falling back to full re-query."), 1; throw e } try { l = new Wu(a, s, o) } catch (e) { return xo(e instanceof $u ? "BloomFilter error: " : "Applying bloom filter failed: ", e), 1 } return 0 === l.It ? 1 : r !== t - this.oe(e.targetId, l) ? 2 : 0 } oe(e, t) { const n = this.Gt.getRemoteKeysForTarget(e); let r = 0; return n.forEach((n => { const i = this.Gt.ue(), s = "projects/".concat(i.projectId, "/databases/").concat(i.database, "/documents/").concat(n.path.canonicalString()); t.vt(s) || (this.Yt(e, n, null), r++) })), r } ce(e) { const t = new Map; this.Qt.forEach(((n, r) => { const i = this.se(r); if (i) { if (n.current && bc(i.target)) { const t = new Yo(i.target.path); null !== this.jt.get(t) || this.ae(r, t) || this.Yt(r, t, Gl.newNoDocument(t, e)) } n.Mt && (t.set(r, n.Ot()), n.Ft()) } })); let n = Zc(); this.zt.forEach(((e, t) => { let r = !0; t.forEachWhile((e => { const t = this.se(e); return !t || "TargetPurposeLimboResolution" === t.purpose || (r = !1, !1) })), r && (n = n.add(e)) })), this.jt.forEach(((t, n) => n.setReadTime(e))); const r = new Xu(e, t, this.Wt, this.jt, n); return this.jt = Kc(), this.zt = rh(), this.Wt = new il(zo), r } Jt(e, t) { if (!this.te(e)) return; const n = this.ae(e, t.key) ? 2 : 0; this.Zt(e).Bt(t.key, n), this.jt = this.jt.insert(t.key, t), this.zt = this.zt.insert(t.key, this.he(t.key).add(e)) } Yt(e, t, n) { if (!this.te(e)) return; const r = this.Zt(e); this.ae(e, t) ? r.Bt(t, 1) : r.Lt(t), this.zt = this.zt.insert(t, this.he(t).delete(e)), n && (this.jt = this.jt.insert(t, n)) } removeTarget(e) { this.Qt.delete(e) } ie(e) { const t = this.Zt(e).Ot(); return this.Gt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size } qt(e) { this.Zt(e).qt() } Zt(e) { let t = this.Qt.get(e); return t || (t = new th, this.Qt.set(e, t)), t } he(e) { let t = this.zt.get(e); return t || (t = new al(zo), this.zt = this.zt.insert(e, t)), t } te(e) { const t = null !== this.se(e); return t || So("WatchChangeAggregator", "Detected inactive target", e), t } se(e) { const t = this.Qt.get(e); return t && t.kt ? null : this.Gt.le(e) } ee(e) { this.Qt.set(e, new th), this.Gt.getRemoteKeysForTarget(e).forEach((t => { this.Yt(e, t, null) })) } ae(e, t) { return this.Gt.getRemoteKeysForTarget(e).has(t) } } function rh() { return new il(Yo.comparator) } function ih() { return new il(Yo.comparator) } const sh = { asc: "ASCENDING", desc: "DESCENDING" }, oh = { "<": "LESS_THAN", "<=": "LESS_THAN_OR_EQUAL", ">": "GREATER_THAN", ">=": "GREATER_THAN_OR_EQUAL", "==": "EQUAL", "!=": "NOT_EQUAL", "array-contains": "ARRAY_CONTAINS", in: "IN", "not-in": "NOT_IN", "array-contains-any": "ARRAY_CONTAINS_ANY" }, ah = { and: "AND", or: "OR" }; class lh { constructor(e, t) { this.databaseId = e, this.useProto3Json = t } } function ch(e, t) { return e.useProto3Json || _a(t) ? t : { value: t } } function uh(e, t) { return e.useProto3Json ? "".concat(new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", ""), ".").concat(("000000000" + t.nanoseconds).slice(-9), "Z") : { seconds: "" + t.seconds, nanos: t.nanoseconds } } function hh(e, t) { return e.useProto3Json ? t.toBase64() : t.toUint8Array() } function dh(e, t) { return uh(e, t.toTimestamp()) } function fh(e) { return ko(!!e), Ho.fromTimestamp(function (e) { const t = pl(e); return new Go(t.seconds, t.nanos) }(e)) } function ph(e, t) { return function (e) { return new Wo(["projects", e.projectId, "databases", e.database]) }(e).child("documents").child(t).canonicalString() } function mh(e) { const t = Wo.fromString(e); return ko(Mh(t)), t } function gh(e, t) { return ph(e.databaseId, t.path) } function yh(e, t) { const n = mh(t); if (n.get(1) !== e.databaseId.projectId) throw new Do(No.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId); if (n.get(3) !== e.databaseId.database) throw new Do(No.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database); return new Yo(Eh(n)) } function vh(e, t) { return ph(e.databaseId, t) } function wh(e) { const t = mh(e); return 4 === t.length ? Wo.emptyPath() : Eh(t) } function bh(e) { return new Wo(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString() } function Eh(e) { return ko(e.length > 4 && "documents" === e.get(4)), e.popFirst(5) } function Sh(e, t, n) { return { name: gh(e, t), fields: n.value.mapValue.fields } } function _h(e, t, n) { const r = yh(e, t.name), i = fh(t.updateTime), s = t.createTime ? fh(t.createTime) : Ho.min(), o = new ql({ mapValue: { fields: t.fields } }), a = Gl.newFoundDocument(r, i, s, o); return n && a.setHasCommittedMutations(), n ? a.setHasCommittedMutations() : a } function xh(e, t) { let n; if (t instanceof ku) n = { update: Sh(e, t.key, t.value) }; else if (t instanceof Ou) n = { delete: gh(e, t.key) }; else if (t instanceof Cu) n = { update: Sh(e, t.key, t.data), updateMask: Fh(t.fieldMask) }; else { if (!(t instanceof Ru)) return To(); n = { verify: gh(e, t.key) } } return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map((e => function (e, t) { const n = t.transform; if (n instanceof cu) return { fieldPath: t.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (n instanceof uu) return { fieldPath: t.field.canonicalString(), appendMissingElements: { values: n.elements } }; if (n instanceof du) return { fieldPath: t.field.canonicalString(), removeAllFromArray: { values: n.elements } }; if (n instanceof pu) return { fieldPath: t.field.canonicalString(), increment: n.gt }; throw To() }(0, e)))), t.precondition.isNone || (n.currentDocument = function (e, t) { return void 0 !== t.updateTime ? { updateTime: dh(e, t.updateTime) } : void 0 !== t.exists ? { exists: t.exists } : To() }(e, t.precondition)), n } function Ih(e, t) { const n = t.currentDocument ? function (e) { return void 0 !== e.updateTime ? wu.updateTime(fh(e.updateTime)) : void 0 !== e.exists ? wu.exists(e.exists) : wu.none() }(t.currentDocument) : wu.none(), r = t.updateTransforms ? t.updateTransforms.map((t => function (e, t) { let n = null; if ("setToServerValue" in t) ko("REQUEST_TIME" === t.setToServerValue), n = new cu; else if ("appendMissingElements" in t) { const e = t.appendMissingElements.values || []; n = new uu(e) } else if ("removeAllFromArray" in t) { const e = t.removeAllFromArray.values || []; n = new du(e) } else "increment" in t ? n = new pu(e, t.increment) : To(); const r = Xo.fromServerFormat(t.fieldPath); return new yu(r, n) }(e, t))) : []; if (t.update) { t.update.name; const i = yh(e, t.update.name), s = new ql({ mapValue: { fields: t.update.fields } }); if (t.updateMask) { const e = function (e) { const t = e.fieldPaths || []; return new ul(t.map((e => Xo.fromServerFormat(e)))) }(t.updateMask); return new Cu(i, s, e, n, r) } return new ku(i, s, n, r) } if (t.delete) { const r = yh(e, t.delete); return new Ou(r, n) } if (t.verify) { const r = yh(e, t.verify); return new Ru(r, n) } return To() } function Th(e, t) { return { documents: [vh(e, t.path)] } } function kh(e, t) { const n = { structuredQuery: {} }, r = t.path; null !== t.collectionGroup ? (n.parent = vh(e, r), n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]) : (n.parent = vh(e, r.popLast()), n.structuredQuery.from = [{ collectionId: r.lastSegment() }]); const i = function (e) { if (0 !== e.length) return Lh(Zl.create(e, "and")) }(t.filters); i && (n.structuredQuery.where = i); const s = function (e) { if (0 !== e.length) return e.map((e => function (e) { return { field: Rh(e.field), direction: Dh(e.dir) } }(e))) }(t.orderBy); s && (n.structuredQuery.orderBy = s); const o = ch(e, t.limit); var a; return null !== o && (n.structuredQuery.limit = o), t.startAt && (n.structuredQuery.startAt = { before: (a = t.startAt).inclusive, values: a.position }), t.endAt && (n.structuredQuery.endAt = function (e) { return { before: !e.inclusive, values: e.position } }(t.endAt)), n } function Ch(e) { let t = wh(e.parent); const n = e.structuredQuery, r = n.from ? n.from.length : 0; let i = null; if (r > 0) { ko(1 === r); const e = n.from[0]; e.allDescendants ? i = e.collectionId : t = t.child(e.collectionId) } let s = []; n.where && (s = function (e) { const t = Nh(e); return t instanceof Zl && nc(t) ? t.getFilters() : [t] }(n.where)); let o = []; n.orderBy && (o = n.orderBy.map((e => function (e) { return new $l(Ph(e.field), function (e) { switch (e) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } }(e.direction)) }(e)))); let a = null; n.limit && (a = function (e) { let t; return t = "object" == typeof e ? e.value : e, _a(t) ? null : t }(n.limit)); let l = null; n.startAt && (l = function (e) { const t = !!e.before, n = e.values || []; return new Hl(n, t) }(n.startAt)); let c = null; return n.endAt && (c = function (e) { const t = !e.before, n = e.values || []; return new Hl(n, t) }(n.endAt)), Ic(t, i, o, s, a, "F", l, c) } function Nh(e) { return void 0 !== e.unaryFilter ? function (e) { switch (e.unaryFilter.op) { case "IS_NAN": const t = Ph(e.unaryFilter.field); return Jl.create(t, "==", { doubleValue: NaN }); case "IS_NULL": const n = Ph(e.unaryFilter.field); return Jl.create(n, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const r = Ph(e.unaryFilter.field); return Jl.create(r, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const i = Ph(e.unaryFilter.field); return Jl.create(i, "!=", { nullValue: "NULL_VALUE" }); default: return To() } }(e) : void 0 !== e.fieldFilter ? function (e) { return Jl.create(Ph(e.fieldFilter.field), function (e) { switch (e) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; default: return To() } }(e.fieldFilter.op), e.fieldFilter.value) }(e) : void 0 !== e.compositeFilter ? function (e) { return Zl.create(e.compositeFilter.filters.map((e => Nh(e))), function (e) { switch (e) { case "AND": return "and"; case "OR": return "or"; default: return To() } }(e.compositeFilter.op)) }(e) : To() } function Dh(e) { return sh[e] } function Ah(e) { return oh[e] } function Oh(e) { return ah[e] } function Rh(e) { return { fieldPath: e.canonicalString() } } function Ph(e) { return Xo.fromServerFormat(e.fieldPath) } function Lh(e) { return e instanceof Jl ? function (e) { if ("==" === e.op) { if (Ll(e.value)) return { unaryFilter: { field: Rh(e.field), op: "IS_NAN" } }; if (Pl(e.value)) return { unaryFilter: { field: Rh(e.field), op: "IS_NULL" } } } else if ("!=" === e.op) { if (Ll(e.value)) return { unaryFilter: { field: Rh(e.field), op: "IS_NOT_NAN" } }; if (Pl(e.value)) return { unaryFilter: { field: Rh(e.field), op: "IS_NOT_NULL" } } } return { fieldFilter: { field: Rh(e.field), op: Ah(e.op), value: e.value } } }(e) : e instanceof Zl ? function (e) { const t = e.getFilters().map((e => Lh(e))); return 1 === t.length ? t[0] : { compositeFilter: { op: Oh(e.op), filters: t } } }(e) : To() } function Fh(e) { const t = []; return e.fields.forEach((e => t.push(e.canonicalString()))), { fieldPaths: t } } function Mh(e) { return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2) } class jh { constructor(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ho.min(), s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : Ho.min(), o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : dl.EMPTY_BYTE_STRING, a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null; this.target = e, this.targetId = t, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = s, this.resumeToken = o, this.expectedCount = a } withSequenceNumber(e) { return new jh(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount) } withResumeToken(e, t) { return new jh(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null) } withExpectedCount(e) { return new jh(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e) } withLastLimboFreeSnapshotVersion(e) { return new jh(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount) } } class Vh { constructor(e) { this.fe = e } } function Bh(e, t) { const n = t.key, r = { prefixPath: n.getCollectionPath().popLast().toArray(), collectionGroup: n.collectionGroup, documentId: n.path.lastSegment(), readTime: Uh(t.readTime), hasCommittedMutations: t.hasCommittedMutations }; if (t.isFoundDocument()) r.document = function (e, t) { return { name: gh(e, t.key), fields: t.data.value.mapValue.fields, updateTime: uh(e, t.version.toTimestamp()), createTime: uh(e, t.createTime.toTimestamp()) } }(e.fe, t); else if (t.isNoDocument()) r.noDocument = { path: n.path.toArray(), readTime: zh(t.version) }; else { if (!t.isUnknownDocument()) return To(); r.unknownDocument = { path: n.path.toArray(), version: zh(t.version) } } return r } function Uh(e) { const t = e.toTimestamp(); return [t.seconds, t.nanoseconds] } function zh(e) { const t = e.toTimestamp(); return { seconds: t.seconds, nanoseconds: t.nanoseconds } } function qh(e) { const t = new Go(e.seconds, e.nanoseconds); return Ho.fromTimestamp(t) } function Kh(e, t) { const n = (t.baseMutations || []).map((t => Ih(e.fe, t))); for (let s = 0; s < t.mutations.length - 1; ++s) { const e = t.mutations[s]; if (s + 1 < t.mutations.length && void 0 !== t.mutations[s + 1].transform) { const n = t.mutations[s + 1]; e.updateTransforms = n.transform.fieldTransforms, t.mutations.splice(s + 1, 1), ++s } } const r = t.mutations.map((t => Ih(e.fe, t))), i = Go.fromMillis(t.localWriteTimeMs); return new Pu(t.batchId, i, n, r) } function Gh(e) { const t = qh(e.readTime), n = void 0 !== e.lastLimboFreeSnapshotVersion ? qh(e.lastLimboFreeSnapshotVersion) : Ho.min(); let r; var i; return void 0 !== e.query.documents ? (ko(1 === (i = e.query).documents.length), r = Oc(Tc(wh(i.documents[0])))) : r = function (e) { return Oc(Ch(e)) }(e.query), new jh(r, e.targetId, "TargetPurposeListen", e.lastListenSequenceNumber, t, n, dl.fromBase64String(e.resumeToken)) } function Hh(e, t) { const n = zh(t.snapshotVersion), r = zh(t.lastLimboFreeSnapshotVersion); let i; i = bc(t.target) ? Th(e.fe, t.target) : kh(e.fe, t.target); const s = t.resumeToken.toBase64(); return { targetId: t.targetId, canonicalId: vc(t.target), readTime: n, resumeToken: s, lastListenSequenceNumber: t.sequenceNumber, lastLimboFreeSnapshotVersion: r, query: i } } function Qh(e) { const t = Ch({ parent: e.parent, structuredQuery: e.structuredQuery }); return "LAST" === e.limitType ? Pc(t, t.limit, "L") : t } function Wh(e, t) { return new Fu(t.largestBatchId, Ih(e.fe, t.overlayMutation)) } function $h(e, t) { const n = t.path.lastSegment(); return [e, Ta(t.path.popLast()), n] } function Xh(e, t, n, r) { return { indexId: e, uid: t.uid || "", sequenceNumber: n, readTime: zh(r.readTime), documentKey: Ta(r.documentKey.path), largestBatchId: r.largestBatchId } } class Yh { getBundleMetadata(e, t) { return Jh(e).get(t).next((e => { if (e) return { id: (t = e).bundleId, createTime: qh(t.createTime), version: t.version }; var t })) } saveBundleMetadata(e, t) { return Jh(e).put({ bundleId: (n = t).id, createTime: zh(fh(n.createTime)), version: n.version }); var n } getNamedQuery(e, t) { return Zh(e).get(t).next((e => { if (e) return { name: (t = e).name, query: Qh(t.bundledQuery), readTime: qh(t.readTime) }; var t })) } saveNamedQuery(e, t) { return Zh(e).put(function (e) { return { name: e.name, readTime: zh(fh(e.readTime)), bundledQuery: e.bundledQuery } }(t)) } } function Jh(e) { return el(e, "bundles") } function Zh(e) { return el(e, "namedQueries") } class ed { constructor(e, t) { this.serializer = e, this.userId = t } static de(e, t) { const n = t.uid || ""; return new ed(e, n) } getOverlay(e, t) { return td(e).get($h(this.userId, t)).next((e => e ? Wh(this.serializer, e) : null)) } getOverlays(e, t) { const n = Wc(); return ua.forEach(t, (t => this.getOverlay(e, t).next((e => { null !== e && n.set(t, e) })))).next((() => n)) } saveOverlays(e, t, n) { const r = []; return n.forEach(((n, i) => { const s = new Fu(t, i); r.push(this.we(e, s)) })), ua.waitFor(r) } removeOverlaysForBatchId(e, t, n) { const r = new Set; t.forEach((e => r.add(Ta(e.getCollectionPath())))); const i = []; return r.forEach((t => { const r = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, n + 1], !1, !0); i.push(td(e).J("collectionPathOverlayIndex", r)) })), ua.waitFor(i) } getOverlaysForCollection(e, t, n) { const r = Wc(), i = Ta(t), s = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], !0); return td(e).j("collectionPathOverlayIndex", s).next((e => { for (const t of e) { const e = Wh(this.serializer, t); r.set(e.getKey(), e) } return r })) } getOverlaysForCollectionGroup(e, t, n, r) { const i = Wc(); let s; const o = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, Number.POSITIVE_INFINITY], !0); return td(e).X({ index: "collectionGroupOverlayIndex", range: o }, ((e, t, n) => { const o = Wh(this.serializer, t); i.size() < r || o.largestBatchId === s ? (i.set(o.getKey(), o), s = o.largestBatchId) : n.done() })).next((() => i)) } we(e, t) { return td(e).put(function (e, t, n) { const [r, i, s] = $h(t, n.mutation.key); return { userId: t, collectionPath: i, documentId: s, collectionGroup: n.mutation.key.getCollectionGroup(), largestBatchId: n.largestBatchId, overlayMutation: xh(e.fe, n.mutation) } }(this.serializer, this.userId, t)) } } function td(e) { return el(e, "documentOverlays") } class nd { constructor() { } _e(e, t) { this.me(e, t), t.ge() } me(e, t) { if ("nullValue" in e) this.ye(t, 5); else if ("booleanValue" in e) this.ye(t, 10), t.pe(e.booleanValue ? 1 : 0); else if ("integerValue" in e) this.ye(t, 15), t.pe(ml(e.integerValue)); else if ("doubleValue" in e) { const n = ml(e.doubleValue); isNaN(n) ? this.ye(t, 13) : (this.ye(t, 15), xa(n) ? t.pe(0) : t.pe(n)) } else if ("timestampValue" in e) { const n = e.timestampValue; this.ye(t, 20), "string" == typeof n ? t.Ie(n) : (t.Ie("".concat(n.seconds || "")), t.pe(n.nanos || 0)) } else if ("stringValue" in e) this.Te(e.stringValue, t), this.Ee(t); else if ("bytesValue" in e) this.ye(t, 30), t.Ae(gl(e.bytesValue)), this.Ee(t); else if ("referenceValue" in e) this.ve(e.referenceValue, t); else if ("geoPointValue" in e) { const n = e.geoPointValue; this.ye(t, 45), t.pe(n.latitude || 0), t.pe(n.longitude || 0) } else "mapValue" in e ? jl(e) ? this.ye(t, Number.MAX_SAFE_INTEGER) : (this.Re(e.mapValue, t), this.Ee(t)) : "arrayValue" in e ? (this.Pe(e.arrayValue, t), this.Ee(t)) : To() } Te(e, t) { this.ye(t, 25), this.be(e, t) } be(e, t) { t.Ie(e) } Re(e, t) { const n = e.fields || {}; this.ye(t, 55); for (const r of Object.keys(n)) this.Te(r, t), this.me(n[r], t) } Pe(e, t) { const n = e.values || []; this.ye(t, 50); for (const r of n) this.me(r, t) } ve(e, t) { this.ye(t, 37), Yo.fromName(e).path.forEach((e => { this.ye(t, 60), this.be(e, t) })) } ye(e, t) { e.pe(t) } Ee(e) { e.pe(2) } } function rd(e) { if (0 === e) return 8; let t = 0; return e >> 4 == 0 && (t += 4, e <<= 4), e >> 6 == 0 && (t += 2, e <<= 2), e >> 7 == 0 && (t += 1), t } function id(e) { const t = 64 - function (e) { let t = 0; for (let n = 0; n < 8; ++n) { const r = rd(255 & e[n]); if (t += r, 8 !== r) break } return t }(e); return Math.ceil(t / 8) } nd.Ve = new nd; class sd { constructor() { this.buffer = new Uint8Array(1024), this.position = 0 } Se(e) { const t = e[Symbol.iterator](); let n = t.next(); for (; !n.done;)this.De(n.value), n = t.next(); this.Ce() } xe(e) { const t = e[Symbol.iterator](); let n = t.next(); for (; !n.done;)this.Ne(n.value), n = t.next(); this.ke() } Me(e) { for (const t of e) { const e = t.charCodeAt(0); if (e < 128) this.De(e); else if (e < 2048) this.De(960 | e >>> 6), this.De(128 | 63 & e); else if (t < "\ud800" || "\udbff" < t) this.De(480 | e >>> 12), this.De(128 | 63 & e >>> 6), this.De(128 | 63 & e); else { const e = t.codePointAt(0); this.De(240 | e >>> 18), this.De(128 | 63 & e >>> 12), this.De(128 | 63 & e >>> 6), this.De(128 | 63 & e) } } this.Ce() } $e(e) { for (const t of e) { const e = t.charCodeAt(0); if (e < 128) this.Ne(e); else if (e < 2048) this.Ne(960 | e >>> 6), this.Ne(128 | 63 & e); else if (t < "\ud800" || "\udbff" < t) this.Ne(480 | e >>> 12), this.Ne(128 | 63 & e >>> 6), this.Ne(128 | 63 & e); else { const e = t.codePointAt(0); this.Ne(240 | e >>> 18), this.Ne(128 | 63 & e >>> 12), this.Ne(128 | 63 & e >>> 6), this.Ne(128 | 63 & e) } } this.ke() } Oe(e) { const t = this.Fe(e), n = id(t); this.Be(1 + n), this.buffer[this.position++] = 255 & n; for (let r = t.length - n; r < t.length; ++r)this.buffer[this.position++] = 255 & t[r] } Le(e) { const t = this.Fe(e), n = id(t); this.Be(1 + n), this.buffer[this.position++] = ~(255 & n); for (let r = t.length - n; r < t.length; ++r)this.buffer[this.position++] = ~(255 & t[r]) } qe() { this.Ue(255), this.Ue(255) } Ke() { this.Ge(255), this.Ge(255) } reset() { this.position = 0 } seed(e) { this.Be(e.length), this.buffer.set(e, this.position), this.position += e.length } Qe() { return this.buffer.slice(0, this.position) } Fe(e) { const t = function (e) { const t = new DataView(new ArrayBuffer(8)); return t.setFloat64(0, e, !1), new Uint8Array(t.buffer) }(e), n = 0 != (128 & t[0]); t[0] ^= n ? 255 : 128; for (let r = 1; r < t.length; ++r)t[r] ^= n ? 255 : 0; return t } De(e) { const t = 255 & e; 0 === t ? (this.Ue(0), this.Ue(255)) : 255 === t ? (this.Ue(255), this.Ue(0)) : this.Ue(t) } Ne(e) { const t = 255 & e; 0 === t ? (this.Ge(0), this.Ge(255)) : 255 === t ? (this.Ge(255), this.Ge(0)) : this.Ge(e) } Ce() { this.Ue(0), this.Ue(1) } ke() { this.Ge(0), this.Ge(1) } Ue(e) { this.Be(1), this.buffer[this.position++] = e } Ge(e) { this.Be(1), this.buffer[this.position++] = ~e } Be(e) { const t = e + this.position; if (t <= this.buffer.length) return; let n = 2 * this.buffer.length; n < t && (n = t); const r = new Uint8Array(n); r.set(this.buffer), this.buffer = r } } class od { constructor(e) { this.je = e } Ae(e) { this.je.Se(e) } Ie(e) { this.je.Me(e) } pe(e) { this.je.Oe(e) } ge() { this.je.qe() } } class ad { constructor(e) { this.je = e } Ae(e) { this.je.xe(e) } Ie(e) { this.je.$e(e) } pe(e) { this.je.Le(e) } ge() { this.je.Ke() } } class ld { constructor() { this.je = new sd, this.ze = new od(this.je), this.We = new ad(this.je) } seed(e) { this.je.seed(e) } He(e) { return 0 === e ? this.ze : this.We } Qe() { return this.je.Qe() } reset() { this.je.reset() } } class cd { constructor(e, t, n, r) { this.indexId = e, this.documentKey = t, this.arrayValue = n, this.directionalValue = r } Je() { const e = this.directionalValue.length, t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e, n = new Uint8Array(t); return n.set(this.directionalValue, 0), t !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new cd(this.indexId, this.documentKey, this.arrayValue, n) } } function ud(e, t) { let n = e.indexId - t.indexId; return 0 !== n ? n : (n = hd(e.arrayValue, t.arrayValue), 0 !== n ? n : (n = hd(e.directionalValue, t.directionalValue), 0 !== n ? n : Yo.comparator(e.documentKey, t.documentKey))) } function hd(e, t) { for (let n = 0; n < e.length && n < t.length; ++n) { const r = e[n] - t[n]; if (0 !== r) return r } return e.length - t.length } class dd { constructor(e) { this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment(), this.Ye = e.orderBy, this.Xe = []; for (const t of e.filters) { const e = t; e.isInequality() ? this.Ze = e : this.Xe.push(e) } } tn(e) { ko(e.collectionGroup === this.collectionId); const t = Zo(e); if (void 0 !== t && !this.en(t)) return !1; const n = ea(e); let r = new Set, i = 0, s = 0; for (; i < n.length && this.en(n[i]); ++i)r = r.add(n[i].fieldPath.canonicalString()); if (i === n.length) return !0; if (void 0 !== this.Ze) { if (!r.has(this.Ze.field.canonicalString())) { const e = n[i]; if (!this.nn(this.Ze, e) || !this.sn(this.Ye[s++], e)) return !1 } ++i } for (; i < n.length; ++i) { const e = n[i]; if (s >= this.Ye.length || !this.sn(this.Ye[s++], e)) return !1 } return !0 } en(e) { for (const t of this.Xe) if (this.nn(t, e)) return !0; return !1 } nn(e, t) { if (void 0 === e || !e.field.isEqual(t.fieldPath)) return !1; const n = "array-contains" === e.op || "array-contains-any" === e.op; return 2 === t.kind === n } sn(e, t) { return !!e.field.isEqual(t.fieldPath) && (0 === t.kind && "asc" === e.dir || 1 === t.kind && "desc" === e.dir) } } function fd(e) { var t, n; if (ko(e instanceof Jl || e instanceof Zl), e instanceof Jl) { if (e instanceof fc) { const r = (null === (n = null === (t = e.value.arrayValue) || void 0 === t ? void 0 : t.values) || void 0 === n ? void 0 : n.map((t => Jl.create(e.field, "==", t)))) || []; return Zl.create(r, "or") } return e } const r = e.filters.map((e => fd(e))); return Zl.create(r, e.op) } function pd(e) { if (0 === e.getFilters().length) return []; const t = vd(fd(e)); return ko(yd(t)), md(t) || gd(t) ? [t] : t.getFilters() } function md(e) { return e instanceof Jl } function gd(e) { return e instanceof Zl && nc(e) } function yd(e) { return md(e) || gd(e) || function (e) { if (e instanceof Zl && tc(e)) { for (const t of e.getFilters()) if (!md(t) && !gd(t)) return !1; return !0 } return !1 }(e) } function vd(e) { if (ko(e instanceof Jl || e instanceof Zl), e instanceof Jl) return e; if (1 === e.filters.length) return vd(e.filters[0]); const t = e.filters.map((e => vd(e))); let n = Zl.create(t, e.op); return n = Ed(n), yd(n) ? n : (ko(n instanceof Zl), ko(ec(n)), ko(n.filters.length > 1), n.filters.reduce(((e, t) => wd(e, t)))) } function wd(e, t) { let n; return ko(e instanceof Jl || e instanceof Zl), ko(t instanceof Jl || t instanceof Zl), n = e instanceof Jl ? t instanceof Jl ? function (e, t) { return Zl.create([e, t], "and") }(e, t) : bd(e, t) : t instanceof Jl ? bd(t, e) : function (e, t) { if (ko(e.filters.length > 0 && t.filters.length > 0), ec(e) && ec(t)) return oc(e, t.getFilters()); const n = tc(e) ? e : t, r = tc(e) ? t : e, i = n.filters.map((e => wd(e, r))); return Zl.create(i, "or") }(e, t), Ed(n) } function bd(e, t) { if (ec(t)) return oc(t, e.getFilters()); { const n = t.filters.map((t => wd(e, t))); return Zl.create(n, "or") } } function Ed(e) { if (ko(e instanceof Jl || e instanceof Zl), e instanceof Jl) return e; const t = e.getFilters(); if (1 === t.length) return Ed(t[0]); if (rc(e)) return e; const n = t.map((e => Ed(e))), r = []; return n.forEach((t => { t instanceof Jl ? r.push(t) : t instanceof Zl && (t.op === e.op ? r.push(...t.filters) : r.push(t)) })), 1 === r.length ? r[0] : Zl.create(r, e.op) } class Sd { constructor() { this.rn = new _d } addToCollectionParentIndex(e, t) { return this.rn.add(t), ua.resolve() } getCollectionParents(e, t) { return ua.resolve(this.rn.getEntries(t)) } addFieldIndex(e, t) { return ua.resolve() } deleteFieldIndex(e, t) { return ua.resolve() } getDocumentsMatchingTarget(e, t) { return ua.resolve(null) } getIndexType(e, t) { return ua.resolve(0) } getFieldIndexes(e, t) { return ua.resolve([]) } getNextCollectionGroupToUpdate(e) { return ua.resolve(null) } getMinOffset(e, t) { return ua.resolve(sa.min()) } getMinOffsetFromCollectionGroup(e, t) { return ua.resolve(sa.min()) } updateCollectionGroup(e, t, n) { return ua.resolve() } updateIndexEntries(e, t) { return ua.resolve() } } class _d { constructor() { this.index = {} } add(e) { const t = e.lastSegment(), n = e.popLast(), r = this.index[t] || new al(Wo.comparator), i = !r.has(n); return this.index[t] = r.add(n), i } has(e) { const t = e.lastSegment(), n = e.popLast(), r = this.index[t]; return r && r.has(n) } getEntries(e) { return (this.index[e] || new al(Wo.comparator)).toArray() } } const xd = new Uint8Array(0); class Id { constructor(e, t) { this.user = e, this.databaseId = t, this.on = new _d, this.un = new zc((e => vc(e)), ((e, t) => wc(e, t))), this.uid = e.uid || "" } addToCollectionParentIndex(e, t) { if (!this.on.has(t)) { const n = t.lastSegment(), r = t.popLast(); e.addOnCommittedListener((() => { this.on.add(t) })); const i = { collectionId: n, parent: Ta(r) }; return Td(e).put(i) } return ua.resolve() } getCollectionParents(e, t) { const n = [], r = IDBKeyRange.bound([t, ""], [Ko(t), ""], !1, !0); return Td(e).j(r).next((e => { for (const r of e) { if (r.collectionId !== t) break; n.push(Na(r.parent)) } return n })) } addFieldIndex(e, t) { const n = Cd(e), r = function (e) { return { indexId: e.indexId, collectionGroup: e.collectionGroup, fields: e.fields.map((e => [e.fieldPath.canonicalString(), e.kind])) } }(t); delete r.indexId; const i = n.add(r); if (t.indexState) { const n = Nd(e); return i.next((e => { n.put(Xh(e, this.user, t.indexState.sequenceNumber, t.indexState.offset)) })) } return i.next() } deleteFieldIndex(e, t) { const n = Cd(e), r = Nd(e), i = kd(e); return n.delete(t.indexId).next((() => r.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))).next((() => i.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0)))) } getDocumentsMatchingTarget(e, t) { const n = kd(e); let r = !0; const i = new Map; return ua.forEach(this.cn(t), (t => this.an(e, t).next((e => { r && (r = !!e), i.set(t, e) })))).next((() => { if (r) { let e = Zc(); const r = []; return ua.forEach(i, ((i, s) => { var o; So("IndexedDbIndexManager", "Using index ".concat((o = i, "id=".concat(o.indexId, "|cg=").concat(o.collectionGroup, "|f=").concat(o.fields.map((e => "".concat(e.fieldPath, ":").concat(e.kind))).join(","))), " to execute ").concat(vc(t))); const a = function (e, t) { const n = Zo(t); if (void 0 === n) return null; for (const r of Ec(e, n.fieldPath)) switch (r.op) { case "array-contains-any": return r.value.arrayValue.values || []; case "array-contains": return [r.value] }return null }(s, i), l = function (e, t) { const n = new Map; for (const r of ea(t)) for (const t of Ec(e, r.fieldPath)) switch (t.op) { case "==": case "in": n.set(r.fieldPath.canonicalString(), t.value); break; case "not-in": case "!=": return n.set(r.fieldPath.canonicalString(), t.value), Array.from(n.values()) }return null }(s, i), c = function (e, t) { const n = []; let r = !0; for (const i of ea(t)) { const t = 0 === i.kind ? Sc(e, i.fieldPath, e.startAt) : _c(e, i.fieldPath, e.startAt); n.push(t.value), r && (r = t.inclusive) } return new Hl(n, r) }(s, i), u = function (e, t) { const n = []; let r = !0; for (const i of ea(t)) { const t = 0 === i.kind ? _c(e, i.fieldPath, e.endAt) : Sc(e, i.fieldPath, e.endAt); n.push(t.value), r && (r = t.inclusive) } return new Hl(n, r) }(s, i), h = this.hn(i, s, c), d = this.hn(i, s, u), f = this.ln(i, s, l), p = this.fn(i.indexId, a, h, c.inclusive, d, u.inclusive, f); return ua.forEach(p, (i => n.H(i, t.limit).next((t => { t.forEach((t => { const n = Yo.fromSegments(t.documentKey); e.has(n) || (e = e.add(n), r.push(n)) })) })))) })).next((() => r)) } return ua.resolve(null) })) } cn(e) { let t = this.un.get(e); return t || (t = 0 === e.filters.length ? [e] : pd(Zl.create(e.filters, "and")).map((t => yc(e.path, e.collectionGroup, e.orderBy, t.getFilters(), e.limit, e.startAt, e.endAt))), this.un.set(e, t), t) } fn(e, t, n, r, i, s, o) { const a = (null != t ? t.length : 1) * Math.max(n.length, i.length), l = a / (null != t ? t.length : 1), c = []; for (let u = 0; u < a; ++u) { const a = t ? this.dn(t[u / l]) : xd, h = this.wn(e, a, n[u % l], r), d = this._n(e, a, i[u % l], s), f = o.map((t => this.wn(e, a, t, !0))); c.push(...this.createRange(h, d, f)) } return c } wn(e, t, n, r) { const i = new cd(e, Yo.empty(), t, n); return r ? i : i.Je() } _n(e, t, n, r) { const i = new cd(e, Yo.empty(), t, n); return r ? i.Je() : i } an(e, t) { const n = new dd(t), r = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment(); return this.getFieldIndexes(e, r).next((e => { let t = null; for (const r of e) n.tn(r) && (!t || r.fields.length > t.fields.length) && (t = r); return t })) } getIndexType(e, t) { let n = 2; const r = this.cn(t); return ua.forEach(r, (t => this.an(e, t).next((e => { e ? 0 !== n && e.fields.length < function (e) { let t = new al(Xo.comparator), n = !1; for (const r of e.filters) for (const e of r.getFlattenedFilters()) e.field.isKeyField() || ("array-contains" === e.op || "array-contains-any" === e.op ? n = !0 : t = t.add(e.field)); for (const r of e.orderBy) r.field.isKeyField() || (t = t.add(r.field)); return t.size + (n ? 1 : 0) }(t) && (n = 1) : n = 0 })))).next((() => function (e) { return null !== e.limit }(t) && r.length > 1 && 2 === n ? 1 : n)) } mn(e, t) { const n = new ld; for (const r of ea(e)) { const e = t.data.field(r.fieldPath); if (null == e) return null; const i = n.He(r.kind); nd.Ve._e(e, i) } return n.Qe() } dn(e) { const t = new ld; return nd.Ve._e(e, t.He(0)), t.Qe() } gn(e, t) { const n = new ld; return nd.Ve._e(Al(this.databaseId, t), n.He(function (e) { const t = ea(e); return 0 === t.length ? 0 : t[t.length - 1].kind }(e))), n.Qe() } ln(e, t, n) { if (null === n) return []; let r = []; r.push(new ld); let i = 0; for (const s of ea(e)) { const e = n[i++]; for (const n of r) if (this.yn(t, s.fieldPath) && Rl(e)) r = this.pn(r, s, e); else { const t = n.He(s.kind); nd.Ve._e(e, t) } } return this.In(r) } hn(e, t, n) { return this.ln(e, t, n.position) } In(e) { const t = []; for (let n = 0; n < e.length; ++n)t[n] = e[n].Qe(); return t } pn(e, t, n) { const r = [...e], i = []; for (const s of n.arrayValue.values || []) for (const e of r) { const n = new ld; n.seed(e.Qe()), nd.Ve._e(s, n.He(t.kind)), i.push(n) } return i } yn(e, t) { return !!e.filters.find((e => e instanceof Jl && e.field.isEqual(t) && ("in" === e.op || "not-in" === e.op))) } getFieldIndexes(e, t) { const n = Cd(e), r = Nd(e); return (t ? n.j("collectionGroupIndex", IDBKeyRange.bound(t, t)) : n.j()).next((e => { const t = []; return ua.forEach(e, (e => r.get([e.indexId, this.uid]).next((n => { t.push(function (e, t) { const n = t ? new na(t.sequenceNumber, new sa(qh(t.readTime), new Yo(Na(t.documentKey)), t.largestBatchId)) : na.empty(), r = e.fields.map((e => { let [t, n] = e; return new ta(Xo.fromServerFormat(t), n) })); return new Jo(e.indexId, e.collectionGroup, r, n) }(e, n)) })))).next((() => t)) })) } getNextCollectionGroupToUpdate(e) { return this.getFieldIndexes(e).next((e => 0 === e.length ? null : (e.sort(((e, t) => { const n = e.indexState.sequenceNumber - t.indexState.sequenceNumber; return 0 !== n ? n : zo(e.collectionGroup, t.collectionGroup) })), e[0].collectionGroup))) } updateCollectionGroup(e, t, n) { const r = Cd(e), i = Nd(e); return this.Tn(e).next((e => r.j("collectionGroupIndex", IDBKeyRange.bound(t, t)).next((t => ua.forEach(t, (t => i.put(Xh(t.indexId, this.user, e, n)))))))) } updateIndexEntries(e, t) { const n = new Map; return ua.forEach(t, ((t, r) => { const i = n.get(t.collectionGroup); return (i ? ua.resolve(i) : this.getFieldIndexes(e, t.collectionGroup)).next((i => (n.set(t.collectionGroup, i), ua.forEach(i, (n => this.En(e, t, n).next((t => { const i = this.An(r, n); return t.isEqual(i) ? ua.resolve() : this.vn(e, r, n, t, i) }))))))) })) } Rn(e, t, n, r) { return kd(e).put({ indexId: r.indexId, uid: this.uid, arrayValue: r.arrayValue, directionalValue: r.directionalValue, orderedDocumentKey: this.gn(n, t.key), documentKey: t.key.path.toArray() }) } Pn(e, t, n, r) { return kd(e).delete([r.indexId, this.uid, r.arrayValue, r.directionalValue, this.gn(n, t.key), t.key.path.toArray()]) } En(e, t, n) { const r = kd(e); let i = new al(ud); return r.X({ index: "documentKeyIndex", range: IDBKeyRange.only([n.indexId, this.uid, this.gn(n, t)]) }, ((e, r) => { i = i.add(new cd(n.indexId, t, r.arrayValue, r.directionalValue)) })).next((() => i)) } An(e, t) { let n = new al(ud); const r = this.mn(t, e); if (null == r) return n; const i = Zo(t); if (null != i) { const s = e.data.field(i.fieldPath); if (Rl(s)) for (const i of s.arrayValue.values || []) n = n.add(new cd(t.indexId, e.key, this.dn(i), r)) } else n = n.add(new cd(t.indexId, e.key, xd, r)); return n } vn(e, t, n, r, i) { So("IndexedDbIndexManager", "Updating index entries for document '%s'", t.key); const s = []; return function (e, t, n, r, i) { const s = e.getIterator(), o = t.getIterator(); let a = cl(s), l = cl(o); for (; a || l;) { let e = !1, t = !1; if (a && l) { const r = n(a, l); r < 0 ? t = !0 : r > 0 && (e = !0) } else null != a ? t = !0 : e = !0; e ? (r(l), l = cl(o)) : t ? (i(a), a = cl(s)) : (a = cl(s), l = cl(o)) } }(r, i, ud, (r => { s.push(this.Rn(e, t, n, r)) }), (r => { s.push(this.Pn(e, t, n, r)) })), ua.waitFor(s) } Tn(e) { let t = 1; return Nd(e).X({ index: "sequenceNumberIndex", reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, ((e, n, r) => { r.done(), t = n.sequenceNumber + 1 })).next((() => t)) } createRange(e, t, n) { n = n.sort(((e, t) => ud(e, t))).filter(((e, t, n) => !t || 0 !== ud(e, n[t - 1]))); const r = []; r.push(e); for (const s of n) { const n = ud(s, e), i = ud(s, t); if (0 === n) r[0] = e.Je(); else if (n > 0 && i < 0) r.push(s), r.push(s.Je()); else if (i > 0) break } r.push(t); const i = []; for (let s = 0; s < r.length; s += 2) { if (this.bn(r[s], r[s + 1])) return []; const e = [r[s].indexId, this.uid, r[s].arrayValue, r[s].directionalValue, xd, []], t = [r[s + 1].indexId, this.uid, r[s + 1].arrayValue, r[s + 1].directionalValue, xd, []]; i.push(IDBKeyRange.bound(e, t)) } return i } bn(e, t) { return ud(e, t) > 0 } getMinOffsetFromCollectionGroup(e, t) { return this.getFieldIndexes(e, t).next(Dd) } getMinOffset(e, t) { return ua.mapArray(this.cn(t), (t => this.an(e, t).next((e => e || To())))).next(Dd) } } function Td(e) { return el(e, "collectionParents") } function kd(e) { return el(e, "indexEntries") } function Cd(e) { return el(e, "indexConfiguration") } function Nd(e) { return el(e, "indexState") } function Dd(e) { ko(0 !== e.length); let t = e[0].indexState.offset, n = t.largestBatchId; for (let r = 1; r < e.length; r++) { const i = e[r].indexState.offset; oa(i, t) < 0 && (t = i), n < i.largestBatchId && (n = i.largestBatchId) } return new sa(t.readTime, t.documentKey, n) } const Ad = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 }; class Od { constructor(e, t, n) { this.cacheSizeCollectionThreshold = e, this.percentileToCollect = t, this.maximumSequenceNumbersToCollect = n } static withCacheSize(e) { return new Od(e, Od.DEFAULT_COLLECTION_PERCENTILE, Od.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT) } } function Rd(e, t, n) { const r = e.store("mutations"), i = e.store("documentMutations"), s = [], o = IDBKeyRange.only(n.batchId); let a = 0; const l = r.X({ range: o }, ((e, t, n) => (a++, n.delete()))); s.push(l.next((() => { ko(1 === a) }))); const c = []; for (const u of n.mutations) { const e = Oa(t, u.key.path, n.batchId); s.push(i.delete(e)), c.push(u.key) } return ua.waitFor(s).next((() => c)) } function Pd(e) { if (!e) return 0; let t; if (e.document) t = e.document; else if (e.unknownDocument) t = e.unknownDocument; else { if (!e.noDocument) throw To(); t = e.noDocument } return JSON.stringify(t).length } Od.DEFAULT_COLLECTION_PERCENTILE = 10, Od.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Od.DEFAULT = new Od(41943040, Od.DEFAULT_COLLECTION_PERCENTILE, Od.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Od.DISABLED = new Od(-1, 0, 0); class Ld { constructor(e, t, n, r) { this.userId = e, this.serializer = t, this.indexManager = n, this.referenceDelegate = r, this.Vn = {} } static de(e, t, n, r) { ko("" !== e.uid); const i = e.isAuthenticated() ? e.uid : ""; return new Ld(i, t, n, r) } checkEmpty(e) { let t = !0; const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]); return Md(e).X({ index: "userMutationsIndex", range: n }, ((e, n, r) => { t = !1, r.done() })).next((() => t)) } addMutationBatch(e, t, n, r) { const i = jd(e), s = Md(e); return s.add({}).next((o => { ko("number" == typeof o); const a = new Pu(o, t, n, r), l = function (e, t, n) { const r = n.baseMutations.map((t => xh(e.fe, t))), i = n.mutations.map((t => xh(e.fe, t))); return { userId: t, batchId: n.batchId, localWriteTimeMs: n.localWriteTime.toMillis(), baseMutations: r, mutations: i } }(this.serializer, this.userId, a), c = []; let u = new al(((e, t) => zo(e.canonicalString(), t.canonicalString()))); for (const e of r) { const t = Oa(this.userId, e.key.path, o); u = u.add(e.key.path.popLast()), c.push(s.put(l)), c.push(i.put(t, Ra)) } return u.forEach((t => { c.push(this.indexManager.addToCollectionParentIndex(e, t)) })), e.addOnCommittedListener((() => { this.Vn[o] = a.keys() })), ua.waitFor(c).next((() => a)) })) } lookupMutationBatch(e, t) { return Md(e).get(t).next((e => e ? (ko(e.userId === this.userId), Kh(this.serializer, e)) : null)) } Sn(e, t) { return this.Vn[t] ? ua.resolve(this.Vn[t]) : this.lookupMutationBatch(e, t).next((e => { if (e) { const n = e.keys(); return this.Vn[t] = n, n } return null })) } getNextMutationBatchAfterBatchId(e, t) { const n = t + 1, r = IDBKeyRange.lowerBound([this.userId, n]); let i = null; return Md(e).X({ index: "userMutationsIndex", range: r }, ((e, t, r) => { t.userId === this.userId && (ko(t.batchId >= n), i = Kh(this.serializer, t)), r.done() })).next((() => i)) } getHighestUnacknowledgedBatchId(e) { const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]); let n = -1; return Md(e).X({ index: "userMutationsIndex", range: t, reverse: !0 }, ((e, t, r) => { n = t.batchId, r.done() })).next((() => n)) } getAllMutationBatches(e) { const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]); return Md(e).j("userMutationsIndex", t).next((e => e.map((e => Kh(this.serializer, e))))) } getAllMutationBatchesAffectingDocumentKey(e, t) { const n = Aa(this.userId, t.path), r = IDBKeyRange.lowerBound(n), i = []; return jd(e).X({ range: r }, ((n, r, s) => { const [o, a, l] = n, c = Na(a); if (o === this.userId && t.path.isEqual(c)) return Md(e).get(l).next((e => { if (!e) throw To(); ko(e.userId === this.userId), i.push(Kh(this.serializer, e)) })); s.done() })).next((() => i)) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let n = new al(zo); const r = []; return t.forEach((t => { const i = Aa(this.userId, t.path), s = IDBKeyRange.lowerBound(i), o = jd(e).X({ range: s }, ((e, r, i) => { const [s, o, a] = e, l = Na(o); s === this.userId && t.path.isEqual(l) ? n = n.add(a) : i.done() })); r.push(o) })), ua.waitFor(r).next((() => this.Dn(e, n))) } getAllMutationBatchesAffectingQuery(e, t) { const n = t.path, r = n.length + 1, i = Aa(this.userId, n), s = IDBKeyRange.lowerBound(i); let o = new al(zo); return jd(e).X({ range: s }, ((e, t, i) => { const [s, a, l] = e, c = Na(a); s === this.userId && n.isPrefixOf(c) ? c.length === r && (o = o.add(l)) : i.done() })).next((() => this.Dn(e, o))) } Dn(e, t) { const n = [], r = []; return t.forEach((t => { r.push(Md(e).get(t).next((e => { if (null === e) throw To(); ko(e.userId === this.userId), n.push(Kh(this.serializer, e)) }))) })), ua.waitFor(r).next((() => n)) } removeMutationBatch(e, t) { return Rd(e.ht, this.userId, t).next((n => (e.addOnCommittedListener((() => { this.Cn(t.batchId) })), ua.forEach(n, (t => this.referenceDelegate.markPotentiallyOrphaned(e, t)))))) } Cn(e) { delete this.Vn[e] } performConsistencyCheck(e) { return this.checkEmpty(e).next((t => { if (!t) return ua.resolve(); const n = IDBKeyRange.lowerBound([this.userId]), r = []; return jd(e).X({ range: n }, ((e, t, n) => { if (e[0] === this.userId) { const t = Na(e[1]); r.push(t) } else n.done() })).next((() => { ko(0 === r.length) })) })) } containsKey(e, t) { return Fd(e, this.userId, t) } xn(e) { return Vd(e).get(this.userId).next((e => e || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: "" })) } } function Fd(e, t, n) { const r = Aa(t, n.path), i = r[1], s = IDBKeyRange.lowerBound(r); let o = !1; return jd(e).X({ range: s, Y: !0 }, ((e, n, r) => { const [s, a, l] = e; s === t && a === i && (o = !0), r.done() })).next((() => o)) } function Md(e) { return el(e, "mutations") } function jd(e) { return el(e, "documentMutations") } function Vd(e) { return el(e, "mutationQueues") } class Bd { constructor(e) { this.Nn = e } next() { return this.Nn += 2, this.Nn } static kn() { return new Bd(0) } static Mn() { return new Bd(-1) } } class Ud { constructor(e, t) { this.referenceDelegate = e, this.serializer = t } allocateTargetId(e) { return this.$n(e).next((t => { const n = new Bd(t.highestTargetId); return t.highestTargetId = n.next(), this.On(e, t).next((() => t.highestTargetId)) })) } getLastRemoteSnapshotVersion(e) { return this.$n(e).next((e => Ho.fromTimestamp(new Go(e.lastRemoteSnapshotVersion.seconds, e.lastRemoteSnapshotVersion.nanoseconds)))) } getHighestSequenceNumber(e) { return this.$n(e).next((e => e.highestListenSequenceNumber)) } setTargetsMetadata(e, t, n) { return this.$n(e).next((r => (r.highestListenSequenceNumber = t, n && (r.lastRemoteSnapshotVersion = n.toTimestamp()), t > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = t), this.On(e, r)))) } addTargetData(e, t) { return this.Fn(e, t).next((() => this.$n(e).next((n => (n.targetCount += 1, this.Bn(t, n), this.On(e, n)))))) } updateTargetData(e, t) { return this.Fn(e, t) } removeTargetData(e, t) { return this.removeMatchingKeysForTargetId(e, t.targetId).next((() => zd(e).delete(t.targetId))).next((() => this.$n(e))).next((t => (ko(t.targetCount > 0), t.targetCount -= 1, this.On(e, t)))) } removeTargets(e, t, n) { let r = 0; const i = []; return zd(e).X(((s, o) => { const a = Gh(o); a.sequenceNumber <= t && null === n.get(a.targetId) && (r++, i.push(this.removeTargetData(e, a))) })).next((() => ua.waitFor(i))).next((() => r)) } forEachTarget(e, t) { return zd(e).X(((e, n) => { const r = Gh(n); t(r) })) } $n(e) { return qd(e).get("targetGlobalKey").next((e => (ko(null !== e), e))) } On(e, t) { return qd(e).put("targetGlobalKey", t) } Fn(e, t) { return zd(e).put(Hh(this.serializer, t)) } Bn(e, t) { let n = !1; return e.targetId > t.highestTargetId && (t.highestTargetId = e.targetId, n = !0), e.sequenceNumber > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = e.sequenceNumber, n = !0), n } getTargetCount(e) { return this.$n(e).next((e => e.targetCount)) } getTargetData(e, t) { const n = vc(t), r = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]); let i = null; return zd(e).X({ range: r, index: "queryTargetsIndex" }, ((e, n, r) => { const s = Gh(n); wc(t, s.target) && (i = s, r.done()) })).next((() => i)) } addMatchingKeys(e, t, n) { const r = [], i = Kd(e); return t.forEach((t => { const s = Ta(t.path); r.push(i.put({ targetId: n, path: s })), r.push(this.referenceDelegate.addReference(e, n, t)) })), ua.waitFor(r) } removeMatchingKeys(e, t, n) { const r = Kd(e); return ua.forEach(t, (t => { const i = Ta(t.path); return ua.waitFor([r.delete([n, i]), this.referenceDelegate.removeReference(e, n, t)]) })) } removeMatchingKeysForTargetId(e, t) { const n = Kd(e), r = IDBKeyRange.bound([t], [t + 1], !1, !0); return n.delete(r) } getMatchingKeysForTargetId(e, t) { const n = IDBKeyRange.bound([t], [t + 1], !1, !0), r = Kd(e); let i = Zc(); return r.X({ range: n, Y: !0 }, ((e, t, n) => { const r = Na(e[1]), s = new Yo(r); i = i.add(s) })).next((() => i)) } containsKey(e, t) { const n = Ta(t.path), r = IDBKeyRange.bound([n], [Ko(n)], !1, !0); let i = 0; return Kd(e).X({ index: "documentTargetsIndex", Y: !0, range: r }, ((e, t, n) => { let [r, s] = e; 0 !== r && (i++, n.done()) })).next((() => i > 0)) } le(e, t) { return zd(e).get(t).next((e => e ? Gh(e) : null)) } } function zd(e) { return el(e, "targets") } function qd(e) { return el(e, "targetGlobal") } function Kd(e) { return el(e, "targetDocuments") } function Gd(e, t) { let [n, r] = e, [i, s] = t; const o = zo(n, i); return 0 === o ? zo(r, s) : o } class Hd { constructor(e) { this.Ln = e, this.buffer = new al(Gd), this.qn = 0 } Un() { return ++this.qn } Kn(e) { const t = [e, this.Un()]; if (this.buffer.size < this.Ln) this.buffer = this.buffer.add(t); else { const e = this.buffer.last(); Gd(t, e) < 0 && (this.buffer = this.buffer.delete(e).add(t)) } } get maxValue() { return this.buffer.last()[0] } } class Qd { constructor(e, t, n) { this.garbageCollector = e, this.asyncQueue = t, this.localStore = n, this.Gn = null } start() { -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Qn(6e4) } stop() { this.Gn && (this.Gn.cancel(), this.Gn = null) } get started() { return null !== this.Gn } Qn(e) { So("LruGarbageCollector", "Garbage collection scheduled in ".concat(e, "ms")), this.Gn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, (async () => { this.Gn = null; try { await this.localStore.collectGarbage(this.garbageCollector) } catch (e) { ma(e) ? So("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e) : await ca(e) } await this.Qn(3e5) })) } } class Wd { constructor(e, t) { this.jn = e, this.params = t } calculateTargetCount(e, t) { return this.jn.zn(e).next((e => Math.floor(t / 100 * e))) } nthSequenceNumber(e, t) { if (0 === t) return ua.resolve(Sa.ct); const n = new Hd(t); return this.jn.forEachTarget(e, (e => n.Kn(e.sequenceNumber))).next((() => this.jn.Wn(e, (e => n.Kn(e))))).next((() => n.maxValue)) } removeTargets(e, t, n) { return this.jn.removeTargets(e, t, n) } removeOrphanedDocuments(e, t) { return this.jn.removeOrphanedDocuments(e, t) } collect(e, t) { return -1 === this.params.cacheSizeCollectionThreshold ? (So("LruGarbageCollector", "Garbage collection skipped; disabled"), ua.resolve(Ad)) : this.getCacheSize(e).next((n => n < this.params.cacheSizeCollectionThreshold ? (So("LruGarbageCollector", "Garbage collection skipped; Cache size ".concat(n, " is lower than threshold ").concat(this.params.cacheSizeCollectionThreshold)), Ad) : this.Hn(e, t))) } getCacheSize(e) { return this.jn.getCacheSize(e) } Hn(e, t) { let n, r, i, s, o, a, l; const c = Date.now(); return this.calculateTargetCount(e, this.params.percentileToCollect).next((t => (t > this.params.maximumSequenceNumbersToCollect ? (So("LruGarbageCollector", "Capping sequence numbers to collect down to the maximum of ".concat(this.params.maximumSequenceNumbersToCollect, " from ").concat(t)), r = this.params.maximumSequenceNumbersToCollect) : r = t, s = Date.now(), this.nthSequenceNumber(e, r)))).next((r => (n = r, o = Date.now(), this.removeTargets(e, n, t)))).next((t => (i = t, a = Date.now(), this.removeOrphanedDocuments(e, n)))).next((e => (l = Date.now(), Eo() <= Ve.DEBUG && So("LruGarbageCollector", "LRU Garbage Collection\n\tCounted targets in ".concat(s - c, "ms\n\tDetermined least recently used ").concat(r, " in ") + (o - s) + "ms\n" + "\tRemoved ".concat(i, " targets in ") + (a - o) + "ms\n" + "\tRemoved ".concat(e, " documents in ") + (l - a) + "ms\n" + "Total Duration: ".concat(l - c, "ms")), ua.resolve({ didRun: !0, sequenceNumbersCollected: r, targetsRemoved: i, documentsRemoved: e })))) } } function $d(e, t) { return new Wd(e, t) } class Xd { constructor(e, t) { this.db = e, this.garbageCollector = $d(this, t) } zn(e) { const t = this.Jn(e); return this.db.getTargetCache().getTargetCount(e).next((e => t.next((t => e + t)))) } Jn(e) { let t = 0; return this.Wn(e, (e => { t++ })).next((() => t)) } forEachTarget(e, t) { return this.db.getTargetCache().forEachTarget(e, t) } Wn(e, t) { return this.Yn(e, ((e, n) => t(n))) } addReference(e, t, n) { return Yd(e, n) } removeReference(e, t, n) { return Yd(e, n) } removeTargets(e, t, n) { return this.db.getTargetCache().removeTargets(e, t, n) } markPotentiallyOrphaned(e, t) { return Yd(e, t) } Xn(e, t) { return function (e, t) { let n = !1; return Vd(e).Z((r => Fd(e, r, t).next((e => (e && (n = !0), ua.resolve(!e)))))).next((() => n)) }(e, t) } removeOrphanedDocuments(e, t) { const n = this.db.getRemoteDocumentCache().newChangeBuffer(), r = []; let i = 0; return this.Yn(e, ((s, o) => { if (o <= t) { const t = this.Xn(e, s).next((t => { if (!t) return i++, n.getEntry(e, s).next((() => (n.removeEntry(s, Ho.min()), Kd(e).delete([0, Ta(s.path)])))) })); r.push(t) } })).next((() => ua.waitFor(r))).next((() => n.apply(e))).next((() => i)) } removeTarget(e, t) { const n = t.withSequenceNumber(e.currentSequenceNumber); return this.db.getTargetCache().updateTargetData(e, n) } updateLimboDocument(e, t) { return Yd(e, t) } Yn(e, t) { const n = Kd(e); let r, i = Sa.ct; return n.X({ index: "documentTargetsIndex" }, ((e, n) => { let [s, o] = e, { path: a, sequenceNumber: l } = n; 0 === s ? (i !== Sa.ct && t(new Yo(Na(r)), i), i = l, r = a) : i = Sa.ct })).next((() => { i !== Sa.ct && t(new Yo(Na(r)), i) })) } getCacheSize(e) { return this.db.getRemoteDocumentCache().getSize(e) } } function Yd(e, t) { return Kd(e).put(function (e, t) { return { targetId: 0, path: Ta(e.path), sequenceNumber: t } }(t, e.currentSequenceNumber)) } class Jd { constructor() { this.changes = new zc((e => e.toString()), ((e, t) => e.isEqual(t))), this.changesApplied = !1 } addEntry(e) { this.assertNotApplied(), this.changes.set(e.key, e) } removeEntry(e, t) { this.assertNotApplied(), this.changes.set(e, Gl.newInvalidDocument(e).setReadTime(t)) } getEntry(e, t) { this.assertNotApplied(); const n = this.changes.get(t); return void 0 !== n ? ua.resolve(n) : this.getFromCache(e, t) } getEntries(e, t) { return this.getAllFromCache(e, t) } apply(e) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e) } assertNotApplied() { } } class Zd { constructor(e) { this.serializer = e } setIndexManager(e) { this.indexManager = e } addEntry(e, t, n) { return rf(e).put(n) } removeEntry(e, t, n) { return rf(e).delete(function (e, t) { const n = e.path.toArray(); return [n.slice(0, n.length - 2), n[n.length - 2], Uh(t), n[n.length - 1]] }(t, n)) } updateMetadata(e, t) { return this.getMetadata(e).next((n => (n.byteSize += t, this.Zn(e, n)))) } getEntry(e, t) { let n = Gl.newInvalidDocument(t); return rf(e).X({ index: "documentKeyIndex", range: IDBKeyRange.only(sf(t)) }, ((e, r) => { n = this.ts(t, r) })).next((() => n)) } es(e, t) { let n = { size: 0, document: Gl.newInvalidDocument(t) }; return rf(e).X({ index: "documentKeyIndex", range: IDBKeyRange.only(sf(t)) }, ((e, r) => { n = { document: this.ts(t, r), size: Pd(r) } })).next((() => n)) } getEntries(e, t) { let n = Kc(); return this.ns(e, t, ((e, t) => { const r = this.ts(e, t); n = n.insert(e, r) })).next((() => n)) } ss(e, t) { let n = Kc(), r = new il(Yo.comparator); return this.ns(e, t, ((e, t) => { const i = this.ts(e, t); n = n.insert(e, i), r = r.insert(e, Pd(t)) })).next((() => ({ documents: n, rs: r }))) } ns(e, t, n) { if (t.isEmpty()) return ua.resolve(); let r = new al(af); t.forEach((e => r = r.add(e))); const i = IDBKeyRange.bound(sf(r.first()), sf(r.last())), s = r.getIterator(); let o = s.getNext(); return rf(e).X({ index: "documentKeyIndex", range: i }, ((e, t, r) => { const i = Yo.fromSegments([...t.prefixPath, t.collectionGroup, t.documentId]); for (; o && af(o, i) < 0;)n(o, null), o = s.getNext(); o && o.isEqual(i) && (n(o, t), o = s.hasNext() ? s.getNext() : null), o ? r.G(sf(o)) : r.done() })).next((() => { for (; o;)n(o, null), o = s.hasNext() ? s.getNext() : null })) } getDocumentsMatchingQuery(e, t, n, r) { const i = t.path, s = [i.popLast().toArray(), i.lastSegment(), Uh(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], o = [i.popLast().toArray(), i.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""]; return rf(e).j(IDBKeyRange.bound(s, o, !0)).next((e => { let n = Kc(); for (const i of e) { const e = this.ts(Yo.fromSegments(i.prefixPath.concat(i.collectionGroup, i.documentId)), i); e.isFoundDocument() && (jc(t, e) || r.has(e.key)) && (n = n.insert(e.key, e)) } return n })) } getAllFromCollectionGroup(e, t, n, r) { let i = Kc(); const s = of(t, n), o = of(t, sa.max()); return rf(e).X({ index: "collectionGroupIndex", range: IDBKeyRange.bound(s, o, !0) }, ((e, t, n) => { const s = this.ts(Yo.fromSegments(t.prefixPath.concat(t.collectionGroup, t.documentId)), t); i = i.insert(s.key, s), i.size === r && n.done() })).next((() => i)) } newChangeBuffer(e) { return new tf(this, !!e && e.trackRemovals) } getSize(e) { return this.getMetadata(e).next((e => e.byteSize)) } getMetadata(e) { return nf(e).get("remoteDocumentGlobalKey").next((e => (ko(!!e), e))) } Zn(e, t) { return nf(e).put("remoteDocumentGlobalKey", t) } ts(e, t) { if (t) { const e = function (e, t) { let n; if (t.document) n = _h(e.fe, t.document, !!t.hasCommittedMutations); else if (t.noDocument) { const e = Yo.fromSegments(t.noDocument.path), r = qh(t.noDocument.readTime); n = Gl.newNoDocument(e, r), t.hasCommittedMutations && n.setHasCommittedMutations() } else { if (!t.unknownDocument) return To(); { const e = Yo.fromSegments(t.unknownDocument.path), r = qh(t.unknownDocument.version); n = Gl.newUnknownDocument(e, r) } } return t.readTime && n.setReadTime(function (e) { const t = new Go(e[0], e[1]); return Ho.fromTimestamp(t) }(t.readTime)), n }(this.serializer, t); if (!e.isNoDocument() || !e.version.isEqual(Ho.min())) return e } return Gl.newInvalidDocument(e) } } function ef(e) { return new Zd(e) } class tf extends Jd { constructor(e, t) { super(), this.os = e, this.trackRemovals = t, this.us = new zc((e => e.toString()), ((e, t) => e.isEqual(t))) } applyChanges(e) { const t = []; let n = 0, r = new al(((e, t) => zo(e.canonicalString(), t.canonicalString()))); return this.changes.forEach(((i, s) => { const o = this.us.get(i); if (t.push(this.os.removeEntry(e, i, o.readTime)), s.isValidDocument()) { const a = Bh(this.os.serializer, s); r = r.add(i.path.popLast()); const l = Pd(a); n += l - o.size, t.push(this.os.addEntry(e, i, a)) } else if (n -= o.size, this.trackRemovals) { const n = Bh(this.os.serializer, s.convertToNoDocument(Ho.min())); t.push(this.os.addEntry(e, i, n)) } })), r.forEach((n => { t.push(this.os.indexManager.addToCollectionParentIndex(e, n)) })), t.push(this.os.updateMetadata(e, n)), ua.waitFor(t) } getFromCache(e, t) { return this.os.es(e, t).next((e => (this.us.set(t, { size: e.size, readTime: e.document.readTime }), e.document))) } getAllFromCache(e, t) { return this.os.ss(e, t).next((e => { let { documents: t, rs: n } = e; return n.forEach(((e, n) => { this.us.set(e, { size: n, readTime: t.get(e).readTime }) })), t })) } } function nf(e) { return el(e, "remoteDocumentGlobal") } function rf(e) { return el(e, "remoteDocumentsV14") } function sf(e) { const t = e.path.toArray(); return [t.slice(0, t.length - 2), t[t.length - 2], t[t.length - 1]] } function of(e, t) { const n = t.documentKey.path.toArray(); return [e, Uh(t.readTime), n.slice(0, n.length - 2), n.length > 0 ? n[n.length - 1] : ""] } function af(e, t) { const n = e.path.toArray(), r = t.path.toArray(); let i = 0; for (let s = 0; s < n.length - 2 && s < r.length - 2; ++s)if (i = zo(n[s], r[s]), i) return i; return i = zo(n.length, r.length), i || (i = zo(n[n.length - 2], r[r.length - 2]), i || zo(n[n.length - 1], r[r.length - 1])) } class lf { constructor(e, t) { this.overlayedDocument = e, this.mutatedFields = t } } class cf { constructor(e, t, n, r) { this.remoteDocumentCache = e, this.mutationQueue = t, this.documentOverlayCache = n, this.indexManager = r } getDocument(e, t) { let n = null; return this.documentOverlayCache.getOverlay(e, t).next((r => (n = r, this.remoteDocumentCache.getEntry(e, t)))).next((e => (null !== n && xu(n.mutation, e, ul.empty(), Go.now()), e))) } getDocuments(e, t) { return this.remoteDocumentCache.getEntries(e, t).next((t => this.getLocalViewOfDocuments(e, t, Zc()).next((() => t)))) } getLocalViewOfDocuments(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Zc(); const r = Wc(); return this.populateOverlays(e, r, t).next((() => this.computeViews(e, t, r, n).next((e => { let t = Hc(); return e.forEach(((e, n) => { t = t.insert(e, n.overlayedDocument) })), t })))) } getOverlayedDocuments(e, t) { const n = Wc(); return this.populateOverlays(e, n, t).next((() => this.computeViews(e, t, n, Zc()))) } populateOverlays(e, t, n) { const r = []; return n.forEach((e => { t.has(e) || r.push(e) })), this.documentOverlayCache.getOverlays(e, r).next((e => { e.forEach(((e, n) => { t.set(e, n) })) })) } computeViews(e, t, n, r) { let i = Kc(); const s = Xc(), o = Xc(); return t.forEach(((e, t) => { const o = n.get(t.key); r.has(t.key) && (void 0 === o || o.mutation instanceof Cu) ? i = i.insert(t.key, t) : void 0 !== o ? (s.set(t.key, o.mutation.getFieldMask()), xu(o.mutation, t, o.mutation.getFieldMask(), Go.now())) : s.set(t.key, ul.empty()) })), this.recalculateAndSaveOverlays(e, i).next((e => (e.forEach(((e, t) => s.set(e, t))), t.forEach(((e, t) => { var n; return o.set(e, new lf(t, null !== (n = s.get(e)) && void 0 !== n ? n : null)) })), o))) } recalculateAndSaveOverlays(e, t) { const n = Xc(); let r = new il(((e, t) => e - t)), i = Zc(); return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next((e => { for (const i of e) i.keys().forEach((e => { const s = t.get(e); if (null === s) return; let o = n.get(e) || ul.empty(); o = i.applyToLocalView(s, o), n.set(e, o); const a = (r.get(i.batchId) || Zc()).add(e); r = r.insert(i.batchId, a) })) })).next((() => { const s = [], o = r.getReverseIterator(); for (; o.hasNext();) { const r = o.getNext(), a = r.key, l = r.value, c = $c(); l.forEach((e => { if (!i.has(e)) { const r = Su(t.get(e), n.get(e)); null !== r && c.set(e, r), i = i.add(e) } })), s.push(this.documentOverlayCache.saveOverlays(e, a, c)) } return ua.waitFor(s) })).next((() => n)) } recalculateAndSaveOverlaysForDocumentKeys(e, t) { return this.remoteDocumentCache.getEntries(e, t).next((t => this.recalculateAndSaveOverlays(e, t))) } getDocumentsMatchingQuery(e, t, n) { return function (e) { return Yo.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length }(t) ? this.getDocumentsMatchingDocumentQuery(e, t.path) : Dc(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, n) : this.getDocumentsMatchingCollectionQuery(e, t, n) } getNextDocuments(e, t, n, r) { return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, n, r).next((i => { const s = r - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, n.largestBatchId, r - i.size) : ua.resolve(Wc()); let o = -1, a = i; return s.next((t => ua.forEach(t, ((t, n) => (o < n.largestBatchId && (o = n.largestBatchId), i.get(t) ? ua.resolve() : this.remoteDocumentCache.getEntry(e, t).next((e => { a = a.insert(t, e) }))))).next((() => this.populateOverlays(e, t, i))).next((() => this.computeViews(e, a, t, Zc()))).next((e => ({ batchId: o, changes: Qc(e) }))))) })) } getDocumentsMatchingDocumentQuery(e, t) { return this.getDocument(e, new Yo(t)).next((e => { let t = Hc(); return e.isFoundDocument() && (t = t.insert(e.key, e)), t })) } getDocumentsMatchingCollectionGroupQuery(e, t, n) { const r = t.collectionGroup; let i = Hc(); return this.indexManager.getCollectionParents(e, r).next((s => ua.forEach(s, (s => { const o = function (e, t) { return new xc(t, null, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt) }(t, s.child(r)); return this.getDocumentsMatchingCollectionQuery(e, o, n).next((e => { e.forEach(((e, t) => { i = i.insert(e, t) })) })) })).next((() => i)))) } getDocumentsMatchingCollectionQuery(e, t, n) { let r; return this.documentOverlayCache.getOverlaysForCollection(e, t.path, n.largestBatchId).next((i => (r = i, this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, n, r)))).next((e => { r.forEach(((t, n) => { const r = n.getKey(); null === e.get(r) && (e = e.insert(r, Gl.newInvalidDocument(r))) })); let n = Hc(); return e.forEach(((e, i) => { const s = r.get(e); void 0 !== s && xu(s.mutation, i, ul.empty(), Go.now()), jc(t, i) && (n = n.insert(e, i)) })), n })) } } class uf { constructor(e) { this.serializer = e, this.cs = new Map, this.hs = new Map } getBundleMetadata(e, t) { return ua.resolve(this.cs.get(t)) } saveBundleMetadata(e, t) { var n; return this.cs.set(t.id, { id: (n = t).id, version: n.version, createTime: fh(n.createTime) }), ua.resolve() } getNamedQuery(e, t) { return ua.resolve(this.hs.get(t)) } saveNamedQuery(e, t) { return this.hs.set(t.name, function (e) { return { name: e.name, query: Qh(e.bundledQuery), readTime: fh(e.readTime) } }(t)), ua.resolve() } } class hf { constructor() { this.overlays = new il(Yo.comparator), this.ls = new Map } getOverlay(e, t) { return ua.resolve(this.overlays.get(t)) } getOverlays(e, t) { const n = Wc(); return ua.forEach(t, (t => this.getOverlay(e, t).next((e => { null !== e && n.set(t, e) })))).next((() => n)) } saveOverlays(e, t, n) { return n.forEach(((n, r) => { this.we(e, t, r) })), ua.resolve() } removeOverlaysForBatchId(e, t, n) { const r = this.ls.get(n); return void 0 !== r && (r.forEach((e => this.overlays = this.overlays.remove(e))), this.ls.delete(n)), ua.resolve() } getOverlaysForCollection(e, t, n) { const r = Wc(), i = t.length + 1, s = new Yo(t.child("")), o = this.overlays.getIteratorFrom(s); for (; o.hasNext();) { const e = o.getNext().value, s = e.getKey(); if (!t.isPrefixOf(s.path)) break; s.path.length === i && e.largestBatchId > n && r.set(e.getKey(), e) } return ua.resolve(r) } getOverlaysForCollectionGroup(e, t, n, r) { let i = new il(((e, t) => e - t)); const s = this.overlays.getIterator(); for (; s.hasNext();) { const e = s.getNext().value; if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) { let t = i.get(e.largestBatchId); null === t && (t = Wc(), i = i.insert(e.largestBatchId, t)), t.set(e.getKey(), e) } } const o = Wc(), a = i.getIterator(); for (; a.hasNext() && (a.getNext().value.forEach(((e, t) => o.set(e, t))), !(o.size() >= r));); return ua.resolve(o) } we(e, t, n) { const r = this.overlays.get(n.key); if (null !== r) { const e = this.ls.get(r.largestBatchId).delete(n.key); this.ls.set(r.largestBatchId, e) } this.overlays = this.overlays.insert(n.key, new Fu(t, n)); let i = this.ls.get(t); void 0 === i && (i = Zc(), this.ls.set(t, i)), this.ls.set(t, i.add(n.key)) } } class df { constructor() { this.fs = new al(ff.ds), this.ws = new al(ff._s) } isEmpty() { return this.fs.isEmpty() } addReference(e, t) { const n = new ff(e, t); this.fs = this.fs.add(n), this.ws = this.ws.add(n) } gs(e, t) { e.forEach((e => this.addReference(e, t))) } removeReference(e, t) { this.ys(new ff(e, t)) } ps(e, t) { e.forEach((e => this.removeReference(e, t))) } Is(e) { const t = new Yo(new Wo([])), n = new ff(t, e), r = new ff(t, e + 1), i = []; return this.ws.forEachInRange([n, r], (e => { this.ys(e), i.push(e.key) })), i } Ts() { this.fs.forEach((e => this.ys(e))) } ys(e) { this.fs = this.fs.delete(e), this.ws = this.ws.delete(e) } Es(e) { const t = new Yo(new Wo([])), n = new ff(t, e), r = new ff(t, e + 1); let i = Zc(); return this.ws.forEachInRange([n, r], (e => { i = i.add(e.key) })), i } containsKey(e) { const t = new ff(e, 0), n = this.fs.firstAfterOrEqual(t); return null !== n && e.isEqual(n.key) } } class ff { constructor(e, t) { this.key = e, this.As = t } static ds(e, t) { return Yo.comparator(e.key, t.key) || zo(e.As, t.As) } static _s(e, t) { return zo(e.As, t.As) || Yo.comparator(e.key, t.key) } } class pf { constructor(e, t) { this.indexManager = e, this.referenceDelegate = t, this.mutationQueue = [], this.vs = 1, this.Rs = new al(ff.ds) } checkEmpty(e) { return ua.resolve(0 === this.mutationQueue.length) } addMutationBatch(e, t, n, r) { const i = this.vs; this.vs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1]; const s = new Pu(i, t, n, r); this.mutationQueue.push(s); for (const o of r) this.Rs = this.Rs.add(new ff(o.key, i)), this.indexManager.addToCollectionParentIndex(e, o.key.path.popLast()); return ua.resolve(s) } lookupMutationBatch(e, t) { return ua.resolve(this.Ps(t)) } getNextMutationBatchAfterBatchId(e, t) { const n = t + 1, r = this.bs(n), i = r < 0 ? 0 : r; return ua.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null) } getHighestUnacknowledgedBatchId() { return ua.resolve(0 === this.mutationQueue.length ? -1 : this.vs - 1) } getAllMutationBatches(e) { return ua.resolve(this.mutationQueue.slice()) } getAllMutationBatchesAffectingDocumentKey(e, t) { const n = new ff(t, 0), r = new ff(t, Number.POSITIVE_INFINITY), i = []; return this.Rs.forEachInRange([n, r], (e => { const t = this.Ps(e.As); i.push(t) })), ua.resolve(i) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let n = new al(zo); return t.forEach((e => { const t = new ff(e, 0), r = new ff(e, Number.POSITIVE_INFINITY); this.Rs.forEachInRange([t, r], (e => { n = n.add(e.As) })) })), ua.resolve(this.Vs(n)) } getAllMutationBatchesAffectingQuery(e, t) { const n = t.path, r = n.length + 1; let i = n; Yo.isDocumentKey(i) || (i = i.child("")); const s = new ff(new Yo(i), 0); let o = new al(zo); return this.Rs.forEachWhile((e => { const t = e.key.path; return !!n.isPrefixOf(t) && (t.length === r && (o = o.add(e.As)), !0) }), s), ua.resolve(this.Vs(o)) } Vs(e) { const t = []; return e.forEach((e => { const n = this.Ps(e); null !== n && t.push(n) })), t } removeMutationBatch(e, t) { ko(0 === this.Ss(t.batchId, "removed")), this.mutationQueue.shift(); let n = this.Rs; return ua.forEach(t.mutations, (r => { const i = new ff(r.key, t.batchId); return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(e, r.key) })).next((() => { this.Rs = n })) } Cn(e) { } containsKey(e, t) { const n = new ff(t, 0), r = this.Rs.firstAfterOrEqual(n); return ua.resolve(t.isEqual(r && r.key)) } performConsistencyCheck(e) { return this.mutationQueue.length, ua.resolve() } Ss(e, t) { return this.bs(e) } bs(e) { return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId } Ps(e) { const t = this.bs(e); return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t] } } class mf { constructor(e) { this.Ds = e, this.docs = new il(Yo.comparator), this.size = 0 } setIndexManager(e) { this.indexManager = e } addEntry(e, t) { const n = t.key, r = this.docs.get(n), i = r ? r.size : 0, s = this.Ds(t); return this.docs = this.docs.insert(n, { document: t.mutableCopy(), size: s }), this.size += s - i, this.indexManager.addToCollectionParentIndex(e, n.path.popLast()) } removeEntry(e) { const t = this.docs.get(e); t && (this.docs = this.docs.remove(e), this.size -= t.size) } getEntry(e, t) { const n = this.docs.get(t); return ua.resolve(n ? n.document.mutableCopy() : Gl.newInvalidDocument(t)) } getEntries(e, t) { let n = Kc(); return t.forEach((e => { const t = this.docs.get(e); n = n.insert(e, t ? t.document.mutableCopy() : Gl.newInvalidDocument(e)) })), ua.resolve(n) } getDocumentsMatchingQuery(e, t, n, r) { let i = Kc(); const s = t.path, o = new Yo(s.child("")), a = this.docs.getIteratorFrom(o); for (; a.hasNext();) { const { key: e, value: { document: o } } = a.getNext(); if (!s.isPrefixOf(e.path)) break; e.path.length > s.length + 1 || oa(ia(o), n) <= 0 || (r.has(o.key) || jc(t, o)) && (i = i.insert(o.key, o.mutableCopy())) } return ua.resolve(i) } getAllFromCollectionGroup(e, t, n, r) { To() } Cs(e, t) { return ua.forEach(this.docs, (e => t(e))) } newChangeBuffer(e) { return new gf(this) } getSize(e) { return ua.resolve(this.size) } } class gf extends Jd { constructor(e) { super(), this.os = e } applyChanges(e) { const t = []; return this.changes.forEach(((n, r) => { r.isValidDocument() ? t.push(this.os.addEntry(e, r)) : this.os.removeEntry(n) })), ua.waitFor(t) } getFromCache(e, t) { return this.os.getEntry(e, t) } getAllFromCache(e, t) { return this.os.getEntries(e, t) } } class yf { constructor(e) { this.persistence = e, this.xs = new zc((e => vc(e)), wc), this.lastRemoteSnapshotVersion = Ho.min(), this.highestTargetId = 0, this.Ns = 0, this.ks = new df, this.targetCount = 0, this.Ms = Bd.kn() } forEachTarget(e, t) { return this.xs.forEach(((e, n) => t(n))), ua.resolve() } getLastRemoteSnapshotVersion(e) { return ua.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(e) { return ua.resolve(this.Ns) } allocateTargetId(e) { return this.highestTargetId = this.Ms.next(), ua.resolve(this.highestTargetId) } setTargetsMetadata(e, t, n) { return n && (this.lastRemoteSnapshotVersion = n), t > this.Ns && (this.Ns = t), ua.resolve() } Fn(e) { this.xs.set(e.target, e); const t = e.targetId; t > this.highestTargetId && (this.Ms = new Bd(t), this.highestTargetId = t), e.sequenceNumber > this.Ns && (this.Ns = e.sequenceNumber) } addTargetData(e, t) { return this.Fn(t), this.targetCount += 1, ua.resolve() } updateTargetData(e, t) { return this.Fn(t), ua.resolve() } removeTargetData(e, t) { return this.xs.delete(t.target), this.ks.Is(t.targetId), this.targetCount -= 1, ua.resolve() } removeTargets(e, t, n) { let r = 0; const i = []; return this.xs.forEach(((s, o) => { o.sequenceNumber <= t && null === n.get(o.targetId) && (this.xs.delete(s), i.push(this.removeMatchingKeysForTargetId(e, o.targetId)), r++) })), ua.waitFor(i).next((() => r)) } getTargetCount(e) { return ua.resolve(this.targetCount) } getTargetData(e, t) { const n = this.xs.get(t) || null; return ua.resolve(n) } addMatchingKeys(e, t, n) { return this.ks.gs(t, n), ua.resolve() } removeMatchingKeys(e, t, n) { this.ks.ps(t, n); const r = this.persistence.referenceDelegate, i = []; return r && t.forEach((t => { i.push(r.markPotentiallyOrphaned(e, t)) })), ua.waitFor(i) } removeMatchingKeysForTargetId(e, t) { return this.ks.Is(t), ua.resolve() } getMatchingKeysForTargetId(e, t) { const n = this.ks.Es(t); return ua.resolve(n) } containsKey(e, t) { return ua.resolve(this.ks.containsKey(t)) } } class vf { constructor(e, t) { this.$s = {}, this.overlays = {}, this.Os = new Sa(0), this.Fs = !1, this.Fs = !0, this.referenceDelegate = e(this), this.Bs = new yf(this), this.indexManager = new Sd, this.remoteDocumentCache = function (e) { return new mf(e) }((e => this.referenceDelegate.Ls(e))), this.serializer = new Vh(t), this.qs = new uf(this.serializer) } start() { return Promise.resolve() } shutdown() { return this.Fs = !1, Promise.resolve() } get started() { return this.Fs } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(e) { return this.indexManager } getDocumentOverlayCache(e) { let t = this.overlays[e.toKey()]; return t || (t = new hf, this.overlays[e.toKey()] = t), t } getMutationQueue(e, t) { let n = this.$s[e.toKey()]; return n || (n = new pf(t, this.referenceDelegate), this.$s[e.toKey()] = n), n } getTargetCache() { return this.Bs } getRemoteDocumentCache() { return this.remoteDocumentCache } getBundleCache() { return this.qs } runTransaction(e, t, n) { So("MemoryPersistence", "Starting transaction:", e); const r = new wf(this.Os.next()); return this.referenceDelegate.Us(), n(r).next((e => this.referenceDelegate.Ks(r).next((() => e)))).toPromise().then((e => (r.raiseOnCommittedEvent(), e))) } Gs(e, t) { return ua.or(Object.values(this.$s).map((n => () => n.containsKey(e, t)))) } } class wf extends la { constructor(e) { super(), this.currentSequenceNumber = e } } class bf { constructor(e) { this.persistence = e, this.Qs = new df, this.js = null } static zs(e) { return new bf(e) } get Ws() { if (this.js) return this.js; throw To() } addReference(e, t, n) { return this.Qs.addReference(n, t), this.Ws.delete(n.toString()), ua.resolve() } removeReference(e, t, n) { return this.Qs.removeReference(n, t), this.Ws.add(n.toString()), ua.resolve() } markPotentiallyOrphaned(e, t) { return this.Ws.add(t.toString()), ua.resolve() } removeTarget(e, t) { this.Qs.Is(t.targetId).forEach((e => this.Ws.add(e.toString()))); const n = this.persistence.getTargetCache(); return n.getMatchingKeysForTargetId(e, t.targetId).next((e => { e.forEach((e => this.Ws.add(e.toString()))) })).next((() => n.removeTargetData(e, t))) } Us() { this.js = new Set } Ks(e) { const t = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return ua.forEach(this.Ws, (n => { const r = Yo.fromPath(n); return this.Hs(e, r).next((e => { e || t.removeEntry(r, Ho.min()) })) })).next((() => (this.js = null, t.apply(e)))) } updateLimboDocument(e, t) { return this.Hs(e, t).next((e => { e ? this.Ws.delete(t.toString()) : this.Ws.add(t.toString()) })) } Ls(e) { return 0 } Hs(e, t) { return ua.or([() => ua.resolve(this.Qs.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Gs(e, t)]) } } class Ef { constructor(e) { this.serializer = e } O(e, t, n, r) { const i = new ha("createOrUpgrade", t); n < 1 && r >= 1 && (function (e) { e.createObjectStore("owner") }(e), function (e) { e.createObjectStore("mutationQueues", { keyPath: "userId" }), e.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", Da, { unique: !0 }), e.createObjectStore("documentMutations") }(e), Sf(e), function (e) { e.createObjectStore("remoteDocuments") }(e)); let s = ua.resolve(); return n < 3 && r >= 3 && (0 !== n && (function (e) { e.deleteObjectStore("targetDocuments"), e.deleteObjectStore("targets"), e.deleteObjectStore("targetGlobal") }(e), Sf(e)), s = s.next((() => function (e) { const t = e.store("targetGlobal"), n = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: Ho.min().toTimestamp(), targetCount: 0 }; return t.put("targetGlobalKey", n) }(i)))), n < 4 && r >= 4 && (0 !== n && (s = s.next((() => function (e, t) { return t.store("mutations").j().next((n => { e.deleteObjectStore("mutations"), e.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", Da, { unique: !0 }); const r = t.store("mutations"), i = n.map((e => r.put(e))); return ua.waitFor(i) })) }(e, i)))), s = s.next((() => { !function (e) { e.createObjectStore("clientMetadata", { keyPath: "clientId" }) }(e) }))), n < 5 && r >= 5 && (s = s.next((() => this.Ys(i)))), n < 6 && r >= 6 && (s = s.next((() => (function (e) { e.createObjectStore("remoteDocumentGlobal") }(e), this.Xs(i))))), n < 7 && r >= 7 && (s = s.next((() => this.Zs(i)))), n < 8 && r >= 8 && (s = s.next((() => this.ti(e, i)))), n < 9 && r >= 9 && (s = s.next((() => { !function (e) { e.objectStoreNames.contains("remoteDocumentChanges") && e.deleteObjectStore("remoteDocumentChanges") }(e) }))), n < 10 && r >= 10 && (s = s.next((() => this.ei(i)))), n < 11 && r >= 11 && (s = s.next((() => { !function (e) { e.createObjectStore("bundles", { keyPath: "bundleId" }) }(e), function (e) { e.createObjectStore("namedQueries", { keyPath: "name" }) }(e) }))), n < 12 && r >= 12 && (s = s.next((() => { !function (e) { const t = e.createObjectStore("documentOverlays", { keyPath: Ga }); t.createIndex("collectionPathOverlayIndex", Ha, { unique: !1 }), t.createIndex("collectionGroupOverlayIndex", Qa, { unique: !1 }) }(e) }))), n < 13 && r >= 13 && (s = s.next((() => function (e) { const t = e.createObjectStore("remoteDocumentsV14", { keyPath: Pa }); t.createIndex("documentKeyIndex", La), t.createIndex("collectionGroupIndex", Fa) }(e))).next((() => this.ni(e, i))).next((() => e.deleteObjectStore("remoteDocuments")))), n < 14 && r >= 14 && (s = s.next((() => this.si(e, i)))), n < 15 && r >= 15 && (s = s.next((() => function (e) { e.createObjectStore("indexConfiguration", { keyPath: "indexId", autoIncrement: !0 }).createIndex("collectionGroupIndex", "collectionGroup", { unique: !1 }), e.createObjectStore("indexState", { keyPath: Ua }).createIndex("sequenceNumberIndex", za, { unique: !1 }), e.createObjectStore("indexEntries", { keyPath: qa }).createIndex("documentKeyIndex", Ka, { unique: !1 }) }(e)))), s } Xs(e) { let t = 0; return e.store("remoteDocuments").X(((e, n) => { t += Pd(n) })).next((() => { const n = { byteSize: t }; return e.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n) })) } Ys(e) { const t = e.store("mutationQueues"), n = e.store("mutations"); return t.j().next((t => ua.forEach(t, (t => { const r = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]); return n.j("userMutationsIndex", r).next((n => ua.forEach(n, (n => { ko(n.userId === t.userId); const r = Kh(this.serializer, n); return Rd(e, t.userId, r).next((() => { })) })))) })))) } Zs(e) { const t = e.store("targetDocuments"), n = e.store("remoteDocuments"); return e.store("targetGlobal").get("targetGlobalKey").next((e => { const r = []; return n.X(((n, i) => { const s = new Wo(n), o = function (e) { return [0, Ta(e)] }(s); r.push(t.get(o).next((n => n ? ua.resolve() : (n => t.put({ targetId: 0, path: Ta(n), sequenceNumber: e.highestListenSequenceNumber }))(s)))) })).next((() => ua.waitFor(r))) })) } ti(e, t) { e.createObjectStore("collectionParents", { keyPath: Ba }); const n = t.store("collectionParents"), r = new _d, i = e => { if (r.add(e)) { const t = e.lastSegment(), r = e.popLast(); return n.put({ collectionId: t, parent: Ta(r) }) } }; return t.store("remoteDocuments").X({ Y: !0 }, ((e, t) => { const n = new Wo(e); return i(n.popLast()) })).next((() => t.store("documentMutations").X({ Y: !0 }, ((e, t) => { let [n, r, s] = e; const o = Na(r); return i(o.popLast()) })))) } ei(e) { const t = e.store("targets"); return t.X(((e, n) => { const r = Gh(n), i = Hh(this.serializer, r); return t.put(i) })) } ni(e, t) { const n = t.store("remoteDocuments"), r = []; return n.X(((e, n) => { const i = t.store("remoteDocumentsV14"), s = (o = n, o.document ? new Yo(Wo.fromString(o.document.name).popFirst(5)) : o.noDocument ? Yo.fromSegments(o.noDocument.path) : o.unknownDocument ? Yo.fromSegments(o.unknownDocument.path) : To()).path.toArray(); var o; const a = { prefixPath: s.slice(0, s.length - 2), collectionGroup: s[s.length - 2], documentId: s[s.length - 1], readTime: n.readTime || [0, 0], unknownDocument: n.unknownDocument, noDocument: n.noDocument, document: n.document, hasCommittedMutations: !!n.hasCommittedMutations }; r.push(i.put(a)) })).next((() => ua.waitFor(r))) } si(e, t) { const n = t.store("mutations"), r = ef(this.serializer), i = new vf(bf.zs, this.serializer.fe); return n.j().next((e => { const n = new Map; return e.forEach((e => { var t; let r = null !== (t = n.get(e.userId)) && void 0 !== t ? t : Zc(); Kh(this.serializer, e).keys().forEach((e => r = r.add(e))), n.set(e.userId, r) })), ua.forEach(n, ((e, n) => { const s = new vo(n), o = ed.de(this.serializer, s), a = i.getIndexManager(s), l = Ld.de(s, this.serializer, a, i.referenceDelegate); return new cf(r, l, o, a).recalculateAndSaveOverlaysForDocumentKeys(new Za(t, Sa.ct), e).next() })) })) } } function Sf(e) { e.createObjectStore("targetDocuments", { keyPath: ja }).createIndex("documentTargetsIndex", Va, { unique: !0 }), e.createObjectStore("targets", { keyPath: "targetId" }).createIndex("queryTargetsIndex", Ma, { unique: !0 }), e.createObjectStore("targetGlobal") } const _f = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time."; class xf { constructor(e, t, n, r, i, s, o, a, l, c) { let u = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 15; if (this.allowTabSynchronization = e, this.persistenceKey = t, this.clientId = n, this.ii = i, this.window = s, this.document = o, this.ri = l, this.oi = c, this.ui = u, this.Os = null, this.Fs = !1, this.isPrimary = !1, this.networkEnabled = !0, this.ci = null, this.inForeground = !1, this.ai = null, this.hi = null, this.li = Number.NEGATIVE_INFINITY, this.fi = e => Promise.resolve(), !xf.D()) throw new Do(No.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled."); this.referenceDelegate = new Xd(this, r), this.di = t + "main", this.serializer = new Vh(a), this.wi = new da(this.di, this.ui, new Ef(this.serializer)), this.Bs = new Ud(this.referenceDelegate, this.serializer), this.remoteDocumentCache = ef(this.serializer), this.qs = new Yh, this.window && this.window.localStorage ? this._i = this.window.localStorage : (this._i = null, !1 === c && _o("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.")) } start() { return this.mi().then((() => { if (!this.isPrimary && !this.allowTabSynchronization) throw new Do(No.FAILED_PRECONDITION, _f); return this.gi(), this.yi(), this.pi(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (e => this.Bs.getHighestSequenceNumber(e))) })).then((e => { this.Os = new Sa(e, this.ri) })).then((() => { this.Fs = !0 })).catch((e => (this.wi && this.wi.close(), Promise.reject(e)))) } Ii(e) { return this.fi = async t => { if (this.started) return e(t) }, e(this.isPrimary) } setDatabaseDeletedListener(e) { this.wi.B((async t => { null === t.newVersion && await e() })) } setNetworkEnabled(e) { this.networkEnabled !== e && (this.networkEnabled = e, this.ii.enqueueAndForget((async () => { this.started && await this.mi() }))) } mi() { return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (e => Tf(e).put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground }).next((() => { if (this.isPrimary) return this.Ti(e).next((e => { e || (this.isPrimary = !1, this.ii.enqueueRetryable((() => this.fi(!1)))) })) })).next((() => this.Ei(e))).next((t => this.isPrimary && !t ? this.Ai(e).next((() => !1)) : !!t && this.vi(e).next((() => !0)))))).catch((e => { if (ma(e)) return So("IndexedDbPersistence", "Failed to extend owner lease: ", e), this.isPrimary; if (!this.allowTabSynchronization) throw e; return So("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), !1 })).then((e => { this.isPrimary !== e && this.ii.enqueueRetryable((() => this.fi(e))), this.isPrimary = e })) } Ti(e) { return If(e).get("owner").next((e => ua.resolve(this.Ri(e)))) } Pi(e) { return Tf(e).delete(this.clientId) } async bi() { if (this.isPrimary && !this.Vi(this.li, 18e5)) { this.li = Date.now(); const e = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (e => { const t = el(e, "clientMetadata"); return t.j().next((e => { const n = this.Si(e, 18e5), r = e.filter((e => -1 === n.indexOf(e))); return ua.forEach(r, (e => t.delete(e.clientId))).next((() => r)) })) })).catch((() => [])); if (this._i) for (const t of e) this._i.removeItem(this.Di(t.clientId)) } } pi() { this.hi = this.ii.enqueueAfterDelay("client_metadata_refresh", 4e3, (() => this.mi().then((() => this.bi())).then((() => this.pi())))) } Ri(e) { return !!e && e.ownerId === this.clientId } Ei(e) { return this.oi ? ua.resolve(!0) : If(e).get("owner").next((t => { if (null !== t && this.Vi(t.leaseTimestampMs, 5e3) && !this.Ci(t.ownerId)) { if (this.Ri(t) && this.networkEnabled) return !0; if (!this.Ri(t)) { if (!t.allowTabSynchronization) throw new Do(No.FAILED_PRECONDITION, _f); return !1 } } return !(!this.networkEnabled || !this.inForeground) || Tf(e).j().next((e => void 0 === this.Si(e, 5e3).find((e => { if (this.clientId !== e.clientId) { const t = !this.networkEnabled && e.networkEnabled, n = !this.inForeground && e.inForeground, r = this.networkEnabled === e.networkEnabled; if (t || n && r) return !0 } return !1 })))) })).next((e => (this.isPrimary !== e && So("IndexedDbPersistence", "Client ".concat(e ? "is" : "is not", " eligible for a primary lease.")), e))) } async shutdown() { this.Fs = !1, this.xi(), this.hi && (this.hi.cancel(), this.hi = null), this.Ni(), this.ki(), await this.wi.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (e => { const t = new Za(e, Sa.ct); return this.Ai(t).next((() => this.Pi(t))) })), this.wi.close(), this.Mi() } Si(e, t) { return e.filter((e => this.Vi(e.updateTimeMs, t) && !this.Ci(e.clientId))) } $i() { return this.runTransaction("getActiveClients", "readonly", (e => Tf(e).j().next((e => this.Si(e, 18e5).map((e => e.clientId)))))) } get started() { return this.Fs } getMutationQueue(e, t) { return Ld.de(e, this.serializer, t, this.referenceDelegate) } getTargetCache() { return this.Bs } getRemoteDocumentCache() { return this.remoteDocumentCache } getIndexManager(e) { return new Id(e, this.serializer.fe.databaseId) } getDocumentOverlayCache(e) { return ed.de(this.serializer, e) } getBundleCache() { return this.qs } runTransaction(e, t, n) { So("IndexedDbPersistence", "Starting transaction:", e); const r = "readonly" === t ? "readonly" : "readwrite", i = 15 === (s = this.ui) ? Ja : 14 === s ? Ya : 13 === s ? Xa : 12 === s ? $a : 11 === s ? Wa : void To(); var s; let o; return this.wi.runTransaction(e, r, i, (r => (o = new Za(r, this.Os ? this.Os.next() : Sa.ct), "readwrite-primary" === t ? this.Ti(o).next((e => !!e || this.Ei(o))).next((t => { if (!t) throw _o("Failed to obtain primary lease for action '".concat(e, "'.")), this.isPrimary = !1, this.ii.enqueueRetryable((() => this.fi(!1))), new Do(No.FAILED_PRECONDITION, aa); return n(o) })).next((e => this.vi(o).next((() => e)))) : this.Oi(o).next((() => n(o)))))).then((e => (o.raiseOnCommittedEvent(), e))) } Oi(e) { return If(e).get("owner").next((e => { if (null !== e && this.Vi(e.leaseTimestampMs, 5e3) && !this.Ci(e.ownerId) && !this.Ri(e) && !(this.oi || this.allowTabSynchronization && e.allowTabSynchronization)) throw new Do(No.FAILED_PRECONDITION, _f) })) } vi(e) { const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() }; return If(e).put("owner", t) } static D() { return da.D() } Ai(e) { const t = If(e); return t.get("owner").next((e => this.Ri(e) ? (So("IndexedDbPersistence", "Releasing primary lease."), t.delete("owner")) : ua.resolve())) } Vi(e, t) { const n = Date.now(); return !(e < n - t) && (!(e > n) || (_o("Detected an update time that is in the future: ".concat(e, " > ").concat(n)), !1)) } gi() { null !== this.document && "function" == typeof this.document.addEventListener && (this.ai = () => { this.ii.enqueueAndForget((() => (this.inForeground = "visible" === this.document.visibilityState, this.mi()))) }, this.document.addEventListener("visibilitychange", this.ai), this.inForeground = "visible" === this.document.visibilityState) } Ni() { this.ai && (this.document.removeEventListener("visibilitychange", this.ai), this.ai = null) } yi() { var e; "function" == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) && (this.ci = () => { this.xi(); const e = /(?:Version|Mobile)\/1[456]/; Se() && (navigator.appVersion.match(e) || navigator.userAgent.match(e)) && this.ii.enterRestrictedMode(!0), this.ii.enqueueAndForget((() => this.shutdown())) }, this.window.addEventListener("pagehide", this.ci)) } ki() { this.ci && (this.window.removeEventListener("pagehide", this.ci), this.ci = null) } Ci(e) { var t; try { const n = null !== (null === (t = this._i) || void 0 === t ? void 0 : t.getItem(this.Di(e))); return So("IndexedDbPersistence", "Client '".concat(e, "' ").concat(n ? "is" : "is not", " zombied in LocalStorage")), n } catch (e) { return _o("IndexedDbPersistence", "Failed to get zombied client id.", e), !1 } } xi() { if (this._i) try { this._i.setItem(this.Di(this.clientId), String(Date.now())) } catch (e) { _o("Failed to set zombie client id.", e) } } Mi() { if (this._i) try { this._i.removeItem(this.Di(this.clientId)) } catch (e) { } } Di(e) { return "firestore_zombie_".concat(this.persistenceKey, "_").concat(e) } } function If(e) { return el(e, "owner") } function Tf(e) { return el(e, "clientMetadata") } function kf(e, t) { let n = e.projectId; return e.isDefaultDatabase || (n += "." + e.database), "firestore/" + t + "/" + n + "/" } class Cf { constructor(e, t, n, r) { this.targetId = e, this.fromCache = t, this.Fi = n, this.Bi = r } static Li(e, t) { let n = Zc(), r = Zc(); for (const i of t.docChanges) switch (i.type) { case 0: n = n.add(i.doc.key); break; case 1: r = r.add(i.doc.key) }return new Cf(e, t.fromCache, n, r) } } class Nf { constructor() { this.qi = !1 } initialize(e, t) { this.Ui = e, this.indexManager = t, this.qi = !0 } getDocumentsMatchingQuery(e, t, n, r) { return this.Ki(e, t).next((i => i || this.Gi(e, t, r, n))).next((n => n || this.Qi(e, t))) } Ki(e, t) { if (kc(t)) return ua.resolve(null); let n = Oc(t); return this.indexManager.getIndexType(e, n).next((r => 0 === r ? null : (null !== t.limit && 1 === r && (t = Pc(t, null, "F"), n = Oc(t)), this.indexManager.getDocumentsMatchingTarget(e, n).next((r => { const i = Zc(...r); return this.Ui.getDocuments(e, i).next((r => this.indexManager.getMinOffset(e, n).next((n => { const s = this.ji(t, r); return this.zi(t, s, i, n.readTime) ? this.Ki(e, Pc(t, null, "F")) : this.Wi(e, s, t, n) })))) }))))) } Gi(e, t, n, r) { return kc(t) || r.isEqual(Ho.min()) ? this.Qi(e, t) : this.Ui.getDocuments(e, n).next((i => { const s = this.ji(t, i); return this.zi(t, s, n, r) ? this.Qi(e, t) : (Eo() <= Ve.DEBUG && So("QueryEngine", "Re-using previous result from %s to execute query: %s", r.toString(), Mc(t)), this.Wi(e, s, t, ra(r, -1))) })) } ji(e, t) { let n = new al(Bc(e)); return t.forEach(((t, r) => { jc(e, r) && (n = n.add(r)) })), n } zi(e, t, n, r) { if (null === e.limit) return !1; if (n.size !== t.size) return !0; const i = "F" === e.limitType ? t.last() : t.first(); return !!i && (i.hasPendingWrites || i.version.compareTo(r) > 0) } Qi(e, t) { return Eo() <= Ve.DEBUG && So("QueryEngine", "Using full collection scan to execute query:", Mc(t)), this.Ui.getDocumentsMatchingQuery(e, t, sa.min()) } Wi(e, t, n, r) { return this.Ui.getDocumentsMatchingQuery(e, n, r).next((e => (t.forEach((t => { e = e.insert(t.key, t) })), e))) } } class Df { constructor(e, t, n, r) { this.persistence = e, this.Hi = t, this.serializer = r, this.Ji = new il(zo), this.Yi = new zc((e => vc(e)), wc), this.Xi = new Map, this.Zi = e.getRemoteDocumentCache(), this.Bs = e.getTargetCache(), this.qs = e.getBundleCache(), this.tr(n) } tr(e) { this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new cf(this.Zi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Zi.setIndexManager(this.indexManager), this.Hi.initialize(this.localDocuments, this.indexManager) } collectGarbage(e) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (t => e.collect(t, this.Ji))) } } function Af(e, t, n, r) { return new Df(e, t, n, r) } async function Of(e, t) { const n = Co(e); return await n.persistence.runTransaction("Handle user change", "readonly", (e => { let r; return n.mutationQueue.getAllMutationBatches(e).next((i => (r = i, n.tr(t), n.mutationQueue.getAllMutationBatches(e)))).next((t => { const i = [], s = []; let o = Zc(); for (const e of r) { i.push(e.batchId); for (const t of e.mutations) o = o.add(t.key) } for (const e of t) { s.push(e.batchId); for (const t of e.mutations) o = o.add(t.key) } return n.localDocuments.getDocuments(e, o).next((e => ({ er: e, removedBatchIds: i, addedBatchIds: s }))) })) })) } function Rf(e) { const t = Co(e); return t.persistence.runTransaction("Get last remote snapshot version", "readonly", (e => t.Bs.getLastRemoteSnapshotVersion(e))) } function Pf(e, t, n) { let r = Zc(), i = Zc(); return n.forEach((e => r = r.add(e))), t.getEntries(e, r).next((e => { let r = Kc(); return n.forEach(((n, s) => { const o = e.get(n); s.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n)), s.isNoDocument() && s.version.isEqual(Ho.min()) ? (t.removeEntry(n, s.readTime), r = r.insert(n, s)) : !o.isValidDocument() || s.version.compareTo(o.version) > 0 || 0 === s.version.compareTo(o.version) && o.hasPendingWrites ? (t.addEntry(s), r = r.insert(n, s)) : So("LocalStore", "Ignoring outdated watch update for ", n, ". Current version:", o.version, " Watch version:", s.version) })), { nr: r, sr: i } })) } function Lf(e, t) { const n = Co(e); return n.persistence.runTransaction("Get next mutation batch", "readonly", (e => (void 0 === t && (t = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(e, t)))) } function Ff(e, t) { const n = Co(e); return n.persistence.runTransaction("Allocate target", "readwrite", (e => { let r; return n.Bs.getTargetData(e, t).next((i => i ? (r = i, ua.resolve(r)) : n.Bs.allocateTargetId(e).next((i => (r = new jh(t, i, "TargetPurposeListen", e.currentSequenceNumber), n.Bs.addTargetData(e, r).next((() => r))))))) })).then((e => { const r = n.Ji.get(e.targetId); return (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && (n.Ji = n.Ji.insert(e.targetId, e), n.Yi.set(t, e.targetId)), e })) } async function Mf(e, t, n) { const r = Co(e), i = r.Ji.get(t), s = n ? "readwrite" : "readwrite-primary"; try { n || await r.persistence.runTransaction("Release target", s, (e => r.persistence.referenceDelegate.removeTarget(e, i))) } catch (e) { if (!ma(e)) throw e; So("LocalStore", "Failed to update sequence numbers for target ".concat(t, ": ").concat(e)) } r.Ji = r.Ji.remove(t), r.Yi.delete(i.target) } function jf(e, t, n) { const r = Co(e); let i = Ho.min(), s = Zc(); return r.persistence.runTransaction("Execute query", "readonly", (e => function (e, t, n) { const r = Co(e), i = r.Yi.get(n); return void 0 !== i ? ua.resolve(r.Ji.get(i)) : r.Bs.getTargetData(t, n) }(r, e, Oc(t)).next((t => { if (t) return i = t.lastLimboFreeSnapshotVersion, r.Bs.getMatchingKeysForTargetId(e, t.targetId).next((e => { s = e })) })).next((() => r.Hi.getDocumentsMatchingQuery(e, t, n ? i : Ho.min(), n ? s : Zc()))).next((e => (Uf(r, Vc(t), e), { documents: e, ir: s }))))) } function Vf(e, t) { const n = Co(e), r = Co(n.Bs), i = n.Ji.get(t); return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (e => r.le(e, t).next((e => e ? e.target : null)))) } function Bf(e, t) { const n = Co(e), r = n.Xi.get(t) || Ho.min(); return n.persistence.runTransaction("Get new document changes", "readonly", (e => n.Zi.getAllFromCollectionGroup(e, t, ra(r, -1), Number.MAX_SAFE_INTEGER))).then((e => (Uf(n, t, e), e))) } function Uf(e, t, n) { let r = e.Xi.get(t) || Ho.min(); n.forEach(((e, t) => { t.readTime.compareTo(r) > 0 && (r = t.readTime) })), e.Xi.set(t, r) } async function zf(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Zc(); const r = await Ff(e, Oc(Qh(t.bundledQuery))), i = Co(e); return i.persistence.runTransaction("Save named query", "readwrite", (e => { const s = fh(t.readTime); if (r.snapshotVersion.compareTo(s) >= 0) return i.qs.saveNamedQuery(e, t); const o = r.withResumeToken(dl.EMPTY_BYTE_STRING, s); return i.Ji = i.Ji.insert(o.targetId, o), i.Bs.updateTargetData(e, o).next((() => i.Bs.removeMatchingKeysForTargetId(e, r.targetId))).next((() => i.Bs.addMatchingKeys(e, n, r.targetId))).next((() => i.qs.saveNamedQuery(e, t))) })) } function qf(e, t) { return "firestore_clients_".concat(e, "_").concat(t) } function Kf(e, t, n) { let r = "firestore_mutations_".concat(e, "_").concat(n); return t.isAuthenticated() && (r += "_".concat(t.uid)), r } function Gf(e, t) { return "firestore_targets_".concat(e, "_").concat(t) } class Hf { constructor(e, t, n, r) { this.user = e, this.batchId = t, this.state = n, this.error = r } static ar(e, t, n) { const r = JSON.parse(n); let i, s = "object" == typeof r && -1 !== ["pending", "acknowledged", "rejected"].indexOf(r.state) && (void 0 === r.error || "object" == typeof r.error); return s && r.error && (s = "string" == typeof r.error.message && "string" == typeof r.error.code, s && (i = new Do(r.error.code, r.error.message))), s ? new Hf(e, t, r.state, i) : (_o("SharedClientState", "Failed to parse mutation state for ID '".concat(t, "': ").concat(n)), null) } hr() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class Qf { constructor(e, t, n) { this.targetId = e, this.state = t, this.error = n } static ar(e, t) { const n = JSON.parse(t); let r, i = "object" == typeof n && -1 !== ["not-current", "current", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error); return i && n.error && (i = "string" == typeof n.error.message && "string" == typeof n.error.code, i && (r = new Do(n.error.code, n.error.message))), i ? new Qf(e, n.state, r) : (_o("SharedClientState", "Failed to parse target state for ID '".concat(e, "': ").concat(t)), null) } hr() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class Wf { constructor(e, t) { this.clientId = e, this.activeTargetIds = t } static ar(e, t) { const n = JSON.parse(t); let r = "object" == typeof n && n.activeTargetIds instanceof Array, i = tu(); for (let s = 0; r && s < n.activeTargetIds.length; ++s)r = Ia(n.activeTargetIds[s]), i = i.add(n.activeTargetIds[s]); return r ? new Wf(e, i) : (_o("SharedClientState", "Failed to parse client data for instance '".concat(e, "': ").concat(t)), null) } } class $f { constructor(e, t) { this.clientId = e, this.onlineState = t } static ar(e) { const t = JSON.parse(e); return "object" == typeof t && -1 !== ["Unknown", "Online", "Offline"].indexOf(t.onlineState) && "string" == typeof t.clientId ? new $f(t.clientId, t.onlineState) : (_o("SharedClientState", "Failed to parse online state: ".concat(e)), null) } } class Xf { constructor() { this.activeTargetIds = tu() } lr(e) { this.activeTargetIds = this.activeTargetIds.add(e) } dr(e) { this.activeTargetIds = this.activeTargetIds.delete(e) } hr() { const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(e) } } class Yf { constructor(e, t, n, r, i) { this.window = e, this.ii = t, this.persistenceKey = n, this.wr = r, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this._r = this.mr.bind(this), this.gr = new il(zo), this.started = !1, this.yr = []; const s = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); this.storage = this.window.localStorage, this.currentUser = i, this.pr = qf(this.persistenceKey, this.wr), this.Ir = function (e) { return "firestore_sequence_number_".concat(e) }(this.persistenceKey), this.gr = this.gr.insert(this.wr, new Xf), this.Tr = new RegExp("^firestore_clients_".concat(s, "_([^_]*)$")), this.Er = new RegExp("^firestore_mutations_".concat(s, "_(\\d+)(?:_(.*))?$")), this.Ar = new RegExp("^firestore_targets_".concat(s, "_(\\d+)$")), this.vr = function (e) { return "firestore_online_state_".concat(e) }(this.persistenceKey), this.Rr = function (e) { return "firestore_bundle_loaded_v2_".concat(e) }(this.persistenceKey), this.window.addEventListener("storage", this._r) } static D(e) { return !(!e || !e.localStorage) } async start() { const e = await this.syncEngine.$i(); for (const n of e) { if (n === this.wr) continue; const e = this.getItem(qf(this.persistenceKey, n)); if (e) { const t = Wf.ar(n, e); t && (this.gr = this.gr.insert(t.clientId, t)) } } this.Pr(); const t = this.storage.getItem(this.vr); if (t) { const e = this.br(t); e && this.Vr(e) } for (const n of this.yr) this.mr(n); this.yr = [], this.window.addEventListener("pagehide", (() => this.shutdown())), this.started = !0 } writeSequenceNumber(e) { this.setItem(this.Ir, JSON.stringify(e)) } getAllActiveQueryTargets() { return this.Sr(this.gr) } isActiveQueryTarget(e) { let t = !1; return this.gr.forEach(((n, r) => { r.activeTargetIds.has(e) && (t = !0) })), t } addPendingMutation(e) { this.Dr(e, "pending") } updateMutationState(e, t, n) { this.Dr(e, t, n), this.Cr(e) } addLocalQueryTarget(e) { let t = "not-current"; if (this.isActiveQueryTarget(e)) { const n = this.storage.getItem(Gf(this.persistenceKey, e)); if (n) { const r = Qf.ar(e, n); r && (t = r.state) } } return this.Nr.lr(e), this.Pr(), t } removeLocalQueryTarget(e) { this.Nr.dr(e), this.Pr() } isLocalQueryTarget(e) { return this.Nr.activeTargetIds.has(e) } clearQueryState(e) { this.removeItem(Gf(this.persistenceKey, e)) } updateQueryState(e, t, n) { this.kr(e, t, n) } handleUserChange(e, t, n) { t.forEach((e => { this.Cr(e) })), this.currentUser = e, n.forEach((e => { this.addPendingMutation(e) })) } setOnlineState(e) { this.Mr(e) } notifyBundleLoaded(e) { this.$r(e) } shutdown() { this.started && (this.window.removeEventListener("storage", this._r), this.removeItem(this.pr), this.started = !1) } getItem(e) { const t = this.storage.getItem(e); return So("SharedClientState", "READ", e, t), t } setItem(e, t) { So("SharedClientState", "SET", e, t), this.storage.setItem(e, t) } removeItem(e) { So("SharedClientState", "REMOVE", e), this.storage.removeItem(e) } mr(e) { const t = e; if (t.storageArea === this.storage) { if (So("SharedClientState", "EVENT", t.key, t.newValue), t.key === this.pr) return void _o("Received WebStorage notification for local change. Another client might have garbage-collected our state"); this.ii.enqueueRetryable((async () => { if (this.started) { if (null !== t.key) if (this.Tr.test(t.key)) { if (null == t.newValue) { const e = this.Or(t.key); return this.Fr(e, null) } { const e = this.Br(t.key, t.newValue); if (e) return this.Fr(e.clientId, e) } } else if (this.Er.test(t.key)) { if (null !== t.newValue) { const e = this.Lr(t.key, t.newValue); if (e) return this.qr(e) } } else if (this.Ar.test(t.key)) { if (null !== t.newValue) { const e = this.Ur(t.key, t.newValue); if (e) return this.Kr(e) } } else if (t.key === this.vr) { if (null !== t.newValue) { const e = this.br(t.newValue); if (e) return this.Vr(e) } } else if (t.key === this.Ir) { const e = function (e) { let t = Sa.ct; if (null != e) try { const n = JSON.parse(e); ko("number" == typeof n), t = n } catch (e) { _o("SharedClientState", "Failed to read sequence number from WebStorage", e) } return t }(t.newValue); e !== Sa.ct && this.sequenceNumberHandler(e) } else if (t.key === this.Rr) { const e = this.Gr(t.newValue); await Promise.all(e.map((e => this.syncEngine.Qr(e)))) } } else this.yr.push(t) })) } } get Nr() { return this.gr.get(this.wr) } Pr() { this.setItem(this.pr, this.Nr.hr()) } Dr(e, t, n) { const r = new Hf(this.currentUser, e, t, n), i = Kf(this.persistenceKey, this.currentUser, e); this.setItem(i, r.hr()) } Cr(e) { const t = Kf(this.persistenceKey, this.currentUser, e); this.removeItem(t) } Mr(e) { const t = { clientId: this.wr, onlineState: e }; this.storage.setItem(this.vr, JSON.stringify(t)) } kr(e, t, n) { const r = Gf(this.persistenceKey, e), i = new Qf(e, t, n); this.setItem(r, i.hr()) } $r(e) { const t = JSON.stringify(Array.from(e)); this.setItem(this.Rr, t) } Or(e) { const t = this.Tr.exec(e); return t ? t[1] : null } Br(e, t) { const n = this.Or(e); return Wf.ar(n, t) } Lr(e, t) { const n = this.Er.exec(e), r = Number(n[1]), i = void 0 !== n[2] ? n[2] : null; return Hf.ar(new vo(i), r, t) } Ur(e, t) { const n = this.Ar.exec(e), r = Number(n[1]); return Qf.ar(r, t) } br(e) { return $f.ar(e) } Gr(e) { return JSON.parse(e) } async qr(e) { if (e.user.uid === this.currentUser.uid) return this.syncEngine.jr(e.batchId, e.state, e.error); So("SharedClientState", "Ignoring mutation for non-active user ".concat(e.user.uid)) } Kr(e) { return this.syncEngine.zr(e.targetId, e.state, e.error) } Fr(e, t) { const n = t ? this.gr.insert(e, t) : this.gr.remove(e), r = this.Sr(this.gr), i = this.Sr(n), s = [], o = []; return i.forEach((e => { r.has(e) || s.push(e) })), r.forEach((e => { i.has(e) || o.push(e) })), this.syncEngine.Wr(s, o).then((() => { this.gr = n })) } Vr(e) { this.gr.get(e.clientId) && this.onlineStateHandler(e.onlineState) } Sr(e) { let t = tu(); return e.forEach(((e, n) => { t = t.unionWith(n.activeTargetIds) })), t } } class Jf { constructor() { this.Hr = new Xf, this.Jr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(e) { } updateMutationState(e, t, n) { } addLocalQueryTarget(e) { return this.Hr.lr(e), this.Jr[e] || "not-current" } updateQueryState(e, t, n) { this.Jr[e] = t } removeLocalQueryTarget(e) { this.Hr.dr(e) } isLocalQueryTarget(e) { return this.Hr.activeTargetIds.has(e) } clearQueryState(e) { delete this.Jr[e] } getAllActiveQueryTargets() { return this.Hr.activeTargetIds } isActiveQueryTarget(e) { return this.Hr.activeTargetIds.has(e) } start() { return this.Hr = new Xf, Promise.resolve() } handleUserChange(e, t, n) { } setOnlineState(e) { } shutdown() { } writeSequenceNumber(e) { } notifyBundleLoaded(e) { } } class Zf { Yr(e) { } shutdown() { } } class ep { constructor() { this.Xr = () => this.Zr(), this.eo = () => this.no(), this.so = [], this.io() } Yr(e) { this.so.push(e) } shutdown() { window.removeEventListener("online", this.Xr), window.removeEventListener("offline", this.eo) } io() { window.addEventListener("online", this.Xr), window.addEventListener("offline", this.eo) } Zr() { So("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"); for (const e of this.so) e(0) } no() { So("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"); for (const e of this.so) e(1) } static D() { return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener } } let tp = null; function np() { return null === tp ? tp = 268435456 + Math.round(2147483648 * Math.random()) : tp++, "0x" + tp.toString(16) } const rp = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery", RunAggregationQuery: "runAggregationQuery" }; class ip { constructor(e) { this.ro = e.ro, this.oo = e.oo } uo(e) { this.co = e } ao(e) { this.ho = e } onMessage(e) { this.lo = e } close() { this.oo() } send(e) { this.ro(e) } fo() { this.co() } wo(e) { this.ho(e) } _o(e) { this.lo(e) } } const sp = "WebChannelConnection"; class op extends class { constructor(e) { this.databaseInfo = e, this.databaseId = e.databaseId; const t = e.ssl ? "https" : "http"; this.mo = t + "://" + e.host, this.yo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents" } get po() { return !1 } Io(e, t, n, r, i) { const s = np(), o = this.To(e, t); So("RestConnection", "Sending RPC '".concat(e, "' ").concat(s, ":"), o, n); const a = {}; return this.Eo(a, r, i), this.Ao(e, o, a, n).then((t => (So("RestConnection", "Received RPC '".concat(e, "' ").concat(s, ": "), t), t)), (t => { throw xo("RestConnection", "RPC '".concat(e, "' ").concat(s, " failed with error: "), t, "url: ", o, "request:", n), t })) } vo(e, t, n, r, i, s) { return this.Io(e, t, n, r, i) } Eo(e, t, n) { e["X-Goog-Api-Client"] = "gl-js/ fire/" + wo, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach(((t, n) => e[n] = t)), n && n.headers.forEach(((t, n) => e[n] = t)) } To(e, t) { const n = rp[e]; return "".concat(this.mo, "/v1/").concat(t, ":").concat(n) } }{ constructor(e) { super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams, this.longPollingOptions = e.longPollingOptions } Ao(e, t, n, r) { const i = np(); return new Promise(((s, o) => { const a = new po; a.setWithCredentials(!0), a.listenOnce(lo.COMPLETE, (() => { try { switch (a.getLastErrorCode()) { case ao.NO_ERROR: const t = a.getResponseJson(); So(sp, "XHR for RPC '".concat(e, "' ").concat(i, " received:"), JSON.stringify(t)), s(t); break; case ao.TIMEOUT: So(sp, "RPC '".concat(e, "' ").concat(i, " timed out")), o(new Do(No.DEADLINE_EXCEEDED, "Request time out")); break; case ao.HTTP_ERROR: const n = a.getStatus(); if (So(sp, "RPC '".concat(e, "' ").concat(i, " failed with status:"), n, "response text:", a.getResponseText()), n > 0) { let e = a.getResponseJson(); Array.isArray(e) && (e = e[0]); const t = null == e ? void 0 : e.error; if (t && t.status && t.message) { const e = function (e) { const t = e.toLowerCase().replace(/_/g, "-"); return Object.values(No).indexOf(t) >= 0 ? t : No.UNKNOWN }(t.status); o(new Do(e, t.message)) } else o(new Do(No.UNKNOWN, "Server responded with status " + a.getStatus())) } else o(new Do(No.UNAVAILABLE, "Connection failed.")); break; default: To() } } finally { So(sp, "RPC '".concat(e, "' ").concat(i, " completed.")) } })); const l = JSON.stringify(r); So(sp, "RPC '".concat(e, "' ").concat(i, " sending request:"), r), a.send(t, "POST", l, n, 15) })) } Ro(e, t, n) { const r = np(), i = [this.mo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], s = so(), o = oo(), a = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: "projects/".concat(this.databaseId.projectId, "/databases/").concat(this.databaseId.database) }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }, l = this.longPollingOptions.timeoutSeconds; void 0 !== l && (a.longPollingTimeout = Math.round(1e3 * l)), this.useFetchStreams && (a.xmlHttpFactory = new ho({})), this.Eo(a.initMessageHeaders, t, n), a.encodeInitMessageHeaders = !0; const c = i.join(""); So(sp, "Creating RPC '".concat(e, "' stream ").concat(r, ": ").concat(c), a); const u = s.createWebChannel(c, a); let h = !1, d = !1; const f = new ip({ ro: t => { d ? So(sp, "Not sending because RPC '".concat(e, "' stream ").concat(r, " is closed:"), t) : (h || (So(sp, "Opening RPC '".concat(e, "' stream ").concat(r, " transport.")), u.open(), h = !0), So(sp, "RPC '".concat(e, "' stream ").concat(r, " sending:"), t), u.send(t)) }, oo: () => u.close() }), p = (e, t, n) => { e.listen(t, (e => { try { n(e) } catch (e) { setTimeout((() => { throw e }), 0) } })) }; return p(u, fo.EventType.OPEN, (() => { d || So(sp, "RPC '".concat(e, "' stream ").concat(r, " transport opened.")) })), p(u, fo.EventType.CLOSE, (() => { d || (d = !0, So(sp, "RPC '".concat(e, "' stream ").concat(r, " transport closed")), f.wo()) })), p(u, fo.EventType.ERROR, (t => { d || (d = !0, xo(sp, "RPC '".concat(e, "' stream ").concat(r, " transport errored:"), t), f.wo(new Do(No.UNAVAILABLE, "The operation could not be completed"))) })), p(u, fo.EventType.MESSAGE, (t => { var n; if (!d) { const i = t.data[0]; ko(!!i); const s = i, o = s.error || (null === (n = s[0]) || void 0 === n ? void 0 : n.error); if (o) { So(sp, "RPC '".concat(e, "' stream ").concat(r, " received error:"), o); const t = o.status; let n = function (e) { const t = ju[e]; if (void 0 !== t) return Uu(t) }(t), i = o.message; void 0 === n && (n = No.INTERNAL, i = "Unknown error status: " + t + " with message " + o.message), d = !0, f.wo(new Do(n, i)), u.close() } else So(sp, "RPC '".concat(e, "' stream ").concat(r, " received:"), i), f._o(i) } })), p(o, co.STAT_EVENT, (t => { t.stat === uo.PROXY ? So(sp, "RPC '".concat(e, "' stream ").concat(r, " detected buffering proxy")) : t.stat === uo.NOPROXY && So(sp, "RPC '".concat(e, "' stream ").concat(r, " detected no buffering proxy")) })), setTimeout((() => { f.fo() }), 0), f } } function ap() { return "undefined" != typeof window ? window : null } function lp() { return "undefined" != typeof document ? document : null } function cp(e) { return new lh(e, !0) } class up { constructor(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1.5, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 6e4; this.ii = e, this.timerId = t, this.Po = n, this.bo = r, this.Vo = i, this.So = 0, this.Do = null, this.Co = Date.now(), this.reset() } reset() { this.So = 0 } xo() { this.So = this.Vo } No(e) { this.cancel(); const t = Math.floor(this.So + this.ko()), n = Math.max(0, Date.now() - this.Co), r = Math.max(0, t - n); r > 0 && So("ExponentialBackoff", "Backing off for ".concat(r, " ms (base delay: ").concat(this.So, " ms, delay with jitter: ").concat(t, " ms, last attempt: ").concat(n, " ms ago)")), this.Do = this.ii.enqueueAfterDelay(this.timerId, r, (() => (this.Co = Date.now(), e()))), this.So *= this.bo, this.So < this.Po && (this.So = this.Po), this.So > this.Vo && (this.So = this.Vo) } Mo() { null !== this.Do && (this.Do.skipDelay(), this.Do = null) } cancel() { null !== this.Do && (this.Do.cancel(), this.Do = null) } ko() { return (Math.random() - .5) * this.So } } class hp { constructor(e, t, n, r, i, s, o, a) { this.ii = e, this.$o = n, this.Oo = r, this.connection = i, this.authCredentialsProvider = s, this.appCheckCredentialsProvider = o, this.listener = a, this.state = 0, this.Fo = 0, this.Bo = null, this.Lo = null, this.stream = null, this.qo = new up(e, t) } Uo() { return 1 === this.state || 5 === this.state || this.Ko() } Ko() { return 2 === this.state || 3 === this.state } start() { 4 !== this.state ? this.auth() : this.Go() } async stop() { this.Uo() && await this.close(0) } Qo() { this.state = 0, this.qo.reset() } jo() { this.Ko() && null === this.Bo && (this.Bo = this.ii.enqueueAfterDelay(this.$o, 6e4, (() => this.zo()))) } Wo(e) { this.Ho(), this.stream.send(e) } async zo() { if (this.Ko()) return this.close(0) } Ho() { this.Bo && (this.Bo.cancel(), this.Bo = null) } Jo() { this.Lo && (this.Lo.cancel(), this.Lo = null) } async close(e, t) { this.Ho(), this.Jo(), this.qo.cancel(), this.Fo++, 4 !== e ? this.qo.reset() : t && t.code === No.RESOURCE_EXHAUSTED ? (_o(t.toString()), _o("Using maximum backoff delay to prevent overloading the backend."), this.qo.xo()) : t && t.code === No.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.Yo(), this.stream.close(), this.stream = null), this.state = e, await this.listener.ao(t) } Yo() { } auth() { this.state = 1; const e = this.Xo(this.Fo), t = this.Fo; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then((e => { let [n, r] = e; this.Fo === t && this.Zo(n, r) }), (t => { e((() => { const e = new Do(No.UNKNOWN, "Fetching auth token failed: " + t.message); return this.tu(e) })) })) } Zo(e, t) { const n = this.Xo(this.Fo); this.stream = this.eu(e, t), this.stream.uo((() => { n((() => (this.state = 2, this.Lo = this.ii.enqueueAfterDelay(this.Oo, 1e4, (() => (this.Ko() && (this.state = 3), Promise.resolve()))), this.listener.uo()))) })), this.stream.ao((e => { n((() => this.tu(e))) })), this.stream.onMessage((e => { n((() => this.onMessage(e))) })) } Go() { this.state = 5, this.qo.No((async () => { this.state = 0, this.start() })) } tu(e) { return So("PersistentStream", "close with error: ".concat(e)), this.stream = null, this.close(4, e) } Xo(e) { return t => { this.ii.enqueueAndForget((() => this.Fo === e ? t() : (So("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()))) } } } class dp extends hp { constructor(e, t, n, r, i, s) { super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, n, r, s), this.serializer = i } eu(e, t) { return this.connection.Ro("Listen", e, t) } onMessage(e) { this.qo.reset(); const t = function (e, t) { let n; if ("targetChange" in t) { t.targetChange; const r = function (e) { return "NO_CHANGE" === e ? 0 : "ADD" === e ? 1 : "REMOVE" === e ? 2 : "CURRENT" === e ? 3 : "RESET" === e ? 4 : To() }(t.targetChange.targetChangeType || "NO_CHANGE"), i = t.targetChange.targetIds || [], s = function (e, t) { return e.useProto3Json ? (ko(void 0 === t || "string" == typeof t), dl.fromBase64String(t || "")) : (ko(void 0 === t || t instanceof Uint8Array), dl.fromUint8Array(t || new Uint8Array)) }(e, t.targetChange.resumeToken), o = t.targetChange.cause, a = o && function (e) { const t = void 0 === e.code ? No.UNKNOWN : Uu(e.code); return new Do(t, e.message || "") }(o); n = new eh(r, i, s, a || null) } else if ("documentChange" in t) { t.documentChange; const r = t.documentChange; r.document, r.document.name, r.document.updateTime; const i = yh(e, r.document.name), s = fh(r.document.updateTime), o = r.document.createTime ? fh(r.document.createTime) : Ho.min(), a = new ql({ mapValue: { fields: r.document.fields } }), l = Gl.newFoundDocument(i, s, o, a), c = r.targetIds || [], u = r.removedTargetIds || []; n = new Ju(c, u, l.key, l) } else if ("documentDelete" in t) { t.documentDelete; const r = t.documentDelete; r.document; const i = yh(e, r.document), s = r.readTime ? fh(r.readTime) : Ho.min(), o = Gl.newNoDocument(i, s), a = r.removedTargetIds || []; n = new Ju([], a, o.key, o) } else if ("documentRemove" in t) { t.documentRemove; const r = t.documentRemove; r.document; const i = yh(e, r.document), s = r.removedTargetIds || []; n = new Ju([], s, i, null) } else { if (!("filter" in t)) return To(); { t.filter; const e = t.filter; e.targetId; const { count: r = 0, unchangedNames: i } = e, s = new Mu(r, i), o = e.targetId; n = new Zu(o, s) } } return n }(this.serializer, e), n = function (e) { if (!("targetChange" in e)) return Ho.min(); const t = e.targetChange; return t.targetIds && t.targetIds.length ? Ho.min() : t.readTime ? fh(t.readTime) : Ho.min() }(e); return this.listener.nu(t, n) } su(e) { const t = {}; t.database = bh(this.serializer), t.addTarget = function (e, t) { let n; const r = t.target; if (n = bc(r) ? { documents: Th(e, r) } : { query: kh(e, r) }, n.targetId = t.targetId, t.resumeToken.approximateByteSize() > 0) { n.resumeToken = hh(e, t.resumeToken); const r = ch(e, t.expectedCount); null !== r && (n.expectedCount = r) } else if (t.snapshotVersion.compareTo(Ho.min()) > 0) { n.readTime = uh(e, t.snapshotVersion.toTimestamp()); const r = ch(e, t.expectedCount); null !== r && (n.expectedCount = r) } return n }(this.serializer, e); const n = function (e, t) { const n = function (e) { switch (e) { case "TargetPurposeListen": return null; case "TargetPurposeExistenceFilterMismatch": return "existence-filter-mismatch"; case "TargetPurposeExistenceFilterMismatchBloom": return "existence-filter-mismatch-bloom"; case "TargetPurposeLimboResolution": return "limbo-document"; default: return To() } }(t.purpose); return null == n ? null : { "goog-listen-tags": n } }(this.serializer, e); n && (t.labels = n), this.Wo(t) } iu(e) { const t = {}; t.database = bh(this.serializer), t.removeTarget = e, this.Wo(t) } } class fp extends hp { constructor(e, t, n, r, i, s) { super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, n, r, s), this.serializer = i, this.ru = !1 } get ou() { return this.ru } start() { this.ru = !1, this.lastStreamToken = void 0, super.start() } Yo() { this.ru && this.uu([]) } eu(e, t) { return this.connection.Ro("Write", e, t) } onMessage(e) { if (ko(!!e.streamToken), this.lastStreamToken = e.streamToken, this.ru) { this.qo.reset(); const t = function (e, t) { return e && e.length > 0 ? (ko(void 0 !== t), e.map((e => function (e, t) { let n = e.updateTime ? fh(e.updateTime) : fh(t); return n.isEqual(Ho.min()) && (n = fh(t)), new vu(n, e.transformResults || []) }(e, t)))) : [] }(e.writeResults, e.commitTime), n = fh(e.commitTime); return this.listener.cu(n, t) } return ko(!e.writeResults || 0 === e.writeResults.length), this.ru = !0, this.listener.au() } hu() { const e = {}; e.database = bh(this.serializer), this.Wo(e) } uu(e) { const t = { streamToken: this.lastStreamToken, writes: e.map((e => xh(this.serializer, e))) }; this.Wo(t) } } class pp extends class { }{ constructor(e, t, n, r) { super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = n, this.serializer = r, this.lu = !1 } fu() { if (this.lu) throw new Do(No.FAILED_PRECONDITION, "The client has already been terminated.") } Io(e, t, n) { return this.fu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((r => { let [i, s] = r; return this.connection.Io(e, t, n, i, s) })).catch((e => { throw "FirebaseError" === e.name ? (e.code === No.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e) : new Do(No.UNKNOWN, e.toString()) })) } vo(e, t, n, r) { return this.fu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((i => { let [s, o] = i; return this.connection.vo(e, t, n, s, o, r) })).catch((e => { throw "FirebaseError" === e.name ? (e.code === No.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e) : new Do(No.UNKNOWN, e.toString()) })) } terminate() { this.lu = !0 } } class mp { constructor(e, t) { this.asyncQueue = e, this.onlineStateHandler = t, this.state = "Unknown", this.wu = 0, this._u = null, this.mu = !0 } gu() { 0 === this.wu && (this.yu("Unknown"), this._u = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, (() => (this._u = null, this.pu("Backend didn't respond within 10 seconds."), this.yu("Offline"), Promise.resolve())))) } Iu(e) { "Online" === this.state ? this.yu("Unknown") : (this.wu++, this.wu >= 1 && (this.Tu(), this.pu("Connection failed 1 times. Most recent error: ".concat(e.toString())), this.yu("Offline"))) } set(e) { this.Tu(), this.wu = 0, "Online" === e && (this.mu = !1), this.yu(e) } yu(e) { e !== this.state && (this.state = e, this.onlineStateHandler(e)) } pu(e) { const t = "Could not reach Cloud Firestore backend. ".concat(e, "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend."); this.mu ? (_o(t), this.mu = !1) : So("OnlineStateTracker", t) } Tu() { null !== this._u && (this._u.cancel(), this._u = null) } } class gp { constructor(e, t, n, r, i) { this.localStore = e, this.datastore = t, this.asyncQueue = n, this.remoteSyncer = {}, this.Eu = [], this.Au = new Map, this.vu = new Set, this.Ru = [], this.Pu = i, this.Pu.Yr((e => { n.enqueueAndForget((async () => { Ip(this) && (So("RemoteStore", "Restarting streams for network reachability change."), await async function (e) { const t = Co(e); t.vu.add(4), await vp(t), t.bu.set("Unknown"), t.vu.delete(4), await yp(t) }(this)) })) })), this.bu = new mp(n, r) } } async function yp(e) { if (Ip(e)) for (const t of e.Ru) await t(!0) } async function vp(e) { for (const t of e.Ru) await t(!1) } function wp(e, t) { const n = Co(e); n.Au.has(t.targetId) || (n.Au.set(t.targetId, t), xp(n) ? _p(n) : qp(n).Ko() && Ep(n, t)) } function bp(e, t) { const n = Co(e), r = qp(n); n.Au.delete(t), r.Ko() && Sp(n, t), 0 === n.Au.size && (r.Ko() ? r.jo() : Ip(n) && n.bu.set("Unknown")) } function Ep(e, t) { if (e.Vu.qt(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(Ho.min()) > 0) { const n = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size; t = t.withExpectedCount(n) } qp(e).su(t) } function Sp(e, t) { e.Vu.qt(t), qp(e).iu(t) } function _p(e) { e.Vu = new nh({ getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t), le: t => e.Au.get(t) || null, ue: () => e.datastore.serializer.databaseId }), qp(e).start(), e.bu.gu() } function xp(e) { return Ip(e) && !qp(e).Uo() && e.Au.size > 0 } function Ip(e) { return 0 === Co(e).vu.size } function Tp(e) { e.Vu = void 0 } async function kp(e) { e.Au.forEach(((t, n) => { Ep(e, t) })) } async function Cp(e, t) { Tp(e), xp(e) ? (e.bu.Iu(t), _p(e)) : e.bu.set("Unknown") } async function Np(e, t, n) { if (e.bu.set("Online"), t instanceof eh && 2 === t.state && t.cause) try { await async function (e, t) { const n = t.cause; for (const r of t.targetIds) e.Au.has(r) && (await e.remoteSyncer.rejectListen(r, n), e.Au.delete(r), e.Vu.removeTarget(r)) }(e, t) } catch (n) { So("RemoteStore", "Failed to remove targets %s: %s ", t.targetIds.join(","), n), await Dp(e, n) } else if (t instanceof Ju ? e.Vu.Ht(t) : t instanceof Zu ? e.Vu.ne(t) : e.Vu.Xt(t), !n.isEqual(Ho.min())) try { const t = await Rf(e.localStore); n.compareTo(t) >= 0 && await function (e, t) { const n = e.Vu.ce(t); return n.targetChanges.forEach(((n, r) => { if (n.resumeToken.approximateByteSize() > 0) { const i = e.Au.get(r); i && e.Au.set(r, i.withResumeToken(n.resumeToken, t)) } })), n.targetMismatches.forEach(((t, n) => { const r = e.Au.get(t); if (!r) return; e.Au.set(t, r.withResumeToken(dl.EMPTY_BYTE_STRING, r.snapshotVersion)), Sp(e, t); const i = new jh(r.target, t, n, r.sequenceNumber); Ep(e, i) })), e.remoteSyncer.applyRemoteEvent(n) }(e, n) } catch (t) { So("RemoteStore", "Failed to raise snapshot:", t), await Dp(e, t) } } async function Dp(e, t, n) { if (!ma(t)) throw t; e.vu.add(1), await vp(e), e.bu.set("Offline"), n || (n = () => Rf(e.localStore)), e.asyncQueue.enqueueRetryable((async () => { So("RemoteStore", "Retrying IndexedDB access"), await n(), e.vu.delete(1), await yp(e) })) } function Ap(e, t) { return t().catch((n => Dp(e, n, t))) } async function Op(e) { const t = Co(e), n = Kp(t); let r = t.Eu.length > 0 ? t.Eu[t.Eu.length - 1].batchId : -1; for (; Rp(t);)try { const e = await Lf(t.localStore, r); if (null === e) { 0 === t.Eu.length && n.jo(); break } r = e.batchId, Pp(t, e) } catch (e) { await Dp(t, e) } Lp(t) && Fp(t) } function Rp(e) { return Ip(e) && e.Eu.length < 10 } function Pp(e, t) { e.Eu.push(t); const n = Kp(e); n.Ko() && n.ou && n.uu(t.mutations) } function Lp(e) { return Ip(e) && !Kp(e).Uo() && e.Eu.length > 0 } function Fp(e) { Kp(e).start() } async function Mp(e) { Kp(e).hu() } async function jp(e) { const t = Kp(e); for (const n of e.Eu) t.uu(n.mutations) } async function Vp(e, t, n) { const r = e.Eu.shift(), i = Lu.from(r, t, n); await Ap(e, (() => e.remoteSyncer.applySuccessfulWrite(i))), await Op(e) } async function Bp(e, t) { t && Kp(e).ou && await async function (e, t) { if (Bu(n = t.code) && n !== No.ABORTED) { const n = e.Eu.shift(); Kp(e).Qo(), await Ap(e, (() => e.remoteSyncer.rejectFailedWrite(n.batchId, t))), await Op(e) } var n }(e, t), Lp(e) && Fp(e) } async function Up(e, t) { const n = Co(e); n.asyncQueue.verifyOperationInProgress(), So("RemoteStore", "RemoteStore received new credentials"); const r = Ip(n); n.vu.add(3), await vp(n), r && n.bu.set("Unknown"), await n.remoteSyncer.handleCredentialChange(t), n.vu.delete(3), await yp(n) } async function zp(e, t) { const n = Co(e); t ? (n.vu.delete(2), await yp(n)) : t || (n.vu.add(2), await vp(n), n.bu.set("Unknown")) } function qp(e) { return e.Su || (e.Su = function (e, t, n) { const r = Co(e); return r.fu(), new dp(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n) }(e.datastore, e.asyncQueue, { uo: kp.bind(null, e), ao: Cp.bind(null, e), nu: Np.bind(null, e) }), e.Ru.push((async t => { t ? (e.Su.Qo(), xp(e) ? _p(e) : e.bu.set("Unknown")) : (await e.Su.stop(), Tp(e)) }))), e.Su } function Kp(e) { return e.Du || (e.Du = function (e, t, n) { const r = Co(e); return r.fu(), new fp(t, r.connection, r.authCredentials, r.appCheckCredentials, r.serializer, n) }(e.datastore, e.asyncQueue, { uo: Mp.bind(null, e), ao: Bp.bind(null, e), au: jp.bind(null, e), cu: Vp.bind(null, e) }), e.Ru.push((async t => { t ? (e.Du.Qo(), await Op(e)) : (await e.Du.stop(), e.Eu.length > 0 && (So("RemoteStore", "Stopping write stream with ".concat(e.Eu.length, " pending writes")), e.Eu = [])) }))), e.Du } class Gp { constructor(e, t, n, r, i) { this.asyncQueue = e, this.timerId = t, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new Ao, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((e => { })) } static createAndSchedule(e, t, n, r, i) { const s = Date.now() + n, o = new Gp(e, t, s, r, i); return o.start(n), o } start(e) { this.timerHandle = setTimeout((() => this.handleDelayElapsed()), e) } skipDelay() { return this.handleDelayElapsed() } cancel(e) { null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new Do(No.CANCELLED, "Operation cancelled" + (e ? ": " + e : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget((() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((e => this.deferred.resolve(e)))) : Promise.resolve())) } clearTimeout() { null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function Hp(e, t) { if (_o("AsyncQueue", "".concat(t, ": ").concat(e)), ma(e)) return new Do(No.UNAVAILABLE, "".concat(t, ": ").concat(e)); throw e } class Qp { constructor(e) { this.comparator = e ? (t, n) => e(t, n) || Yo.comparator(t.key, n.key) : (e, t) => Yo.comparator(e.key, t.key), this.keyedMap = Hc(), this.sortedSet = new il(this.comparator) } static emptySet(e) { return new Qp(e.comparator) } has(e) { return null != this.keyedMap.get(e) } get(e) { return this.keyedMap.get(e) } first() { return this.sortedSet.minKey() } last() { return this.sortedSet.maxKey() } isEmpty() { return this.sortedSet.isEmpty() } indexOf(e) { const t = this.keyedMap.get(e); return t ? this.sortedSet.indexOf(t) : -1 } get size() { return this.sortedSet.size } forEach(e) { this.sortedSet.inorderTraversal(((t, n) => (e(t), !1))) } add(e) { const t = this.delete(e.key); return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null)) } delete(e) { const t = this.get(e); return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this } isEqual(e) { if (!(e instanceof Qp)) return !1; if (this.size !== e.size) return !1; const t = this.sortedSet.getIterator(), n = e.sortedSet.getIterator(); for (; t.hasNext();) { const e = t.getNext().key, r = n.getNext().key; if (!e.isEqual(r)) return !1 } return !0 } toString() { const e = []; return this.forEach((t => { e.push(t.toString()) })), 0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)" } copy(e, t) { const n = new Qp; return n.comparator = this.comparator, n.keyedMap = e, n.sortedSet = t, n } } class Wp { constructor() { this.Cu = new il(Yo.comparator) } track(e) { const t = e.doc.key, n = this.Cu.get(t); n ? 0 !== e.type && 3 === n.type ? this.Cu = this.Cu.insert(t, e) : 3 === e.type && 1 !== n.type ? this.Cu = this.Cu.insert(t, { type: n.type, doc: e.doc }) : 2 === e.type && 2 === n.type ? this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }) : 2 === e.type && 0 === n.type ? this.Cu = this.Cu.insert(t, { type: 0, doc: e.doc }) : 1 === e.type && 0 === n.type ? this.Cu = this.Cu.remove(t) : 1 === e.type && 2 === n.type ? this.Cu = this.Cu.insert(t, { type: 1, doc: n.doc }) : 0 === e.type && 1 === n.type ? this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }) : To() : this.Cu = this.Cu.insert(t, e) } xu() { const e = []; return this.Cu.inorderTraversal(((t, n) => { e.push(n) })), e } } class $p { constructor(e, t, n, r, i, s, o, a, l) { this.query = e, this.docs = t, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = s, this.syncStateChanged = o, this.excludesMetadataChanges = a, this.hasCachedResults = l } static fromInitialDocuments(e, t, n, r, i) { const s = []; return t.forEach((e => { s.push({ type: 0, doc: e }) })), new $p(e, t, Qp.emptySet(t), s, n, r, !0, !1, i) } get hasPendingWrites() { return !this.mutatedKeys.isEmpty() } isEqual(e) { if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && Lc(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1; const t = this.docChanges, n = e.docChanges; if (t.length !== n.length) return !1; for (let r = 0; r < t.length; r++)if (t[r].type !== n[r].type || !t[r].doc.isEqual(n[r].doc)) return !1; return !0 } } class Xp { constructor() { this.Nu = void 0, this.listeners = [] } } class Yp { constructor() { this.queries = new zc((e => Fc(e)), Lc), this.onlineState = "Unknown", this.ku = new Set } } async function Jp(e, t) { const n = Co(e), r = t.query; let i = !1, s = n.queries.get(r); if (s || (i = !0, s = new Xp), i) try { s.Nu = await n.onListen(r) } catch (e) { const n = Hp(e, "Initialization of query '".concat(Mc(t.query), "' failed")); return void t.onError(n) } n.queries.set(r, s), s.listeners.push(t), t.Mu(n.onlineState), s.Nu && t.$u(s.Nu) && nm(n) } async function Zp(e, t) { const n = Co(e), r = t.query; let i = !1; const s = n.queries.get(r); if (s) { const e = s.listeners.indexOf(t); e >= 0 && (s.listeners.splice(e, 1), i = 0 === s.listeners.length) } if (i) return n.queries.delete(r), n.onUnlisten(r) } function em(e, t) { const n = Co(e); let r = !1; for (const i of t) { const e = i.query, t = n.queries.get(e); if (t) { for (const e of t.listeners) e.$u(i) && (r = !0); t.Nu = i } } r && nm(n) } function tm(e, t, n) { const r = Co(e), i = r.queries.get(t); if (i) for (const s of i.listeners) s.onError(n); r.queries.delete(t) } function nm(e) { e.ku.forEach((e => { e.next() })) } class rm { constructor(e, t, n) { this.query = e, this.Ou = t, this.Fu = !1, this.Bu = null, this.onlineState = "Unknown", this.options = n || {} } $u(e) { if (!this.options.includeMetadataChanges) { const t = []; for (const n of e.docChanges) 3 !== n.type && t.push(n); e = new $p(e.query, e.docs, e.oldDocs, t, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults) } let t = !1; return this.Fu ? this.Lu(e) && (this.Ou.next(e), t = !0) : this.qu(e, this.onlineState) && (this.Uu(e), t = !0), this.Bu = e, t } onError(e) { this.Ou.error(e) } Mu(e) { this.onlineState = e; let t = !1; return this.Bu && !this.Fu && this.qu(this.Bu, e) && (this.Uu(this.Bu), t = !0), t } qu(e, t) { if (!e.fromCache) return !0; const n = "Offline" !== t; return (!this.options.Ku || !n) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t) } Lu(e) { if (e.docChanges.length > 0) return !0; const t = this.Bu && this.Bu.hasPendingWrites !== e.hasPendingWrites; return !(!e.syncStateChanged && !t) && !0 === this.options.includeMetadataChanges } Uu(e) { e = $p.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.Fu = !0, this.Ou.next(e) } } class im { constructor(e, t) { this.Gu = e, this.byteLength = t } Qu() { return "metadata" in this.Gu } } class sm { constructor(e) { this.serializer = e } rr(e) { return yh(this.serializer, e) } ur(e) { return e.metadata.exists ? _h(this.serializer, e.document, !1) : Gl.newNoDocument(this.rr(e.metadata.name), this.cr(e.metadata.readTime)) } cr(e) { return fh(e) } } class om { constructor(e, t, n) { this.ju = e, this.localStore = t, this.serializer = n, this.queries = [], this.documents = [], this.collectionGroups = new Set, this.progress = am(e) } zu(e) { this.progress.bytesLoaded += e.byteLength; let t = this.progress.documentsLoaded; if (e.Gu.namedQuery) this.queries.push(e.Gu.namedQuery); else if (e.Gu.documentMetadata) { this.documents.push({ metadata: e.Gu.documentMetadata }), e.Gu.documentMetadata.exists || ++t; const n = Wo.fromString(e.Gu.documentMetadata.name); this.collectionGroups.add(n.get(n.length - 2)) } else e.Gu.document && (this.documents[this.documents.length - 1].document = e.Gu.document, ++t); return t !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = t, Object.assign({}, this.progress)) : null } Wu(e) { const t = new Map, n = new sm(this.serializer); for (const r of e) if (r.metadata.queries) { const e = n.rr(r.metadata.name); for (const n of r.metadata.queries) { const r = (t.get(n) || Zc()).add(e); t.set(n, r) } } return t } async complete() { const e = await async function (e, t, n, r) { const i = Co(e); let s = Zc(), o = Kc(); for (const c of n) { const e = t.rr(c.metadata.name); c.document && (s = s.add(e)); const n = t.ur(c); n.setReadTime(t.cr(c.metadata.readTime)), o = o.insert(e, n) } const a = i.Zi.newChangeBuffer({ trackRemovals: !0 }), l = await Ff(i, function (e) { return Oc(Tc(Wo.fromString("__bundle__/docs/".concat(e)))) }(r)); return i.persistence.runTransaction("Apply bundle documents", "readwrite", (e => Pf(e, a, o).next((t => (a.apply(e), t))).next((t => i.Bs.removeMatchingKeysForTargetId(e, l.targetId).next((() => i.Bs.addMatchingKeys(e, s, l.targetId))).next((() => i.localDocuments.getLocalViewOfDocuments(e, t.nr, t.sr))).next((() => t.nr)))))) }(this.localStore, new sm(this.serializer), this.documents, this.ju.id), t = this.Wu(this.documents); for (const n of this.queries) await zf(this.localStore, n, t.get(n.name)); return this.progress.taskState = "Success", { progress: this.progress, Hu: this.collectionGroups, Ju: e } } } function am(e) { return { taskState: "Running", documentsLoaded: 0, bytesLoaded: 0, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes } } class lm { constructor(e) { this.key = e } } class cm { constructor(e) { this.key = e } } class um { constructor(e, t) { this.query = e, this.Yu = t, this.Xu = null, this.hasCachedResults = !1, this.current = !1, this.Zu = Zc(), this.mutatedKeys = Zc(), this.tc = Bc(e), this.ec = new Qp(this.tc) } get nc() { return this.Yu } sc(e, t) { const n = t ? t.ic : new Wp, r = t ? t.ec : this.ec; let i = t ? t.mutatedKeys : this.mutatedKeys, s = r, o = !1; const a = "F" === this.query.limitType && r.size === this.query.limit ? r.last() : null, l = "L" === this.query.limitType && r.size === this.query.limit ? r.first() : null; if (e.inorderTraversal(((e, t) => { const c = r.get(e), u = jc(this.query, t) ? t : null, h = !!c && this.mutatedKeys.has(c.key), d = !!u && (u.hasLocalMutations || this.mutatedKeys.has(u.key) && u.hasCommittedMutations); let f = !1; c && u ? c.data.isEqual(u.data) ? h !== d && (n.track({ type: 3, doc: u }), f = !0) : this.rc(c, u) || (n.track({ type: 2, doc: u }), f = !0, (a && this.tc(u, a) > 0 || l && this.tc(u, l) < 0) && (o = !0)) : !c && u ? (n.track({ type: 0, doc: u }), f = !0) : c && !u && (n.track({ type: 1, doc: c }), f = !0, (a || l) && (o = !0)), f && (u ? (s = s.add(u), i = d ? i.add(e) : i.delete(e)) : (s = s.delete(e), i = i.delete(e))) })), null !== this.query.limit) for (; s.size > this.query.limit;) { const e = "F" === this.query.limitType ? s.last() : s.first(); s = s.delete(e.key), i = i.delete(e.key), n.track({ type: 1, doc: e }) } return { ec: s, ic: n, zi: o, mutatedKeys: i } } rc(e, t) { return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations } applyChanges(e, t, n) { const r = this.ec; this.ec = e.ec, this.mutatedKeys = e.mutatedKeys; const i = e.ic.xu(); i.sort(((e, t) => function (e, t) { const n = e => { switch (e) { case 0: return 1; case 2: case 3: return 2; case 1: return 0; default: return To() } }; return n(e) - n(t) }(e.type, t.type) || this.tc(e.doc, t.doc))), this.oc(n); const s = t ? this.uc() : [], o = 0 === this.Zu.size && this.current ? 1 : 0, a = o !== this.Xu; return this.Xu = o, 0 !== i.length || a ? { snapshot: new $p(this.query, e.ec, r, i, e.mutatedKeys, 0 === o, a, !1, !!n && n.resumeToken.approximateByteSize() > 0), cc: s } : { cc: s } } Mu(e) { return this.current && "Offline" === e ? (this.current = !1, this.applyChanges({ ec: this.ec, ic: new Wp, mutatedKeys: this.mutatedKeys, zi: !1 }, !1)) : { cc: [] } } ac(e) { return !this.Yu.has(e) && !!this.ec.has(e) && !this.ec.get(e).hasLocalMutations } oc(e) { e && (e.addedDocuments.forEach((e => this.Yu = this.Yu.add(e))), e.modifiedDocuments.forEach((e => { })), e.removedDocuments.forEach((e => this.Yu = this.Yu.delete(e))), this.current = e.current) } uc() { if (!this.current) return []; const e = this.Zu; this.Zu = Zc(), this.ec.forEach((e => { this.ac(e.key) && (this.Zu = this.Zu.add(e.key)) })); const t = []; return e.forEach((e => { this.Zu.has(e) || t.push(new cm(e)) })), this.Zu.forEach((n => { e.has(n) || t.push(new lm(n)) })), t } hc(e) { this.Yu = e.ir, this.Zu = Zc(); const t = this.sc(e.documents); return this.applyChanges(t, !0) } lc() { return $p.fromInitialDocuments(this.query, this.ec, this.mutatedKeys, 0 === this.Xu, this.hasCachedResults) } } class hm { constructor(e, t, n) { this.query = e, this.targetId = t, this.view = n } } class dm { constructor(e) { this.key = e, this.fc = !1 } } class fm { constructor(e, t, n, r, i, s) { this.localStore = e, this.remoteStore = t, this.eventManager = n, this.sharedClientState = r, this.currentUser = i, this.maxConcurrentLimboResolutions = s, this.dc = {}, this.wc = new zc((e => Fc(e)), Lc), this._c = new Map, this.mc = new Set, this.gc = new il(Yo.comparator), this.yc = new Map, this.Ic = new df, this.Tc = {}, this.Ec = new Map, this.Ac = Bd.Mn(), this.onlineState = "Unknown", this.vc = void 0 } get isPrimaryClient() { return !0 === this.vc } } async function pm(e, t) { const n = Bm(e); let r, i; const s = n.wc.get(t); if (s) r = s.targetId, n.sharedClientState.addLocalQueryTarget(r), i = s.view.lc(); else { const e = await Ff(n.localStore, Oc(t)), s = n.sharedClientState.addLocalQueryTarget(e.targetId); r = e.targetId, i = await mm(n, t, r, "current" === s, e.resumeToken), n.isPrimaryClient && wp(n.remoteStore, e) } return i } async function mm(e, t, n, r, i) { e.Rc = (t, n, r) => async function (e, t, n, r) { let i = t.view.sc(n); i.zi && (i = await jf(e.localStore, t.query, !1).then((e => { let { documents: n } = e; return t.view.sc(n, i) }))); const s = r && r.targetChanges.get(t.targetId), o = t.view.applyChanges(i, e.isPrimaryClient, s); return Tm(e, t.targetId, o.cc), o.snapshot }(e, t, n, r); const s = await jf(e.localStore, t, !0), o = new um(t, s.ir), a = o.sc(s.documents), l = Yu.createSynthesizedTargetChangeForCurrentChange(n, r && "Offline" !== e.onlineState, i), c = o.applyChanges(a, e.isPrimaryClient, l); Tm(e, n, c.cc); const u = new hm(t, n, o); return e.wc.set(t, u), e._c.has(n) ? e._c.get(n).push(t) : e._c.set(n, [t]), c.snapshot } async function gm(e, t) { const n = Co(e), r = n.wc.get(t), i = n._c.get(r.targetId); if (i.length > 1) return n._c.set(r.targetId, i.filter((e => !Lc(e, t)))), void n.wc.delete(t); n.isPrimaryClient ? (n.sharedClientState.removeLocalQueryTarget(r.targetId), n.sharedClientState.isActiveQueryTarget(r.targetId) || await Mf(n.localStore, r.targetId, !1).then((() => { n.sharedClientState.clearQueryState(r.targetId), bp(n.remoteStore, r.targetId), xm(n, r.targetId) })).catch(ca)) : (xm(n, r.targetId), await Mf(n.localStore, r.targetId, !0)) } async function ym(e, t) { const n = Co(e); try { const e = await function (e, t) { const n = Co(e), r = t.snapshotVersion; let i = n.Ji; return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (e => { const s = n.Zi.newChangeBuffer({ trackRemovals: !0 }); i = n.Ji; const o = []; t.targetChanges.forEach(((s, a) => { const l = i.get(a); if (!l) return; o.push(n.Bs.removeMatchingKeys(e, s.removedDocuments, a).next((() => n.Bs.addMatchingKeys(e, s.addedDocuments, a)))); let c = l.withSequenceNumber(e.currentSequenceNumber); null !== t.targetMismatches.get(a) ? c = c.withResumeToken(dl.EMPTY_BYTE_STRING, Ho.min()).withLastLimboFreeSnapshotVersion(Ho.min()) : s.resumeToken.approximateByteSize() > 0 && (c = c.withResumeToken(s.resumeToken, r)), i = i.insert(a, c), function (e, t, n) { return 0 === e.resumeToken.approximateByteSize() || t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 || n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0 }(l, c, s) && o.push(n.Bs.updateTargetData(e, c)) })); let a = Kc(), l = Zc(); if (t.documentUpdates.forEach((r => { t.resolvedLimboDocuments.has(r) && o.push(n.persistence.referenceDelegate.updateLimboDocument(e, r)) })), o.push(Pf(e, s, t.documentUpdates).next((e => { a = e.nr, l = e.sr }))), !r.isEqual(Ho.min())) { const t = n.Bs.getLastRemoteSnapshotVersion(e).next((t => n.Bs.setTargetsMetadata(e, e.currentSequenceNumber, r))); o.push(t) } return ua.waitFor(o).next((() => s.apply(e))).next((() => n.localDocuments.getLocalViewOfDocuments(e, a, l))).next((() => a)) })).then((e => (n.Ji = i, e))) }(n.localStore, t); t.targetChanges.forEach(((e, t) => { const r = n.yc.get(t); r && (ko(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1), e.addedDocuments.size > 0 ? r.fc = !0 : e.modifiedDocuments.size > 0 ? ko(r.fc) : e.removedDocuments.size > 0 && (ko(r.fc), r.fc = !1)) })), await Nm(n, e, t) } catch (e) { await ca(e) } } function vm(e, t, n) { const r = Co(e); if (r.isPrimaryClient && 0 === n || !r.isPrimaryClient && 1 === n) { const e = []; r.wc.forEach(((n, r) => { const i = r.view.Mu(t); i.snapshot && e.push(i.snapshot) })), function (e, t) { const n = Co(e); n.onlineState = t; let r = !1; n.queries.forEach(((e, n) => { for (const i of n.listeners) i.Mu(t) && (r = !0) })), r && nm(n) }(r.eventManager, t), e.length && r.dc.nu(e), r.onlineState = t, r.isPrimaryClient && r.sharedClientState.setOnlineState(t) } } async function wm(e, t, n) { const r = Co(e); r.sharedClientState.updateQueryState(t, "rejected", n); const i = r.yc.get(t), s = i && i.key; if (s) { let e = new il(Yo.comparator); e = e.insert(s, Gl.newNoDocument(s, Ho.min())); const n = Zc().add(s), i = new Xu(Ho.min(), new Map, new il(zo), e, n); await ym(r, i), r.gc = r.gc.remove(s), r.yc.delete(t), Cm(r) } else await Mf(r.localStore, t, !1).then((() => xm(r, t, n))).catch(ca) } async function bm(e, t) { const n = Co(e), r = t.batch.batchId; try { const e = await function (e, t) { const n = Co(e); return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (e => { const r = t.batch.keys(), i = n.Zi.newChangeBuffer({ trackRemovals: !0 }); return function (e, t, n, r) { const i = n.batch, s = i.keys(); let o = ua.resolve(); return s.forEach((e => { o = o.next((() => r.getEntry(t, e))).next((t => { const s = n.docVersions.get(e); ko(null !== s), t.version.compareTo(s) < 0 && (i.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t))) })) })), o.next((() => e.mutationQueue.removeMutationBatch(t, i))) }(n, e, t, i).next((() => i.apply(e))).next((() => n.mutationQueue.performConsistencyCheck(e))).next((() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t.batch.batchId))).next((() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, function (e) { let t = Zc(); for (let n = 0; n < e.mutationResults.length; ++n)e.mutationResults[n].transformResults.length > 0 && (t = t.add(e.batch.mutations[n].key)); return t }(t)))).next((() => n.localDocuments.getDocuments(e, r))) })) }(n.localStore, t); _m(n, r, null), Sm(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await Nm(n, e) } catch (e) { await ca(e) } } async function Em(e, t, n) { const r = Co(e); try { const e = await function (e, t) { const n = Co(e); return n.persistence.runTransaction("Reject batch", "readwrite-primary", (e => { let r; return n.mutationQueue.lookupMutationBatch(e, t).next((t => (ko(null !== t), r = t.keys(), n.mutationQueue.removeMutationBatch(e, t)))).next((() => n.mutationQueue.performConsistencyCheck(e))).next((() => n.documentOverlayCache.removeOverlaysForBatchId(e, r, t))).next((() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e, r))).next((() => n.localDocuments.getDocuments(e, r))) })) }(r.localStore, t); _m(r, t, n), Sm(r, t), r.sharedClientState.updateMutationState(t, "rejected", n), await Nm(r, e) } catch (n) { await ca(n) } } function Sm(e, t) { (e.Ec.get(t) || []).forEach((e => { e.resolve() })), e.Ec.delete(t) } function _m(e, t, n) { const r = Co(e); let i = r.Tc[r.currentUser.toKey()]; if (i) { const e = i.get(t); e && (n ? e.reject(n) : e.resolve(), i = i.remove(t)), r.Tc[r.currentUser.toKey()] = i } } function xm(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; e.sharedClientState.removeLocalQueryTarget(t); for (const r of e._c.get(t)) e.wc.delete(r), n && e.dc.Pc(r, n); e._c.delete(t), e.isPrimaryClient && e.Ic.Is(t).forEach((t => { e.Ic.containsKey(t) || Im(e, t) })) } function Im(e, t) { e.mc.delete(t.path.canonicalString()); const n = e.gc.get(t); null !== n && (bp(e.remoteStore, n), e.gc = e.gc.remove(t), e.yc.delete(n), Cm(e)) } function Tm(e, t, n) { for (const r of n) r instanceof lm ? (e.Ic.addReference(r.key, t), km(e, r)) : r instanceof cm ? (So("SyncEngine", "Document no longer in limbo: " + r.key), e.Ic.removeReference(r.key, t), e.Ic.containsKey(r.key) || Im(e, r.key)) : To() } function km(e, t) { const n = t.key, r = n.path.canonicalString(); e.gc.get(n) || e.mc.has(r) || (So("SyncEngine", "New document in limbo: " + n), e.mc.add(r), Cm(e)) } function Cm(e) { for (; e.mc.size > 0 && e.gc.size < e.maxConcurrentLimboResolutions;) { const t = e.mc.values().next().value; e.mc.delete(t); const n = new Yo(Wo.fromString(t)), r = e.Ac.next(); e.yc.set(r, new dm(n)), e.gc = e.gc.insert(n, r), wp(e.remoteStore, new jh(Oc(Tc(n.path)), r, "TargetPurposeLimboResolution", Sa.ct)) } } async function Nm(e, t, n) { const r = Co(e), i = [], s = [], o = []; r.wc.isEmpty() || (r.wc.forEach(((e, a) => { o.push(r.Rc(a, t, n).then((e => { if ((e || n) && r.isPrimaryClient && r.sharedClientState.updateQueryState(a.targetId, (null == e ? void 0 : e.fromCache) ? "not-current" : "current"), e) { i.push(e); const t = Cf.Li(a.targetId, e); s.push(t) } }))) })), await Promise.all(o), r.dc.nu(i), await async function (e, t) { const n = Co(e); try { await n.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (e => ua.forEach(t, (t => ua.forEach(t.Fi, (r => n.persistence.referenceDelegate.addReference(e, t.targetId, r))).next((() => ua.forEach(t.Bi, (r => n.persistence.referenceDelegate.removeReference(e, t.targetId, r))))))))) } catch (e) { if (!ma(e)) throw e; So("LocalStore", "Failed to update sequence numbers: " + e) } for (const r of t) { const e = r.targetId; if (!r.fromCache) { const t = n.Ji.get(e), r = t.snapshotVersion, i = t.withLastLimboFreeSnapshotVersion(r); n.Ji = n.Ji.insert(e, i) } } }(r.localStore, s)) } async function Dm(e, t) { const n = Co(e); if (!n.currentUser.isEqual(t)) { So("SyncEngine", "User change. New user:", t.toKey()); const e = await Of(n.localStore, t); n.currentUser = t, function (e, t) { e.Ec.forEach((e => { e.forEach((e => { e.reject(new Do(No.CANCELLED, "'waitForPendingWrites' promise is rejected due to a user change.")) })) })), e.Ec.clear() }(n), n.sharedClientState.handleUserChange(t, e.removedBatchIds, e.addedBatchIds), await Nm(n, e.er) } } function Am(e, t) { const n = Co(e), r = n.yc.get(t); if (r && r.fc) return Zc().add(r.key); { let e = Zc(); const r = n._c.get(t); if (!r) return e; for (const t of r) { const r = n.wc.get(t); e = e.unionWith(r.view.nc) } return e } } async function Om(e, t) { const n = Co(e), r = await jf(n.localStore, t.query, !0), i = t.view.hc(r); return n.isPrimaryClient && Tm(n, t.targetId, i.cc), i } async function Rm(e, t) { const n = Co(e); return Bf(n.localStore, t).then((e => Nm(n, e))) } async function Pm(e, t, n, r) { const i = Co(e), s = await function (e, t) { const n = Co(e), r = Co(n.mutationQueue); return n.persistence.runTransaction("Lookup mutation documents", "readonly", (e => r.Sn(e, t).next((t => t ? n.localDocuments.getDocuments(e, t) : ua.resolve(null))))) }(i.localStore, t); null !== s ? ("pending" === n ? await Op(i.remoteStore) : "acknowledged" === n || "rejected" === n ? (_m(i, t, r || null), Sm(i, t), function (e, t) { Co(Co(e).mutationQueue).Cn(t) }(i.localStore, t)) : To(), await Nm(i, s)) : So("SyncEngine", "Cannot apply mutation batch with id: " + t) } async function Lm(e, t, n) { const r = Co(e), i = [], s = []; for (const o of t) { let e; const t = r._c.get(o); if (t && 0 !== t.length) { e = await Ff(r.localStore, Oc(t[0])); for (const e of t) { const t = r.wc.get(e), n = await Om(r, t); n.snapshot && s.push(n.snapshot) } } else { const t = await Vf(r.localStore, o); e = await Ff(r.localStore, t), await mm(r, Fm(t), o, !1, e.resumeToken) } i.push(e) } return r.dc.nu(s), i } function Fm(e) { return Ic(e.path, e.collectionGroup, e.orderBy, e.filters, e.limit, "F", e.startAt, e.endAt) } function Mm(e) { const t = Co(e); return Co(Co(t.localStore).persistence).$i() } async function jm(e, t, n, r) { const i = Co(e); if (i.vc) return void So("SyncEngine", "Ignoring unexpected query state notification."); const s = i._c.get(t); if (s && s.length > 0) switch (n) { case "current": case "not-current": { const e = await Bf(i.localStore, Vc(s[0])), r = Xu.createSynthesizedRemoteEventForCurrentChange(t, "current" === n, dl.EMPTY_BYTE_STRING); await Nm(i, e, r); break } case "rejected": await Mf(i.localStore, t, !0), xm(i, t, r); break; default: To() } } async function Vm(e, t, n) { const r = Bm(e); if (r.vc) { for (const e of t) { if (r._c.has(e)) { So("SyncEngine", "Adding an already active target " + e); continue } const t = await Vf(r.localStore, e), n = await Ff(r.localStore, t); await mm(r, Fm(t), n.targetId, !1, n.resumeToken), wp(r.remoteStore, n) } for (const e of n) r._c.has(e) && await Mf(r.localStore, e, !1).then((() => { bp(r.remoteStore, e), xm(r, e) })).catch(ca) } } function Bm(e) { const t = Co(e); return t.remoteStore.remoteSyncer.applyRemoteEvent = ym.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = Am.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = wm.bind(null, t), t.dc.nu = em.bind(null, t.eventManager), t.dc.Pc = tm.bind(null, t.eventManager), t } function Um(e) { const t = Co(e); return t.remoteStore.remoteSyncer.applySuccessfulWrite = bm.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = Em.bind(null, t), t } class zm { constructor() { this.synchronizeTabs = !1 } async initialize(e) { this.serializer = cp(e.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(e), this.persistence = this.createPersistence(e), await this.persistence.start(), this.localStore = this.createLocalStore(e), this.gcScheduler = this.createGarbageCollectionScheduler(e, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(e, this.localStore) } createGarbageCollectionScheduler(e, t) { return null } createIndexBackfillerScheduler(e, t) { return null } createLocalStore(e) { return Af(this.persistence, new Nf, e.initialUser, this.serializer) } createPersistence(e) { return new vf(bf.zs, this.serializer) } createSharedClientState(e) { return new Jf } async terminate() { this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown() } } class qm extends zm { constructor(e, t, n) { super(), this.Vc = e, this.cacheSizeBytes = t, this.forceOwnership = n, this.synchronizeTabs = !1 } async initialize(e) { await super.initialize(e), await this.Vc.initialize(this, e), await Um(this.Vc.syncEngine), await Op(this.Vc.remoteStore), await this.persistence.Ii((() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(), this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(), Promise.resolve()))) } createLocalStore(e) { return Af(this.persistence, new Nf, e.initialUser, this.serializer) } createGarbageCollectionScheduler(e, t) { const n = this.persistence.referenceDelegate.garbageCollector; return new Qd(n, e.asyncQueue, t) } createIndexBackfillerScheduler(e, t) { const n = new Ea(t, this.persistence); return new ba(e.asyncQueue, n) } createPersistence(e) { const t = kf(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey), n = void 0 !== this.cacheSizeBytes ? Od.withCacheSize(this.cacheSizeBytes) : Od.DEFAULT; return new xf(this.synchronizeTabs, t, e.clientId, n, e.asyncQueue, ap(), lp(), this.serializer, this.sharedClientState, !!this.forceOwnership) } createSharedClientState(e) { return new Jf } } class Km extends qm { constructor(e, t) { super(e, t, !1), this.Vc = e, this.cacheSizeBytes = t, this.synchronizeTabs = !0 } async initialize(e) { await super.initialize(e); const t = this.Vc.syncEngine; this.sharedClientState instanceof Yf && (this.sharedClientState.syncEngine = { jr: Pm.bind(null, t), zr: jm.bind(null, t), Wr: Vm.bind(null, t), $i: Mm.bind(null, t), Qr: Rm.bind(null, t) }, await this.sharedClientState.start()), await this.persistence.Ii((async e => { await async function (e, t) { const n = Co(e); if (Bm(n), Um(n), !0 === t && !0 !== n.vc) { const e = n.sharedClientState.getAllActiveQueryTargets(), t = await Lm(n, e.toArray()); n.vc = !0, await zp(n.remoteStore, !0); for (const r of t) wp(n.remoteStore, r) } else if (!1 === t && !1 !== n.vc) { const e = []; let t = Promise.resolve(); n._c.forEach(((r, i) => { n.sharedClientState.isLocalQueryTarget(i) ? e.push(i) : t = t.then((() => (xm(n, i), Mf(n.localStore, i, !0)))), bp(n.remoteStore, i) })), await t, await Lm(n, e), function (e) { const t = Co(e); t.yc.forEach(((e, n) => { bp(t.remoteStore, n) })), t.Ic.Ts(), t.yc = new Map, t.gc = new il(Yo.comparator) }(n), n.vc = !1, await zp(n.remoteStore, !1) } }(this.Vc.syncEngine, e), this.gcScheduler && (e && !this.gcScheduler.started ? this.gcScheduler.start() : e || this.gcScheduler.stop()), this.indexBackfillerScheduler && (e && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : e || this.indexBackfillerScheduler.stop()) })) } createSharedClientState(e) { const t = ap(); if (!Yf.D(t)) throw new Do(No.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage."); const n = kf(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey); return new Yf(t, e.asyncQueue, n, e.clientId, e.initialUser) } } class Gm { async initialize(e, t) { this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(t), this.remoteStore = this.createRemoteStore(t), this.eventManager = this.createEventManager(t), this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs), this.sharedClientState.onlineStateHandler = e => vm(this.syncEngine, e, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Dm.bind(null, this.syncEngine), await zp(this.remoteStore, this.syncEngine.isPrimaryClient)) } createEventManager(e) { return new Yp } createDatastore(e) { const t = cp(e.databaseInfo.databaseId), n = (r = e.databaseInfo, new op(r)); var r; return function (e, t, n, r) { return new pp(e, t, n, r) }(e.authCredentials, e.appCheckCredentials, n, t) } createRemoteStore(e) { return t = this.localStore, n = this.datastore, r = e.asyncQueue, i = e => vm(this.syncEngine, e, 0), s = ep.D() ? new ep : new Zf, new gp(t, n, r, i, s); var t, n, r, i, s } createSyncEngine(e, t) { return function (e, t, n, r, i, s, o) { const a = new fm(e, t, n, r, i, s); return o && (a.vc = !0), a }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t) } terminate() { return async function (e) { const t = Co(e); So("RemoteStore", "RemoteStore shutting down."), t.vu.add(5), await vp(t), t.Pu.shutdown(), t.bu.set("Unknown") }(this.remoteStore) } } function Hm(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10240, n = 0; return { async read() { if (n < e.byteLength) { const r = { value: e.slice(n, n + t), done: !1 }; return n += t, r } return { done: !0 } }, async cancel() { }, releaseLock() { }, closed: Promise.resolve() } } class Qm { constructor(e) { this.observer = e, this.muted = !1 } next(e) { this.observer.next && this.Sc(this.observer.next, e) } error(e) { this.observer.error ? this.Sc(this.observer.error, e) : _o("Uncaught Error in snapshot listener:", e.toString()) } Dc() { this.muted = !0 } Sc(e, t) { this.muted || setTimeout((() => { this.muted || e(t) }), 0) } } class Wm { constructor(e, t) { this.Cc = e, this.serializer = t, this.metadata = new Ao, this.buffer = new Uint8Array, this.xc = new TextDecoder("utf-8"), this.Nc().then((e => { e && e.Qu() ? this.metadata.resolve(e.Gu.metadata) : this.metadata.reject(new Error("The first element of the bundle is not a metadata, it is\n             ".concat(JSON.stringify(null == e ? void 0 : e.Gu)))) }), (e => this.metadata.reject(e))) } close() { return this.Cc.cancel() } async getMetadata() { return this.metadata.promise } async bc() { return await this.getMetadata(), this.Nc() } async Nc() { const e = await this.kc(); if (null === e) return null; const t = this.xc.decode(e), n = Number(t); isNaN(n) && this.Mc("length string (".concat(t, ") is not valid number")); const r = await this.$c(n); return new im(JSON.parse(r), e.length + n) } Oc() { return this.buffer.findIndex((e => e === "{".charCodeAt(0))) } async kc() { for (; this.Oc() < 0 && !await this.Fc();); if (0 === this.buffer.length) return null; const e = this.Oc(); e < 0 && this.Mc("Reached the end of bundle when a length string is expected."); const t = this.buffer.slice(0, e); return this.buffer = this.buffer.slice(e), t } async $c(e) { for (; this.buffer.length < e;)await this.Fc() && this.Mc("Reached the end of bundle when more is expected."); const t = this.xc.decode(this.buffer.slice(0, e)); return this.buffer = this.buffer.slice(e), t } Mc(e) { throw this.Cc.cancel(), new Error("Invalid bundle format: ".concat(e)) } async Fc() { const e = await this.Cc.read(); if (!e.done) { const t = new Uint8Array(this.buffer.length + e.value.length); t.set(this.buffer), t.set(e.value, this.buffer.length), this.buffer = t } return e.done } } class $m { constructor(e) { this.datastore = e, this.readVersions = new Map, this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = new Set } async lookup(e) { if (this.ensureCommitNotCalled(), this.mutations.length > 0) throw new Do(No.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes."); const t = await async function (e, t) { const n = Co(e), r = bh(n.serializer) + "/documents", i = { documents: t.map((e => gh(n.serializer, e))) }, s = await n.vo("BatchGetDocuments", r, i, t.length), o = new Map; s.forEach((e => { const t = function (e, t) { return "found" in t ? function (e, t) { ko(!!t.found), t.found.name, t.found.updateTime; const n = yh(e, t.found.name), r = fh(t.found.updateTime), i = t.found.createTime ? fh(t.found.createTime) : Ho.min(), s = new ql({ mapValue: { fields: t.found.fields } }); return Gl.newFoundDocument(n, r, i, s) }(e, t) : "missing" in t ? function (e, t) { ko(!!t.missing), ko(!!t.readTime); const n = yh(e, t.missing), r = fh(t.readTime); return Gl.newNoDocument(n, r) }(e, t) : To() }(n.serializer, e); o.set(t.key.toString(), t) })); const a = []; return t.forEach((e => { const t = o.get(e.toString()); ko(!!t), a.push(t) })), a }(this.datastore, e); return t.forEach((e => this.recordVersion(e))), t } set(e, t) { this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } update(e, t) { try { this.write(t.toMutation(e, this.preconditionForUpdate(e))) } catch (e) { this.lastWriteError = e } this.writtenDocs.add(e.toString()) } delete(e) { this.write(new Ou(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } async commit() { if (this.ensureCommitNotCalled(), this.lastWriteError) throw this.lastWriteError; const e = this.readVersions; this.mutations.forEach((t => { e.delete(t.key.toString()) })), e.forEach(((e, t) => { const n = Yo.fromPath(t); this.mutations.push(new Ru(n, this.precondition(n))) })), await async function (e, t) { const n = Co(e), r = bh(n.serializer) + "/documents", i = { writes: t.map((e => xh(n.serializer, e))) }; await n.Io("Commit", r, i) }(this.datastore, this.mutations), this.committed = !0 } recordVersion(e) { let t; if (e.isFoundDocument()) t = e.version; else { if (!e.isNoDocument()) throw To(); t = Ho.min() } const n = this.readVersions.get(e.key.toString()); if (n) { if (!t.isEqual(n)) throw new Do(No.ABORTED, "Document version changed between two reads.") } else this.readVersions.set(e.key.toString(), t) } precondition(e) { const t = this.readVersions.get(e.toString()); return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(Ho.min()) ? wu.exists(!1) : wu.updateTime(t) : wu.none() } preconditionForUpdate(e) { const t = this.readVersions.get(e.toString()); if (!this.writtenDocs.has(e.toString()) && t) { if (t.isEqual(Ho.min())) throw new Do(No.INVALID_ARGUMENT, "Can't update a document that doesn't exist."); return wu.updateTime(t) } return wu.exists(!0) } write(e) { this.ensureCommitNotCalled(), this.mutations.push(e) } ensureCommitNotCalled() { } } class Xm { constructor(e, t, n, r, i) { this.asyncQueue = e, this.datastore = t, this.options = n, this.updateFunction = r, this.deferred = i, this.Bc = n.maxAttempts, this.qo = new up(this.asyncQueue, "transaction_retry") } run() { this.Bc -= 1, this.Lc() } Lc() { this.qo.No((async () => { const e = new $m(this.datastore), t = this.qc(e); t && t.then((t => { this.asyncQueue.enqueueAndForget((() => e.commit().then((() => { this.deferred.resolve(t) })).catch((e => { this.Uc(e) })))) })).catch((e => { this.Uc(e) })) })) } qc(e) { try { const t = this.updateFunction(e); return !_a(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")), null) } catch (e) { return this.deferred.reject(e), null } } Uc(e) { this.Bc > 0 && this.Kc(e) ? (this.Bc -= 1, this.asyncQueue.enqueueAndForget((() => (this.Lc(), Promise.resolve())))) : this.deferred.reject(e) } Kc(e) { if ("FirebaseError" === e.name) { const t = e.code; return "aborted" === t || "failed-precondition" === t || "already-exists" === t || !Bu(t) } return !1 } } class Ym { constructor(e, t, n, r) { this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = n, this.databaseInfo = r, this.user = vo.UNAUTHENTICATED, this.clientId = Uo.A(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, (async e => { So("FirestoreClient", "Received user=", e.uid), await this.authCredentialListener(e), this.user = e })), this.appCheckCredentials.start(n, (e => (So("FirestoreClient", "Received new app check token=", e), this.appCheckCredentialListener(e, this.user)))) } async getConfiguration() { return { asyncQueue: this.asyncQueue, databaseInfo: this.databaseInfo, clientId: this.clientId, authCredentials: this.authCredentials, appCheckCredentials: this.appCheckCredentials, initialUser: this.user, maxConcurrentLimboResolutions: 100 } } setCredentialChangeListener(e) { this.authCredentialListener = e } setAppCheckTokenChangeListener(e) { this.appCheckCredentialListener = e } verifyNotTerminated() { if (this.asyncQueue.isShuttingDown) throw new Do(No.FAILED_PRECONDITION, "The client has already been terminated.") } terminate() { this.asyncQueue.enterRestrictedMode(); const e = new Ao; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async () => { try { this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve() } catch (t) { const n = Hp(t, "Failed to shutdown persistence"); e.reject(n) } })), e.promise } } async function Jm(e, t) { e.asyncQueue.verifyOperationInProgress(), So("FirestoreClient", "Initializing OfflineComponentProvider"); const n = await e.getConfiguration(); await t.initialize(n); let r = n.initialUser; e.setCredentialChangeListener((async e => { r.isEqual(e) || (await Of(t.localStore, e), r = e) })), t.persistence.setDatabaseDeletedListener((() => e.terminate())), e._offlineComponents = t } async function Zm(e, t) { e.asyncQueue.verifyOperationInProgress(); const n = await tg(e); So("FirestoreClient", "Initializing OnlineComponentProvider"); const r = await e.getConfiguration(); await t.initialize(n, r), e.setCredentialChangeListener((e => Up(t.remoteStore, e))), e.setAppCheckTokenChangeListener(((e, n) => Up(t.remoteStore, n))), e._onlineComponents = t } function eg(e) { return "FirebaseError" === e.name ? e.code === No.FAILED_PRECONDITION || e.code === No.UNIMPLEMENTED : !("undefined" != typeof DOMException && e instanceof DOMException) || 22 === e.code || 20 === e.code || 11 === e.code } async function tg(e) { if (!e._offlineComponents) if (e._uninitializedComponentsProvider) { So("FirestoreClient", "Using user provided OfflineComponentProvider"); try { await Jm(e, e._uninitializedComponentsProvider._offline) } catch (t) { const n = t; if (!eg(n)) throw n; xo("Error using user provided cache. Falling back to memory cache: " + n), await Jm(e, new zm) } } else So("FirestoreClient", "Using default OfflineComponentProvider"), await Jm(e, new zm); return e._offlineComponents } async function ng(e) { return e._onlineComponents || (e._uninitializedComponentsProvider ? (So("FirestoreClient", "Using user provided OnlineComponentProvider"), await Zm(e, e._uninitializedComponentsProvider._online)) : (So("FirestoreClient", "Using default OnlineComponentProvider"), await Zm(e, new Gm))), e._onlineComponents } function rg(e) { return tg(e).then((e => e.persistence)) } function ig(e) { return tg(e).then((e => e.localStore)) } function sg(e) { return ng(e).then((e => e.remoteStore)) } function og(e) { return ng(e).then((e => e.syncEngine)) } function ag(e) { return ng(e).then((e => e.datastore)) } async function lg(e) { const t = await ng(e), n = t.eventManager; return n.onListen = pm.bind(null, t.syncEngine), n.onUnlisten = gm.bind(null, t.syncEngine), n } function cg(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = new Ao; return e.asyncQueue.enqueueAndForget((async () => function (e, t, n, r, i) { const s = new Qm({ next: s => { t.enqueueAndForget((() => Zp(e, o))); const a = s.docs.has(n); !a && s.fromCache ? i.reject(new Do(No.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && s.fromCache && r && "server" === r.source ? i.reject(new Do(No.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(s) }, error: e => i.reject(e) }), o = new rm(Tc(n.path), s, { includeMetadataChanges: !0, Ku: !0 }); return Jp(e, o) }(await lg(e), e.asyncQueue, t, n, r))), r.promise } function ug(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = new Ao; return e.asyncQueue.enqueueAndForget((async () => function (e, t, n, r, i) { const s = new Qm({ next: n => { t.enqueueAndForget((() => Zp(e, o))), n.fromCache && "server" === r.source ? i.reject(new Do(No.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n) }, error: e => i.reject(e) }), o = new rm(n, s, { includeMetadataChanges: !0, Ku: !0 }); return Jp(e, o) }(await lg(e), e.asyncQueue, t, n, r))), r.promise } function hg(e, t, n, r) { const i = function (e, t) { let n; return n = "string" == typeof e ? Ku().encode(e) : e, function (e, t) { return new Wm(e, t) }(function (e, t) { if (e instanceof Uint8Array) return Hm(e, t); if (e instanceof ArrayBuffer) return Hm(new Uint8Array(e), t); if (e instanceof ReadableStream) return e.getReader(); throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream") }(n), t) }(n, cp(t)); e.asyncQueue.enqueueAndForget((async () => { !function (e, t, n) { const r = Co(e); (async function (e, t, n) { try { const r = await t.getMetadata(); if (await function (e, t) { const n = Co(e), r = fh(t.createTime); return n.persistence.runTransaction("hasNewerBundle", "readonly", (e => n.qs.getBundleMetadata(e, t.id))).then((e => !!e && e.createTime.compareTo(r) >= 0)) }(e.localStore, r)) return await t.close(), n._completeWith(function (e) { return { taskState: "Success", documentsLoaded: e.totalDocuments, bytesLoaded: e.totalBytes, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes } }(r)), Promise.resolve(new Set); n._updateProgress(am(r)); const i = new om(r, e.localStore, t.serializer); let s = await t.bc(); for (; s;) { const e = await i.zu(s); e && n._updateProgress(e), s = await t.bc() } const o = await i.complete(); return await Nm(e, o.Ju, void 0), await function (e, t) { const n = Co(e); return n.persistence.runTransaction("Save bundle", "readwrite", (e => n.qs.saveBundleMetadata(e, t))) }(e.localStore, r), n._completeWith(o.progress), Promise.resolve(o.Hu) } catch (e) { return xo("SyncEngine", "Loading bundle failed with ".concat(e)), n._failWith(e), Promise.resolve(new Set) } })(r, t, n).then((e => { r.sharedClientState.notifyBundleLoaded(e) })) }(await og(e), i, r) })) } function dg(e) { const t = {}; return void 0 !== e.timeoutSeconds && (t.timeoutSeconds = e.timeoutSeconds), t } const fg = new Map; function pg(e, t, n) { if (!n) throw new Do(No.INVALID_ARGUMENT, "Function ".concat(e, "() cannot be called with an empty ").concat(t, ".")) } function mg(e, t, n, r) { if (!0 === t && !0 === r) throw new Do(No.INVALID_ARGUMENT, "".concat(e, " and ").concat(n, " cannot be used together.")) } function gg(e) { if (!Yo.isDocumentKey(e)) throw new Do(No.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but ".concat(e, " has ").concat(e.length, ".")) } function yg(e) { if (Yo.isDocumentKey(e)) throw new Do(No.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but ".concat(e, " has ").concat(e.length, ".")) } function vg(e) { if (void 0 === e) return "undefined"; if (null === e) return "null"; if ("string" == typeof e) return e.length > 20 && (e = "".concat(e.substring(0, 20), "...")), JSON.stringify(e); if ("number" == typeof e || "boolean" == typeof e) return "" + e; if ("object" == typeof e) { if (e instanceof Array) return "an array"; { const t = function (e) { return e.constructor ? e.constructor.name : null }(e); return t ? "a custom ".concat(t, " object") : "an object" } } return "function" == typeof e ? "a function" : To() } function wg(e, t) { if ("_delegate" in e && (e = e._delegate), !(e instanceof t)) { if (t.name === e.constructor.name) throw new Do(No.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const n = vg(e); throw new Do(No.INVALID_ARGUMENT, "Expected type '".concat(t.name, "', but it was: ").concat(n)) } } return e } function bg(e, t) { if (t <= 0) throw new Do(No.INVALID_ARGUMENT, "Function ".concat(e, "() requires a positive number, but it was: ").concat(t, ".")) } class Eg { constructor(e) { var t, n; if (void 0 === e.host) { if (void 0 !== e.ssl) throw new Do(No.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = "firestore.googleapis.com", this.ssl = !0 } else this.host = e.host, this.ssl = null === (t = e.ssl) || void 0 === t || t; if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.cache = e.localCache, void 0 === e.cacheSizeBytes) this.cacheSizeBytes = 41943040; else { if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576) throw new Do(No.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = e.cacheSizeBytes } mg("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : void 0 === e.experimentalAutoDetectLongPolling ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.experimentalLongPollingOptions = dg(null !== (n = e.experimentalLongPollingOptions) && void 0 !== n ? n : {}), function (e) { if (void 0 !== e.timeoutSeconds) { if (isNaN(e.timeoutSeconds)) throw new Do(No.INVALID_ARGUMENT, "invalid long polling timeout: ".concat(e.timeoutSeconds, " (must not be NaN)")); if (e.timeoutSeconds < 5) throw new Do(No.INVALID_ARGUMENT, "invalid long polling timeout: ".concat(e.timeoutSeconds, " (minimum allowed value is 5)")); if (e.timeoutSeconds > 30) throw new Do(No.INVALID_ARGUMENT, "invalid long polling timeout: ".concat(e.timeoutSeconds, " (maximum allowed value is 30)")) } }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams } isEqual(e) { return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && (t = this.experimentalLongPollingOptions, n = e.experimentalLongPollingOptions, t.timeoutSeconds === n.timeoutSeconds) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams; var t, n } } class Sg { constructor(e, t, n, r) { this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = n, this._app = r, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Eg({}), this._settingsFrozen = !1 } get app() { if (!this._app) throw new Do(No.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return void 0 !== this._terminateTask } _setSettings(e) { if (this._settingsFrozen) throw new Do(No.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new Eg(e), void 0 !== e.credentials && (this._authCredentials = function (e) { if (!e) return new Ro; switch (e.type) { case "firstParty": return new Mo(e.sessionIndex || "0", e.iamToken || null, e.authTokenFactory || null); case "provider": return e.client; default: throw new Do(No.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } }(e.credentials)) } _getSettings() { return this._settings } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return function (e) { const t = fg.get(e); t && (So("ComponentProvider", "Removing Datastore"), fg.delete(e), t.terminate()) }(this), Promise.resolve() } } function _g(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; var i; const s = (e = wg(e, Sg))._getSettings(), o = "".concat(t, ":").concat(n); if ("firestore.googleapis.com" !== s.host && s.host !== o && xo("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), e._setSettings(Object.assign(Object.assign({}, s), { host: o, ssl: !1 })), r.mockUserToken) { let t, n; if ("string" == typeof r.mockUserToken) t = r.mockUserToken, n = vo.MOCK_USER; else { t = function (e, t) { if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); const n = t || "demo-project", r = e.iat || 0, i = e.sub || e.user_id; if (!i) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const s = Object.assign({ iss: "https://securetoken.google.com/".concat(n), aud: n, iat: r, exp: r + 3600, auth_time: r, sub: i, user_id: i, firebase: { sign_in_provider: "custom", identities: {} } }, e); return [pe(JSON.stringify({ alg: "none", type: "JWT" })), pe(JSON.stringify(s)), ""].join(".") }(r.mockUserToken, null === (i = e._app) || void 0 === i ? void 0 : i.options.projectId); const s = r.mockUserToken.sub || r.mockUserToken.user_id; if (!s) throw new Do(No.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); n = new vo(s) } e._authCredentials = new Po(new Oo(t, n)) } } class xg { constructor(e, t, n) { this.converter = t, this._key = n, this.type = "document", this.firestore = e } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new Tg(this.firestore, this.converter, this._key.path.popLast()) } withConverter(e) { return new xg(this.firestore, e, this._key) } } class Ig { constructor(e, t, n) { this.converter = t, this._query = n, this.type = "query", this.firestore = e } withConverter(e) { return new Ig(this.firestore, e, this._query) } } class Tg extends Ig { constructor(e, t, n) { super(e, t, Tc(n)), this._path = n, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const e = this._path.popLast(); return e.isEmpty() ? null : new xg(this.firestore, null, new Yo(e)) } withConverter(e) { return new Tg(this.firestore, e, this._path) } } function kg(e, t) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; if (e = Re(e), pg("collection", "path", t), e instanceof Sg) { const n = Wo.fromString(t, ...r); return yg(n), new Tg(e, null, n) } { if (!(e instanceof xg || e instanceof Tg)) throw new Do(No.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const n = e._path.child(Wo.fromString(t, ...r)); return yg(n), new Tg(e.firestore, null, n) } } function Cg(e, t) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; if (e = Re(e), 1 === arguments.length && (t = Uo.A()), pg("doc", "path", t), e instanceof Sg) { const n = Wo.fromString(t, ...r); return gg(n), new xg(e, null, new Yo(n)) } { if (!(e instanceof xg || e instanceof Tg)) throw new Do(No.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const n = e._path.child(Wo.fromString(t, ...r)); return gg(n), new xg(e.firestore, e instanceof Tg ? e.converter : null, new Yo(n)) } } function Ng(e, t) { return e = Re(e), t = Re(t), (e instanceof xg || e instanceof Tg) && (t instanceof xg || t instanceof Tg) && e.firestore === t.firestore && e.path === t.path && e.converter === t.converter } function Dg(e, t) { return e = Re(e), t = Re(t), e instanceof Ig && t instanceof Ig && e.firestore === t.firestore && Lc(e._query, t._query) && e.converter === t.converter } class Ag { constructor() { this.Gc = Promise.resolve(), this.Qc = [], this.jc = !1, this.zc = [], this.Wc = null, this.Hc = !1, this.Jc = !1, this.Yc = [], this.qo = new up(this, "async_queue_retry"), this.Xc = () => { const e = lp(); e && So("AsyncQueue", "Visibility state changed to " + e.visibilityState), this.qo.Mo() }; const e = lp(); e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.Xc) } get isShuttingDown() { return this.jc } enqueueAndForget(e) { this.enqueue(e) } enqueueAndForgetEvenWhileRestricted(e) { this.Zc(), this.ta(e) } enterRestrictedMode(e) { if (!this.jc) { this.jc = !0, this.Jc = e || !1; const t = lp(); t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.Xc) } } enqueue(e) { if (this.Zc(), this.jc) return new Promise((() => { })); const t = new Ao; return this.ta((() => this.jc && this.Jc ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise))).then((() => t.promise)) } enqueueRetryable(e) { this.enqueueAndForget((() => (this.Qc.push(e), this.ea()))) } async ea() { if (0 !== this.Qc.length) { try { await this.Qc[0](), this.Qc.shift(), this.qo.reset() } catch (e) { if (!ma(e)) throw e; So("AsyncQueue", "Operation failed with retryable error: " + e) } this.Qc.length > 0 && this.qo.No((() => this.ea())) } } ta(e) { const t = this.Gc.then((() => (this.Hc = !0, e().catch((e => { this.Wc = e, this.Hc = !1; const t = function (e) { let t = e.message || ""; return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + "\n" + e.stack), t }(e); throw _o("INTERNAL UNHANDLED ERROR: ", t), e })).then((e => (this.Hc = !1, e)))))); return this.Gc = t, t } enqueueAfterDelay(e, t, n) { this.Zc(), this.Yc.indexOf(e) > -1 && (t = 0); const r = Gp.createAndSchedule(this, e, t, n, (e => this.na(e))); return this.zc.push(r), r } Zc() { this.Wc && To() } verifyOperationInProgress() { } async sa() { let e; do { e = this.Gc, await e } while (e !== this.Gc) } ia(e) { for (const t of this.zc) if (t.timerId === e) return !0; return !1 } ra(e) { return this.sa().then((() => { this.zc.sort(((e, t) => e.targetTimeMs - t.targetTimeMs)); for (const t of this.zc) if (t.skipDelay(), "all" !== e && t.timerId === e) break; return this.sa() })) } oa(e) { this.Yc.push(e) } na(e) { const t = this.zc.indexOf(e); this.zc.splice(t, 1) } } function Og(e) { return function (e, t) { if ("object" != typeof e || null === e) return !1; const n = e; for (const r of ["next", "error", "complete"]) if (r in n && "function" == typeof n[r]) return !0; return !1 }(e) } class Rg { constructor() { this._progressObserver = {}, this._taskCompletionResolver = new Ao, this._lastProgress = { taskState: "Running", totalBytes: 0, totalDocuments: 0, bytesLoaded: 0, documentsLoaded: 0 } } onProgress(e, t, n) { this._progressObserver = { next: e, error: t, complete: n } } catch(e) { return this._taskCompletionResolver.promise.catch(e) } then(e, t) { return this._taskCompletionResolver.promise.then(e, t) } _completeWith(e) { this._updateProgress(e), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(e) } _failWith(e) { this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(e), this._taskCompletionResolver.reject(e) } _updateProgress(e) { this._lastProgress = e, this._progressObserver.next && this._progressObserver.next(e) } } class Pg extends Sg { constructor(e, t, n, r) { super(e, t, n, r), this.type = "firestore", this._queue = new Ag, this._persistenceKey = (null == r ? void 0 : r.name) || "[DEFAULT]" } _terminate() { return this._firestoreClient || Fg(this), this._firestoreClient.terminate() } } function Lg(e) { return e._firestoreClient || Fg(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient } function Fg(e) { var t, n, r; const i = e._freezeSettings(), s = function (e, t, n, r) { return new bl(e, t, n, r.host, r.ssl, r.experimentalForceLongPolling, r.experimentalAutoDetectLongPolling, dg(r.experimentalLongPollingOptions), r.useFetchStreams) }(e._databaseId, (null === (t = e._app) || void 0 === t ? void 0 : t.options.appId) || "", e._persistenceKey, i); e._firestoreClient = new Ym(e._authCredentials, e._appCheckCredentials, e._queue, s), (null === (n = i.cache) || void 0 === n ? void 0 : n._offlineComponentProvider) && (null === (r = i.cache) || void 0 === r ? void 0 : r._onlineComponentProvider) && (e._firestoreClient._uninitializedComponentsProvider = { _offlineKind: i.cache.kind, _offline: i.cache._offlineComponentProvider, _online: i.cache._onlineComponentProvider }) } function Mg(e, t, n) { const r = new Ao; return e.asyncQueue.enqueue((async () => { try { await Jm(e, n), await Zm(e, t), r.resolve() } catch (e) { const n = e; if (!eg(n)) throw n; xo("Error enabling indexeddb cache. Falling back to memory cache: " + n), r.reject(n) } })).then((() => r.promise)) } function jg(e) { return function (e) { const t = new Ao; return e.asyncQueue.enqueueAndForget((async () => async function (e, t) { const n = Co(e); Ip(n.remoteStore) || So("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled."); try { const e = await function (e) { const t = Co(e); return t.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (e => t.mutationQueue.getHighestUnacknowledgedBatchId(e))) }(n.localStore); if (-1 === e) return void t.resolve(); const r = n.Ec.get(e) || []; r.push(t), n.Ec.set(e, r) } catch (e) { const n = Hp(e, "Initialization of waitForPendingWrites() operation failed"); t.reject(n) } }(await og(e), t))), t.promise }(Lg(e = wg(e, Pg))) } function Vg(e) { return function (e) { return e.asyncQueue.enqueue((async () => { const t = await rg(e), n = await sg(e); return t.setNetworkEnabled(!0), function (e) { const t = Co(e); return t.vu.delete(0), yp(t) }(n) })) }(Lg(e = wg(e, Pg))) } function Bg(e) { return function (e) { return e.asyncQueue.enqueue((async () => { const t = await rg(e), n = await sg(e); return t.setNetworkEnabled(!1), async function (e) { const t = Co(e); t.vu.add(0), await vp(t), t.bu.set("Offline") }(n) })) }(Lg(e = wg(e, Pg))) } function Ug(e, t) { return function (e, t) { return e.asyncQueue.enqueue((async () => function (e, t) { const n = Co(e); return n.persistence.runTransaction("Get named query", "readonly", (e => n.qs.getNamedQuery(e, t))) }(await ig(e), t))) }(Lg(e = wg(e, Pg)), t).then((t => t ? new Ig(e, null, t.query) : null)) } function zg(e) { if (e._initialized || e._terminated) throw new Do(No.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.") } class qg { constructor(e) { this._byteString = e } static fromBase64String(e) { try { return new qg(dl.fromBase64String(e)) } catch (e) { throw new Do(No.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e) } } static fromUint8Array(e) { return new qg(dl.fromUint8Array(e)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(e) { return this._byteString.isEqual(e._byteString) } } class Kg { constructor() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; for (let r = 0; r < t.length; ++r)if (0 === t[r].length) throw new Do(No.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new Xo(t) } isEqual(e) { return this._internalPath.isEqual(e._internalPath) } } class Gg { constructor(e) { this._methodName = e } } class Hg { constructor(e, t) { if (!isFinite(e) || e < -90 || e > 90) throw new Do(No.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e); if (!isFinite(t) || t < -180 || t > 180) throw new Do(No.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t); this._lat = e, this._long = t } get latitude() { return this._lat } get longitude() { return this._long } isEqual(e) { return this._lat === e._lat && this._long === e._long } toJSON() { return { latitude: this._lat, longitude: this._long } } _compareTo(e) { return zo(this._lat, e._lat) || zo(this._long, e._long) } } const Qg = /^__.*__$/; class Wg { constructor(e, t, n) { this.data = e, this.fieldMask = t, this.fieldTransforms = n } toMutation(e, t) { return null !== this.fieldMask ? new Cu(e, this.data, this.fieldMask, t, this.fieldTransforms) : new ku(e, this.data, t, this.fieldTransforms) } } class $g { constructor(e, t, n) { this.data = e, this.fieldMask = t, this.fieldTransforms = n } toMutation(e, t) { return new Cu(e, this.data, this.fieldMask, t, this.fieldTransforms) } } function Xg(e) { switch (e) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw To() } } class Yg { constructor(e, t, n, r, i, s) { this.settings = e, this.databaseId = t, this.serializer = n, this.ignoreUndefinedProperties = r, void 0 === i && this.ua(), this.fieldTransforms = i || [], this.fieldMask = s || [] } get path() { return this.settings.path } get ca() { return this.settings.ca } aa(e) { return new Yg(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } ha(e) { var t; const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.aa({ path: n, la: !1 }); return r.fa(e), r } da(e) { var t; const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.aa({ path: n, la: !1 }); return r.ua(), r } wa(e) { return this.aa({ path: void 0, la: !0 }) } _a(e) { return yy(e, this.settings.methodName, this.settings.ma || !1, this.path, this.settings.ga) } contains(e) { return void 0 !== this.fieldMask.find((t => e.isPrefixOf(t))) || void 0 !== this.fieldTransforms.find((t => e.isPrefixOf(t.field))) } ua() { if (this.path) for (let e = 0; e < this.path.length; e++)this.fa(this.path.get(e)) } fa(e) { if (0 === e.length) throw this._a("Document fields must not be empty"); if (Xg(this.ca) && Qg.test(e)) throw this._a('Document fields cannot begin and end with "__"') } } class Jg { constructor(e, t, n) { this.databaseId = e, this.ignoreUndefinedProperties = t, this.serializer = n || cp(e) } ya(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return new Yg({ ca: e, methodName: t, ga: n, path: Xo.emptyPath(), la: !1, ma: r }, this.databaseId, this.serializer, this.ignoreUndefinedProperties) } } function Zg(e) { const t = e._freezeSettings(), n = cp(e._databaseId); return new Jg(e._databaseId, !!t.ignoreUndefinedProperties, n) } function ey(e, t, n, r, i) { let s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}; const o = e.ya(s.merge || s.mergeFields ? 2 : 0, t, n, i); fy("Data must be an object, but it was:", o, r); const a = hy(r, o); let l, c; if (s.merge) l = new ul(o.fieldMask), c = o.fieldTransforms; else if (s.mergeFields) { const e = []; for (const r of s.mergeFields) { const i = py(t, r, n); if (!o.contains(i)) throw new Do(No.INVALID_ARGUMENT, "Field '".concat(i, "' is specified in your field mask but missing from your input data.")); vy(e, i) || e.push(i) } l = new ul(e), c = o.fieldTransforms.filter((e => l.covers(e.field))) } else l = null, c = o.fieldTransforms; return new Wg(new ql(a), l, c) } class ty extends Gg { _toFieldTransform(e) { if (2 !== e.ca) throw 1 === e.ca ? e._a("".concat(this._methodName, "() can only appear at the top level of your update data")) : e._a("".concat(this._methodName, "() cannot be used with set() unless you pass {merge:true}")); return e.fieldMask.push(e.path), null } isEqual(e) { return e instanceof ty } } function ny(e, t, n) { return new Yg({ ca: 3, ga: t.settings.ga, methodName: e._methodName, la: n }, t.databaseId, t.serializer, t.ignoreUndefinedProperties) } class ry extends Gg { _toFieldTransform(e) { return new yu(e.path, new cu) } isEqual(e) { return e instanceof ry } } class iy extends Gg { constructor(e, t) { super(e), this.pa = t } _toFieldTransform(e) { const t = ny(this, e, !0), n = this.pa.map((e => uy(e, t))), r = new uu(n); return new yu(e.path, r) } isEqual(e) { return this === e } } class sy extends Gg { constructor(e, t) { super(e), this.pa = t } _toFieldTransform(e) { const t = ny(this, e, !0), n = this.pa.map((e => uy(e, t))), r = new du(n); return new yu(e.path, r) } isEqual(e) { return this === e } } class oy extends Gg { constructor(e, t) { super(e), this.Ia = t } _toFieldTransform(e) { const t = new pu(e.serializer, iu(e.serializer, this.Ia)); return new yu(e.path, t) } isEqual(e) { return this === e } } function ay(e, t, n, r) { const i = e.ya(1, t, n); fy("Data must be an object, but it was:", i, r); const s = [], o = ql.empty(); nl(r, ((e, r) => { const a = gy(t, e, n); r = Re(r); const l = i.da(a); if (r instanceof ty) s.push(a); else { const e = uy(r, l); null != e && (s.push(a), o.set(a, e)) } })); const a = new ul(s); return new $g(o, a, i.fieldTransforms) } function ly(e, t, n, r, i, s) { const o = e.ya(1, t, n), a = [py(t, r, n)], l = [i]; if (s.length % 2 != 0) throw new Do(No.INVALID_ARGUMENT, "Function ".concat(t, "() needs to be called with an even number of arguments that alternate between field names and values.")); for (let d = 0; d < s.length; d += 2)a.push(py(t, s[d])), l.push(s[d + 1]); const c = [], u = ql.empty(); for (let d = a.length - 1; d >= 0; --d)if (!vy(c, a[d])) { const e = a[d]; let t = l[d]; t = Re(t); const n = o.da(e); if (t instanceof ty) c.push(e); else { const r = uy(t, n); null != r && (c.push(e), u.set(e, r)) } } const h = new ul(c); return new $g(u, h, o.fieldTransforms) } function cy(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; return uy(n, e.ya(r ? 4 : 3, t)) } function uy(e, t) { if (dy(e = Re(e))) return fy("Unsupported field value:", t, e), hy(e, t); if (e instanceof Gg) return function (e, t) { if (!Xg(t.ca)) throw t._a("".concat(e._methodName, "() can only be used with update() and set()")); if (!t.path) throw t._a("".concat(e._methodName, "() is not currently supported inside arrays")); const n = e._toFieldTransform(t); n && t.fieldTransforms.push(n) }(e, t), null; if (void 0 === e && t.ignoreUndefinedProperties) return null; if (t.path && t.fieldMask.push(t.path), e instanceof Array) { if (t.settings.la && 4 !== t.ca) throw t._a("Nested arrays are not supported"); return function (e, t) { const n = []; let r = 0; for (const i of e) { let e = uy(i, t.wa(r)); null == e && (e = { nullValue: "NULL_VALUE" }), n.push(e), r++ } return { arrayValue: { values: n } } }(e, t) } return function (e, t) { if (null === (e = Re(e))) return { nullValue: "NULL_VALUE" }; if ("number" == typeof e) return iu(t.serializer, e); if ("boolean" == typeof e) return { booleanValue: e }; if ("string" == typeof e) return { stringValue: e }; if (e instanceof Date) { const n = Go.fromDate(e); return { timestampValue: uh(t.serializer, n) } } if (e instanceof Go) { const n = new Go(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3)); return { timestampValue: uh(t.serializer, n) } } if (e instanceof Hg) return { geoPointValue: { latitude: e.latitude, longitude: e.longitude } }; if (e instanceof qg) return { bytesValue: hh(t.serializer, e._byteString) }; if (e instanceof xg) { const n = t.databaseId, r = e.firestore._databaseId; if (!r.isEqual(n)) throw t._a("Document reference is for database ".concat(r.projectId, "/").concat(r.database, " but should be for database ").concat(n.projectId, "/").concat(n.database)); return { referenceValue: ph(e.firestore._databaseId || t.databaseId, e._key.path) } } throw t._a("Unsupported field value: ".concat(vg(e))) }(e, t) } function hy(e, t) { const n = {}; return rl(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : nl(e, ((e, r) => { const i = uy(r, t.ha(e)); null != i && (n[e] = i) })), { mapValue: { fields: n } } } function dy(e) { return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof Go || e instanceof Hg || e instanceof qg || e instanceof xg || e instanceof Gg) } function fy(e, t, n) { if (!dy(n) || !function (e) { return "object" == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e)) }(n)) { const r = vg(n); throw "an object" === r ? t._a(e + " a custom object") : t._a(e + " " + r) } } function py(e, t, n) { if ((t = Re(t)) instanceof Kg) return t._internalPath; if ("string" == typeof t) return gy(e, t); throw yy("Field path arguments must be of type string or ", e, !1, void 0, n) } const my = new RegExp("[~\\*/\\[\\]]"); function gy(e, t, n) { if (t.search(my) >= 0) throw yy("Invalid field path (".concat(t, "). Paths must not contain '~', '*', '/', '[', or ']'"), e, !1, void 0, n); try { return new Kg(...t.split("."))._internalPath } catch (r) { throw yy("Invalid field path (".concat(t, "). Paths must not be empty, begin with '.', end with '.', or contain '..'"), e, !1, void 0, n) } } function yy(e, t, n, r, i) { const s = r && !r.isEmpty(), o = void 0 !== i; let a = "Function ".concat(t, "() called with invalid data"); n && (a += " (via `toFirestore()`)"), a += ". "; let l = ""; return (s || o) && (l += " (found", s && (l += " in field ".concat(r)), o && (l += " in document ".concat(i)), l += ")"), new Do(No.INVALID_ARGUMENT, a + e + l) } function vy(e, t) { return e.some((e => e.isEqual(t))) } class wy { constructor(e, t, n, r, i) { this._firestore = e, this._userDataWriter = t, this._key = n, this._document = r, this._converter = i } get id() { return this._key.path.lastSegment() } get ref() { return new xg(this._firestore, this._converter, this._key) } exists() { return null !== this._document } data() { if (this._document) { if (this._converter) { const e = new by(this._firestore, this._userDataWriter, this._key, this._document, null); return this._converter.fromFirestore(e) } return this._userDataWriter.convertValue(this._document.data.value) } } get(e) { if (this._document) { const t = this._document.data.field(Ey("DocumentSnapshot.get", e)); if (null !== t) return this._userDataWriter.convertValue(t) } } } class by extends wy { data() { return super.data() } } function Ey(e, t) { return "string" == typeof t ? gy(e, t) : t instanceof Kg ? t._internalPath : t._delegate._internalPath } function Sy(e) { if ("L" === e.limitType && 0 === e.explicitOrderBy.length) throw new Do(No.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause") } class _y { } class xy extends _y { } function Iy(e, t) { let n = []; for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++)i[s - 2] = arguments[s]; t instanceof _y && n.push(t), n = n.concat(i), function (e) { const t = e.filter((e => e instanceof ky)).length, n = e.filter((e => e instanceof Ty)).length; if (t > 1 || t > 0 && n > 0) throw new Do(No.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.") }(n); for (const o of n) e = o._apply(e); return e } class Ty extends xy { constructor(e, t, n) { super(), this._field = e, this._op = t, this._value = n, this.type = "where" } static _create(e, t, n) { return new Ty(e, t, n) } _apply(e) { const t = this._parse(e); return Ly(e._query, t), new Ig(e.firestore, e.converter, Rc(e._query, t)) } _parse(e) { const t = Zg(e.firestore), n = function (e, t, n, r, i, s, o) { let a; if (i.isKeyField()) { if ("array-contains" === s || "array-contains-any" === s) throw new Do(No.INVALID_ARGUMENT, "Invalid Query. You can't perform '".concat(s, "' queries on documentId().")); if ("in" === s || "not-in" === s) { Py(o, s); const t = []; for (const n of o) t.push(Ry(r, e, n)); a = { arrayValue: { values: t } } } else a = Ry(r, e, o) } else "in" !== s && "not-in" !== s && "array-contains-any" !== s || Py(o, s), a = cy(n, "where", o, "in" === s || "not-in" === s); return Jl.create(i, s, a) }(e._query, 0, t, e.firestore._databaseId, this._field, this._op, this._value); return n } } class ky extends _y { constructor(e, t) { super(), this.type = e, this._queryConstraints = t } static _create(e, t) { return new ky(e, t) } _parse(e) { const t = this._queryConstraints.map((t => t._parse(e))).filter((e => e.getFilters().length > 0)); return 1 === t.length ? t[0] : Zl.create(t, this._getOperator()) } _apply(e) { const t = this._parse(e); return 0 === t.getFilters().length ? e : (function (e, t) { let n = e; const r = t.getFlattenedFilters(); for (const i of r) Ly(n, i), n = Rc(n, i) }(e._query, t), new Ig(e.firestore, e.converter, Rc(e._query, t))) } _getQueryConstraints() { return this._queryConstraints } _getOperator() { return "and" === this.type ? "and" : "or" } } class Cy extends xy { constructor(e, t) { super(), this._field = e, this._direction = t, this.type = "orderBy" } static _create(e, t) { return new Cy(e, t) } _apply(e) { const t = function (e, t, n) { if (null !== e.startAt) throw new Do(No.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy()."); if (null !== e.endAt) throw new Do(No.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy()."); const r = new $l(t, n); return function (e, t) { if (null === Cc(e)) { const n = Nc(e); null !== n && Fy(e, n, t.field) } }(e, r), r }(e._query, this._field, this._direction); return new Ig(e.firestore, e.converter, function (e, t) { const n = e.explicitOrderBy.concat([t]); return new xc(e.path, e.collectionGroup, n, e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt) }(e._query, t)) } } class Ny extends xy { constructor(e, t, n) { super(), this.type = e, this._limit = t, this._limitType = n } static _create(e, t, n) { return new Ny(e, t, n) } _apply(e) { return new Ig(e.firestore, e.converter, Pc(e._query, this._limit, this._limitType)) } } class Dy extends xy { constructor(e, t, n) { super(), this.type = e, this._docOrFields = t, this._inclusive = n } static _create(e, t, n) { return new Dy(e, t, n) } _apply(e) { const t = Oy(e, this.type, this._docOrFields, this._inclusive); return new Ig(e.firestore, e.converter, function (e, t) { return new xc(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, t, e.endAt) }(e._query, t)) } } class Ay extends xy { constructor(e, t, n) { super(), this.type = e, this._docOrFields = t, this._inclusive = n } static _create(e, t, n) { return new Ay(e, t, n) } _apply(e) { const t = Oy(e, this.type, this._docOrFields, this._inclusive); return new Ig(e.firestore, e.converter, function (e, t) { return new xc(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, t) }(e._query, t)) } } function Oy(e, t, n, r) { if (n[0] = Re(n[0]), n[0] instanceof wy) return function (e, t, n, r, i) { if (!r) throw new Do(No.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for ".concat(n, "().")); const s = []; for (const o of Ac(e)) if (o.field.isKeyField()) s.push(Al(t, r.key)); else { const e = r.data.field(o.field); if (yl(e)) throw new Do(No.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + o.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'); if (null === e) { const e = o.field.canonicalString(); throw new Do(No.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a document for which the field '".concat(e, "' (used as the orderBy) does not exist.")) } s.push(e) } return new Hl(s, i) }(e._query, e.firestore._databaseId, t, n[0]._document, r); { const i = Zg(e.firestore); return function (e, t, n, r, i, s) { const o = e.explicitOrderBy; if (i.length > o.length) throw new Do(No.INVALID_ARGUMENT, "Too many arguments provided to ".concat(r, "(). The number of arguments must be less than or equal to the number of orderBy() clauses")); const a = []; for (let l = 0; l < i.length; l++) { const s = i[l]; if (o[l].field.isKeyField()) { if ("string" != typeof s) throw new Do(No.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in ".concat(r, "(), but got a ").concat(typeof s)); if (!Dc(e) && -1 !== s.indexOf("/")) throw new Do(No.INVALID_ARGUMENT, "Invalid query. When querying a collection and ordering by documentId(), the value passed to ".concat(r, "() must be a plain document ID, but '").concat(s, "' contains a slash.")); const n = e.path.child(Wo.fromString(s)); if (!Yo.isDocumentKey(n)) throw new Do(No.INVALID_ARGUMENT, "Invalid query. When querying a collection group and ordering by documentId(), the value passed to ".concat(r, "() must result in a valid document path, but '").concat(n, "' is not because it contains an odd number of segments.")); const i = new Yo(n); a.push(Al(t, i)) } else { const e = cy(n, r, s); a.push(e) } } return new Hl(a, s) }(e._query, e.firestore._databaseId, i, t, n, r) } } function Ry(e, t, n) { if ("string" == typeof (n = Re(n))) { if ("" === n) throw new Do(No.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string."); if (!Dc(t) && -1 !== n.indexOf("/")) throw new Do(No.INVALID_ARGUMENT, "Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '".concat(n, "' contains a '/' character.")); const r = t.path.child(Wo.fromString(n)); if (!Yo.isDocumentKey(r)) throw new Do(No.INVALID_ARGUMENT, "Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '".concat(r, "' is not because it has an odd number of segments (").concat(r.length, ").")); return Al(e, new Yo(r)) } if (n instanceof xg) return Al(e, n._key); throw new Do(No.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ".concat(vg(n), ".")) } function Py(e, t) { if (!Array.isArray(e) || 0 === e.length) throw new Do(No.INVALID_ARGUMENT, "Invalid Query. A non-empty array is required for '".concat(t.toString(), "' filters.")) } function Ly(e, t) { if (t.isInequality()) { const n = Nc(e), r = t.field; if (null !== n && !n.isEqual(r)) throw new Do(No.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '".concat(n.toString(), "' and '").concat(r.toString(), "'")); const i = Cc(e); null !== i && Fy(e, r, i) } const n = function (e, t) { for (const n of e) for (const e of n.getFlattenedFilters()) if (t.indexOf(e.op) >= 0) return e.op; return null }(e.filters, function (e) { switch (e) { case "!=": return ["!=", "not-in"]; case "array-contains-any": case "in": return ["not-in"]; case "not-in": return ["array-contains-any", "in", "not-in", "!="]; default: return [] } }(t.op)); if (null !== n) throw n === t.op ? new Do(No.INVALID_ARGUMENT, "Invalid query. You cannot use more than one '".concat(t.op.toString(), "' filter.")) : new Do(No.INVALID_ARGUMENT, "Invalid query. You cannot use '".concat(t.op.toString(), "' filters with '").concat(n.toString(), "' filters.")) } function Fy(e, t, n) { if (!n.isEqual(t)) throw new Do(No.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '".concat(t.toString(), "' and so you must also use '").concat(t.toString(), "' as your first argument to orderBy(), but your first orderBy() is on field '").concat(n.toString(), "' instead.")) } class My { convertValue(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "none"; switch (xl(e)) { case 0: return null; case 1: return e.booleanValue; case 2: return ml(e.integerValue || e.doubleValue); case 3: return this.convertTimestamp(e.timestampValue); case 4: return this.convertServerTimestamp(e, t); case 5: return e.stringValue; case 6: return this.convertBytes(gl(e.bytesValue)); case 7: return this.convertReference(e.referenceValue); case 8: return this.convertGeoPoint(e.geoPointValue); case 9: return this.convertArray(e.arrayValue, t); case 10: return this.convertObject(e.mapValue, t); default: throw To() } } convertObject(e, t) { return this.convertObjectMap(e.fields, t) } convertObjectMap(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "none"; const n = {}; return nl(e, ((e, r) => { n[e] = this.convertValue(r, t) })), n } convertGeoPoint(e) { return new Hg(ml(e.latitude), ml(e.longitude)) } convertArray(e, t) { return (e.values || []).map((e => this.convertValue(e, t))) } convertServerTimestamp(e, t) { switch (t) { case "previous": const n = vl(e); return null == n ? null : this.convertValue(n, t); case "estimate": return this.convertTimestamp(wl(e)); default: return null } } convertTimestamp(e) { const t = pl(e); return new Go(t.seconds, t.nanos) } convertDocumentKey(e, t) { const n = Wo.fromString(e); ko(Mh(n)); const r = new El(n.get(1), n.get(3)), i = new Yo(n.popFirst(5)); return r.isEqual(t) || _o("Document ".concat(i, " contains a document reference within a different database (").concat(r.projectId, "/").concat(r.database, ") which is not supported. It will be treated as a reference in the current database (").concat(t.projectId, "/").concat(t.database, ") instead.")), i } } function jy(e, t, n) { let r; return r = e ? n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t) : t, r } class Vy extends My { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new qg(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new xg(this.firestore, null, t) } } class By { constructor(e, t) { this.hasPendingWrites = e, this.fromCache = t } isEqual(e) { return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache } } class Uy extends wy { constructor(e, t, n, r, i, s) { super(e, t, n, r, s), this._firestore = e, this._firestoreImpl = e, this.metadata = i } exists() { return super.exists() } data() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (this._document) { if (this._converter) { const t = new zy(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null); return this._converter.fromFirestore(t, e) } return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps) } } get(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this._document) { const n = this._document.data.field(Ey("DocumentSnapshot.get", e)); if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps) } } } class zy extends Uy { data() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return super.data(e) } } class qy { constructor(e, t, n, r) { this._firestore = e, this._userDataWriter = t, this._snapshot = r, this.metadata = new By(r.hasPendingWrites, r.fromCache), this.query = n } get docs() { const e = []; return this.forEach((t => e.push(t))), e } get size() { return this._snapshot.docs.size } get empty() { return 0 === this.size } forEach(e, t) { this._snapshot.docs.forEach((n => { e.call(t, new zy(this._firestore, this._userDataWriter, n.key, n, new By(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter)) })) } docChanges() { const e = !!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeMetadataChanges; if (e && this._snapshot.excludesMetadataChanges) throw new Do(No.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot()."); return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function (e, t) { if (e._snapshot.oldDocs.isEmpty()) { let t = 0; return e._snapshot.docChanges.map((n => { const r = new zy(e._firestore, e._userDataWriter, n.doc.key, n.doc, new By(e._snapshot.mutatedKeys.has(n.doc.key), e._snapshot.fromCache), e.query.converter); return n.doc, { type: "added", doc: r, oldIndex: -1, newIndex: t++ } })) } { let n = e._snapshot.oldDocs; return e._snapshot.docChanges.filter((e => t || 3 !== e.type)).map((t => { const r = new zy(e._firestore, e._userDataWriter, t.doc.key, t.doc, new By(e._snapshot.mutatedKeys.has(t.doc.key), e._snapshot.fromCache), e.query.converter); let i = -1, s = -1; return 0 !== t.type && (i = n.indexOf(t.doc.key), n = n.delete(t.doc.key)), 1 !== t.type && (n = n.add(t.doc), s = n.indexOf(t.doc.key)), { type: Ky(t.type), doc: r, oldIndex: i, newIndex: s } })) } }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges } } function Ky(e) { switch (e) { case 0: return "added"; case 2: case 3: return "modified"; case 1: return "removed"; default: return To() } } function Gy(e, t) { return e instanceof Uy && t instanceof Uy ? e._firestore === t._firestore && e._key.isEqual(t._key) && (null === e._document ? null === t._document : e._document.isEqual(t._document)) && e._converter === t._converter : e instanceof qy && t instanceof qy && e._firestore === t._firestore && Dg(e.query, t.query) && e.metadata.isEqual(t.metadata) && e._snapshot.isEqual(t._snapshot) } class Hy extends My { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new qg(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new xg(this.firestore, null, t) } } function Qy(e) { e = wg(e, xg); const t = wg(e.firestore, Pg), n = Lg(t), r = new Hy(t); return function (e, t) { const n = new Ao; return e.asyncQueue.enqueueAndForget((async () => async function (e, t, n) { try { const r = await function (e, t) { const n = Co(e); return n.persistence.runTransaction("read document", "readonly", (e => n.localDocuments.getDocument(e, t))) }(e, t); r.isFoundDocument() ? n.resolve(r) : r.isNoDocument() ? n.resolve(null) : n.reject(new Do(No.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)")) } catch (e) { const r = Hp(e, "Failed to get document '".concat(t, " from cache")); n.reject(r) } }(await ig(e), t, n))), n.promise }(n, e._key).then((n => new Uy(t, r, e._key, n, new By(null !== n && n.hasLocalMutations, !0), e.converter))) } function Wy(e) { e = wg(e, Ig); const t = wg(e.firestore, Pg), n = Lg(t), r = new Hy(t); return function (e, t) { const n = new Ao; return e.asyncQueue.enqueueAndForget((async () => async function (e, t, n) { try { const r = await jf(e, t, !0), i = new um(t, r.ir), s = i.sc(r.documents), o = i.applyChanges(s, !1); n.resolve(o.snapshot) } catch (e) { const r = Hp(e, "Failed to execute query '".concat(t, " against cache")); n.reject(r) } }(await ig(e), t, n))), n.promise }(n, e._query).then((n => new qy(t, r, e, n))) } function $y(e, t, n) { e = wg(e, xg); const r = wg(e.firestore, Pg), i = jy(e.converter, t, n); return Zy(r, [ey(Zg(r), "setDoc", e._key, i, null !== e.converter, n).toMutation(e._key, wu.none())]) } function Xy(e, t, n) { e = wg(e, xg); const r = wg(e.firestore, Pg), i = Zg(r); let s; for (var o = arguments.length, a = new Array(o > 3 ? o - 3 : 0), l = 3; l < o; l++)a[l - 3] = arguments[l]; return s = "string" == typeof (t = Re(t)) || t instanceof Kg ? ly(i, "updateDoc", e._key, t, n, a) : ay(i, "updateDoc", e._key, t), Zy(r, [s.toMutation(e._key, wu.exists(!0))]) } function Yy(e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; var i, s, o; e = Re(e); let a = { includeMetadataChanges: !1 }, l = 0; "object" != typeof n[l] || Og(n[l]) || (a = n[l], l++); const c = { includeMetadataChanges: a.includeMetadataChanges }; if (Og(n[l])) { const e = n[l]; n[l] = null === (i = e.next) || void 0 === i ? void 0 : i.bind(e), n[l + 1] = null === (s = e.error) || void 0 === s ? void 0 : s.bind(e), n[l + 2] = null === (o = e.complete) || void 0 === o ? void 0 : o.bind(e) } let u, h, d; if (e instanceof xg) h = wg(e.firestore, Pg), d = Tc(e._key.path), u = { next: t => { n[l] && n[l](ev(h, e, t)) }, error: n[l + 1], complete: n[l + 2] }; else { const t = wg(e, Ig); h = wg(t.firestore, Pg), d = t._query; const r = new Hy(h); u = { next: e => { n[l] && n[l](new qy(h, r, t, e)) }, error: n[l + 1], complete: n[l + 2] }, Sy(e._query) } return function (e, t, n, r) { const i = new Qm(r), s = new rm(t, i, n); return e.asyncQueue.enqueueAndForget((async () => Jp(await lg(e), s))), () => { i.Dc(), e.asyncQueue.enqueueAndForget((async () => Zp(await lg(e), s))) } }(Lg(h), d, c, u) } function Jy(e, t) { return function (e, t) { const n = new Qm(t); return e.asyncQueue.enqueueAndForget((async () => function (e, t) { Co(e).ku.add(t), t.next() }(await lg(e), n))), () => { n.Dc(), e.asyncQueue.enqueueAndForget((async () => function (e, t) { Co(e).ku.delete(t) }(await lg(e), n))) } }(Lg(e = wg(e, Pg)), Og(t) ? t : { next: t }) } function Zy(e, t) { return function (e, t) { const n = new Ao; return e.asyncQueue.enqueueAndForget((async () => async function (e, t, n) { const r = Um(e); try { const e = await function (e, t) { const n = Co(e), r = Go.now(), i = t.reduce(((e, t) => e.add(t.key)), Zc()); let s, o; return n.persistence.runTransaction("Locally write mutations", "readwrite", (e => { let a = Kc(), l = Zc(); return n.Zi.getEntries(e, i).next((e => { a = e, a.forEach(((e, t) => { t.isValidDocument() || (l = l.add(e)) })) })).next((() => n.localDocuments.getOverlayedDocuments(e, a))).next((i => { s = i; const o = []; for (const e of t) { const t = Iu(e, s.get(e.key).overlayedDocument); null != t && o.push(new Cu(e.key, t, Kl(t.value.mapValue), wu.exists(!0))) } return n.mutationQueue.addMutationBatch(e, r, o, t) })).next((t => { o = t; const r = t.applyToLocalDocumentSet(s, l); return n.documentOverlayCache.saveOverlays(e, t.batchId, r) })) })).then((() => ({ batchId: o.batchId, changes: Qc(s) }))) }(r.localStore, t); r.sharedClientState.addPendingMutation(e.batchId), function (e, t, n) { let r = e.Tc[e.currentUser.toKey()]; r || (r = new il(zo)), r = r.insert(t, n), e.Tc[e.currentUser.toKey()] = r }(r, e.batchId, n), await Nm(r, e.changes), await Op(r.remoteStore) } catch (e) { const t = Hp(e, "Failed to persist write"); n.reject(t) } }(await og(e), t, n))), n.promise }(Lg(e), t) } function ev(e, t, n) { const r = n.docs.get(t._key), i = new Hy(e); return new Uy(e, i, t._key, r, new By(n.hasPendingWrites, n.fromCache), t.converter) } const tv = { maxAttempts: 5 }; class nv { constructor(e, t) { this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = Zg(e) } set(e, t, n) { this._verifyNotCommitted(); const r = rv(e, this._firestore), i = jy(r.converter, t, n), s = ey(this._dataReader, "WriteBatch.set", r._key, i, null !== r.converter, n); return this._mutations.push(s.toMutation(r._key, wu.none())), this } update(e, t, n) { this._verifyNotCommitted(); const r = rv(e, this._firestore); let i; for (var s = arguments.length, o = new Array(s > 3 ? s - 3 : 0), a = 3; a < s; a++)o[a - 3] = arguments[a]; return i = "string" == typeof (t = Re(t)) || t instanceof Kg ? ly(this._dataReader, "WriteBatch.update", r._key, t, n, o) : ay(this._dataReader, "WriteBatch.update", r._key, t), this._mutations.push(i.toMutation(r._key, wu.exists(!0))), this } delete(e) { this._verifyNotCommitted(); const t = rv(e, this._firestore); return this._mutations = this._mutations.concat(new Ou(t._key, wu.none())), this } commit() { return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve() } _verifyNotCommitted() { if (this._committed) throw new Do(No.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.") } } function rv(e, t) { if ((e = Re(e)).firestore !== t) throw new Do(No.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance."); return e } class iv extends class { constructor(e, t) { this._firestore = e, this._transaction = t, this._dataReader = Zg(e) } get(e) { const t = rv(e, this._firestore), n = new Vy(this._firestore); return this._transaction.lookup([t._key]).then((e => { if (!e || 1 !== e.length) return To(); const r = e[0]; if (r.isFoundDocument()) return new wy(this._firestore, n, r.key, r, t.converter); if (r.isNoDocument()) return new wy(this._firestore, n, t._key, null, t.converter); throw To() })) } set(e, t, n) { const r = rv(e, this._firestore), i = jy(r.converter, t, n), s = ey(this._dataReader, "Transaction.set", r._key, i, null !== r.converter, n); return this._transaction.set(r._key, s), this } update(e, t, n) { const r = rv(e, this._firestore); let i; for (var s = arguments.length, o = new Array(s > 3 ? s - 3 : 0), a = 3; a < s; a++)o[a - 3] = arguments[a]; return i = "string" == typeof (t = Re(t)) || t instanceof Kg ? ly(this._dataReader, "Transaction.update", r._key, t, n, o) : ay(this._dataReader, "Transaction.update", r._key, t), this._transaction.update(r._key, i), this } delete(e) { const t = rv(e, this._firestore); return this._transaction.delete(t._key), this } }{ constructor(e, t) { super(e, t), this._firestore = e } get(e) { const t = rv(e, this._firestore), n = new Hy(this._firestore); return super.get(e).then((e => new Uy(this._firestore, n, t._key, e._document, new By(!1, !1), t.converter))) } } !function (e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; !function (e) { wo = e }(xt), vt(new Pe("firestore", ((e, n) => { let { instanceIdentifier: r, options: i } = n; const s = e.getProvider("app").getImmediate(), o = new Pg(new Lo(e.getProvider("auth-internal")), new Vo(e.getProvider("app-check-internal")), function (e, t) { if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"])) throw new Do(No.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new El(e.options.projectId, t) }(s, r), s); return i = Object.assign({ useFetchStreams: t }, i), o._setSettings(i), o }), "PUBLIC").setMultipleInstances(!0)), Nt(yo, "3.13.0", e), Nt(yo, "3.13.0", "esm2017") }(); function sv(e, t) { if (void 0 === t) return { merge: !1 }; if (void 0 !== t.mergeFields && void 0 !== t.merge) throw new Do("invalid-argument", "Invalid options passed to function ".concat(e, "(): You cannot ") + 'specify both "merge" and "mergeFields".'); return t } function ov() { if ("undefined" === typeof Uint8Array) throw new Do("unimplemented", "Uint8Arrays are not available in this environment.") } function av() { if ("undefined" == typeof atob) throw new Do("unimplemented", "Blobs are unavailable in Firestore in this environment.") } class lv { constructor(e) { this._delegate = e } static fromBase64String(e) { return av(), new lv(qg.fromBase64String(e)) } static fromUint8Array(e) { return ov(), new lv(qg.fromUint8Array(e)) } toBase64() { return av(), this._delegate.toBase64() } toUint8Array() { return ov(), this._delegate.toUint8Array() } isEqual(e) { return this._delegate.isEqual(e._delegate) } toString() { return "Blob(base64: " + this.toBase64() + ")" } } function cv(e) { return function (e, t) { if ("object" !== typeof e || null === e) return !1; const n = e; for (const r of t) if (r in n && "function" === typeof n[r]) return !0; return !1 }(e, ["next", "error", "complete"]) } class uv { enableIndexedDbPersistence(e, t) { return function (e, t) { zg(e = wg(e, Pg)); const n = Lg(e); if (n._uninitializedComponentsProvider) throw new Do(No.FAILED_PRECONDITION, "SDK cache is already specified."); xo("enableIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead."); const r = e._freezeSettings(), i = new Gm; return Mg(n, i, new qm(i, r.cacheSizeBytes, null == t ? void 0 : t.forceOwnership)) }(e._delegate, { forceOwnership: t }) } enableMultiTabIndexedDbPersistence(e) { return function (e) { zg(e = wg(e, Pg)); const t = Lg(e); if (t._uninitializedComponentsProvider) throw new Do(No.FAILED_PRECONDITION, "SDK cache is already specified."); xo("enableMultiTabIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead."); const n = e._freezeSettings(), r = new Gm; return Mg(t, r, new Km(r, n.cacheSizeBytes)) }(e._delegate) } clearIndexedDbPersistence(e) { return function (e) { if (e._initialized && !e._terminated) throw new Do(No.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated."); const t = new Ao; return e._queue.enqueueAndForgetEvenWhileRestricted((async () => { try { await async function (e) { if (!da.D()) return Promise.resolve(); const t = e + "main"; await da.delete(t) }(kf(e._databaseId, e._persistenceKey)), t.resolve() } catch (e) { t.reject(e) } })), t.promise }(e._delegate) } } class hv { constructor(e, t, n) { this._delegate = t, this._persistenceProvider = n, this.INTERNAL = { delete: () => this.terminate() }, e instanceof El || (this._appCompat = e) } get _databaseId() { return this._delegate._databaseId } settings(e) { const t = this._delegate._getSettings(); e.merge || t.host === e.host || xo("You are overriding the original host. If you did not intend to override your settings, use {merge: true}."), e.merge && delete (e = Object.assign(Object.assign({}, t), e)).merge, this._delegate._setSettings(e) } useEmulator(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; _g(this._delegate, e, t, n) } enableNetwork() { return Vg(this._delegate) } disableNetwork() { return Bg(this._delegate) } enablePersistence(e) { let t = !1, n = !1; return e && (t = !!e.synchronizeTabs, n = !!e.experimentalForceOwningTab, mg("synchronizeTabs", t, "experimentalForceOwningTab", n)), t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, n) } clearPersistence() { return this._persistenceProvider.clearIndexedDbPersistence(this) } terminate() { return this._appCompat && (this._appCompat._removeServiceInstance("firestore-compat"), this._appCompat._removeServiceInstance("firestore")), this._delegate._delete() } waitForPendingWrites() { return jg(this._delegate) } onSnapshotsInSync(e) { return Jy(this._delegate, e) } get app() { if (!this._appCompat) throw new Do("failed-precondition", "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._appCompat } collection(e) { try { return new Iv(this, kg(this._delegate, e)) } catch (t) { throw yv(t, "collection()", "Firestore.collection()") } } doc(e) { try { return new gv(this, Cg(this._delegate, e)) } catch (t) { throw yv(t, "doc()", "Firestore.doc()") } } collectionGroup(e) { try { return new Sv(this, function (e, t) { if (e = wg(e, Sg), pg("collectionGroup", "collection id", t), t.indexOf("/") >= 0) throw new Do(No.INVALID_ARGUMENT, "Invalid collection ID '".concat(t, "' passed to function collectionGroup(). Collection IDs must not contain '/'.")); return new Ig(e, null, function (e) { return new xc(Wo.emptyPath(), e) }(t)) }(this._delegate, e)) } catch (t) { throw yv(t, "collectionGroup()", "Firestore.collectionGroup()") } } runTransaction(e) { return function (e, t, n) { e = wg(e, Pg); const r = Object.assign(Object.assign({}, tv), n); return function (e) { if (e.maxAttempts < 1) throw new Do(No.INVALID_ARGUMENT, "Max attempts must be at least 1") }(r), function (e, t, n) { const r = new Ao; return e.asyncQueue.enqueueAndForget((async () => { const i = await ag(e); new Xm(e.asyncQueue, i, n, t, r).run() })), r.promise }(Lg(e), (n => t(new iv(e, n))), r) }(this._delegate, (t => e(new fv(this, t)))) } batch() { return Lg(this._delegate), new pv(new nv(this._delegate, (e => Zy(this._delegate, e)))) } loadBundle(e) { return function (e, t) { const n = Lg(e = wg(e, Pg)), r = new Rg; return hg(n, e._databaseId, t, r), r }(this._delegate, e) } namedQuery(e) { return Ug(this._delegate, e).then((e => e ? new Sv(this, e) : null)) } } class dv extends My { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new lv(new qg(e)) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return gv.forKey(t, this.firestore, null) } } class fv { constructor(e, t) { this._firestore = e, this._delegate = t, this._userDataWriter = new dv(e) } get(e) { const t = Tv(e); return this._delegate.get(t).then((e => new bv(this._firestore, new Uy(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, t.converter)))) } set(e, t, n) { const r = Tv(e); return n ? (sv("Transaction.set", n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this } update(e, t, n) { for (var r = arguments.length, i = new Array(r > 3 ? r - 3 : 0), s = 3; s < r; s++)i[s - 3] = arguments[s]; const o = Tv(e); return 2 === arguments.length ? this._delegate.update(o, t) : this._delegate.update(o, t, n, ...i), this } delete(e) { const t = Tv(e); return this._delegate.delete(t), this } } class pv { constructor(e) { this._delegate = e } set(e, t, n) { const r = Tv(e); return n ? (sv("WriteBatch.set", n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this } update(e, t, n) { for (var r = arguments.length, i = new Array(r > 3 ? r - 3 : 0), s = 3; s < r; s++)i[s - 3] = arguments[s]; const o = Tv(e); return 2 === arguments.length ? this._delegate.update(o, t) : this._delegate.update(o, t, n, ...i), this } delete(e) { const t = Tv(e); return this._delegate.delete(t), this } commit() { return this._delegate.commit() } } class mv { constructor(e, t, n) { this._firestore = e, this._userDataWriter = t, this._delegate = n } fromFirestore(e, t) { const n = new zy(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, null); return this._delegate.fromFirestore(new Ev(this._firestore, n), null !== t && void 0 !== t ? t : {}) } toFirestore(e, t) { return t ? this._delegate.toFirestore(e, t) : this._delegate.toFirestore(e) } static getInstance(e, t) { const n = mv.INSTANCES; let r = n.get(e); r || (r = new WeakMap, n.set(e, r)); let i = r.get(t); return i || (i = new mv(e, new dv(e), t), r.set(t, i)), i } } mv.INSTANCES = new WeakMap; class gv { constructor(e, t) { this.firestore = e, this._delegate = t, this._userDataWriter = new dv(e) } static forPath(e, t, n) { if (e.length % 2 !== 0) throw new Do("invalid-argument", "Invalid document reference. Document references must have an even number of segments, but " + "".concat(e.canonicalString(), " has ").concat(e.length)); return new gv(t, new xg(t._delegate, n, new Yo(e))) } static forKey(e, t, n) { return new gv(t, new xg(t._delegate, n, e)) } get id() { return this._delegate.id } get parent() { return new Iv(this.firestore, this._delegate.parent) } get path() { return this._delegate.path } collection(e) { try { return new Iv(this.firestore, kg(this._delegate, e)) } catch (t) { throw yv(t, "collection()", "DocumentReference.collection()") } } isEqual(e) { return (e = Re(e)) instanceof xg && Ng(this._delegate, e) } set(e, t) { t = sv("DocumentReference.set", t); try { return t ? $y(this._delegate, e, t) : $y(this._delegate, e) } catch (n) { throw yv(n, "setDoc()", "DocumentReference.set()") } } update(e, t) { for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)r[i - 2] = arguments[i]; try { return 1 === arguments.length ? Xy(this._delegate, e) : Xy(this._delegate, e, t, ...r) } catch (s) { throw yv(s, "updateDoc()", "DocumentReference.update()") } } delete() { return Zy(wg((e = this._delegate).firestore, Pg), [new Ou(e._key, wu.none())]); var e } onSnapshot() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const r = vv(t), i = wv(t, (e => new bv(this.firestore, new Uy(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)))); return Yy(this._delegate, r, i) } get(e) { let t; return t = "cache" === (null === e || void 0 === e ? void 0 : e.source) ? Qy(this._delegate) : "server" === (null === e || void 0 === e ? void 0 : e.source) ? function (e) { e = wg(e, xg); const t = wg(e.firestore, Pg); return cg(Lg(t), e._key, { source: "server" }).then((n => ev(t, e, n))) }(this._delegate) : function (e) { e = wg(e, xg); const t = wg(e.firestore, Pg); return cg(Lg(t), e._key).then((n => ev(t, e, n))) }(this._delegate), t.then((e => new bv(this.firestore, new Uy(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter)))) } withConverter(e) { return new gv(this.firestore, e ? this._delegate.withConverter(mv.getInstance(this.firestore, e)) : this._delegate.withConverter(null)) } } function yv(e, t, n) { return e.message = e.message.replace(t, n), e } function vv(e) { for (const t of e) if ("object" === typeof t && !cv(t)) return t; return {} } function wv(e, t) { var n, r; let i; return i = cv(e[0]) ? e[0] : cv(e[1]) ? e[1] : "function" === typeof e[0] ? { next: e[0], error: e[1], complete: e[2] } : { next: e[1], error: e[2], complete: e[3] }, { next: e => { i.next && i.next(t(e)) }, error: null === (n = i.error) || void 0 === n ? void 0 : n.bind(i), complete: null === (r = i.complete) || void 0 === r ? void 0 : r.bind(i) } } class bv { constructor(e, t) { this._firestore = e, this._delegate = t } get ref() { return new gv(this._firestore, this._delegate.ref) } get id() { return this._delegate.id } get metadata() { return this._delegate.metadata } get exists() { return this._delegate.exists() } data(e) { return this._delegate.data(e) } get(e, t) { return this._delegate.get(e, t) } isEqual(e) { return Gy(this._delegate, e._delegate) } } class Ev extends bv { data(e) { const t = this._delegate.data(e); return void 0 !== t || To(), t } } class Sv { constructor(e, t) { this.firestore = e, this._delegate = t, this._userDataWriter = new dv(e) } where(e, t, n) { try { return new Sv(this.firestore, Iy(this._delegate, function (e, t, n) { const r = t, i = Ey("where", e); return Ty._create(i, r, n) }(e, t, n))) } catch (r) { throw yv(r, /(orderBy|where)\(\)/, "Query.$1()") } } orderBy(e, t) { try { return new Sv(this.firestore, Iy(this._delegate, function (e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc", n = Ey("orderBy", e); return Cy._create(n, t) }(e, t))) } catch (n) { throw yv(n, /(orderBy|where)\(\)/, "Query.$1()") } } limit(e) { try { return new Sv(this.firestore, Iy(this._delegate, (bg("limit", t = e), Ny._create("limit", t, "F")))) } catch (n) { throw yv(n, "limit()", "Query.limit()") } var t } limitToLast(e) { try { return new Sv(this.firestore, Iy(this._delegate, (bg("limitToLast", t = e), Ny._create("limitToLast", t, "L")))) } catch (n) { throw yv(n, "limitToLast()", "Query.limitToLast()") } var t } startAt() { try { return new Sv(this.firestore, Iy(this._delegate, function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return Dy._create("startAt", t, !0) }(...arguments))) } catch (e) { throw yv(e, "startAt()", "Query.startAt()") } } startAfter() { try { return new Sv(this.firestore, Iy(this._delegate, function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return Dy._create("startAfter", t, !1) }(...arguments))) } catch (e) { throw yv(e, "startAfter()", "Query.startAfter()") } } endBefore() { try { return new Sv(this.firestore, Iy(this._delegate, function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return Ay._create("endBefore", t, !1) }(...arguments))) } catch (e) { throw yv(e, "endBefore()", "Query.endBefore()") } } endAt() { try { return new Sv(this.firestore, Iy(this._delegate, function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return Ay._create("endAt", t, !0) }(...arguments))) } catch (e) { throw yv(e, "endAt()", "Query.endAt()") } } isEqual(e) { return Dg(this._delegate, e._delegate) } get(e) { let t; return t = "cache" === (null === e || void 0 === e ? void 0 : e.source) ? Wy(this._delegate) : "server" === (null === e || void 0 === e ? void 0 : e.source) ? function (e) { e = wg(e, Ig); const t = wg(e.firestore, Pg), n = Lg(t), r = new Hy(t); return ug(n, e._query, { source: "server" }).then((n => new qy(t, r, e, n))) }(this._delegate) : function (e) { e = wg(e, Ig); const t = wg(e.firestore, Pg), n = Lg(t), r = new Hy(t); return Sy(e._query), ug(n, e._query).then((n => new qy(t, r, e, n))) }(this._delegate), t.then((e => new xv(this.firestore, new qy(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)))) } onSnapshot() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const r = vv(t), i = wv(t, (e => new xv(this.firestore, new qy(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot)))); return Yy(this._delegate, r, i) } withConverter(e) { return new Sv(this.firestore, e ? this._delegate.withConverter(mv.getInstance(this.firestore, e)) : this._delegate.withConverter(null)) } } class _v { constructor(e, t) { this._firestore = e, this._delegate = t } get type() { return this._delegate.type } get doc() { return new Ev(this._firestore, this._delegate.doc) } get oldIndex() { return this._delegate.oldIndex } get newIndex() { return this._delegate.newIndex } } class xv { constructor(e, t) { this._firestore = e, this._delegate = t } get query() { return new Sv(this._firestore, this._delegate.query) } get metadata() { return this._delegate.metadata } get size() { return this._delegate.size } get empty() { return this._delegate.empty } get docs() { return this._delegate.docs.map((e => new Ev(this._firestore, e))) } docChanges(e) { return this._delegate.docChanges(e).map((e => new _v(this._firestore, e))) } forEach(e, t) { this._delegate.forEach((n => { e.call(t, new Ev(this._firestore, n)) })) } isEqual(e) { return Gy(this._delegate, e._delegate) } } class Iv extends Sv { constructor(e, t) { super(e, t), this.firestore = e, this._delegate = t } get id() { return this._delegate.id } get path() { return this._delegate.path } get parent() { const e = this._delegate.parent; return e ? new gv(this.firestore, e) : null } doc(e) { try { return new gv(this.firestore, void 0 === e ? Cg(this._delegate) : Cg(this._delegate, e)) } catch (t) { throw yv(t, "doc()", "CollectionReference.doc()") } } add(e) { return function (e, t) { const n = wg(e.firestore, Pg), r = Cg(e), i = jy(e.converter, t); return Zy(n, [ey(Zg(e.firestore), "addDoc", r._key, i, null !== e.converter, {}).toMutation(r._key, wu.exists(!1))]).then((() => r)) }(this._delegate, e).then((e => new gv(this.firestore, e))) } isEqual(e) { return Ng(this._delegate, e._delegate) } withConverter(e) { return new Iv(this.firestore, e ? this._delegate.withConverter(mv.getInstance(this.firestore, e)) : this._delegate.withConverter(null)) } } function Tv(e) { return wg(e, xg) } class kv { constructor() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._delegate = new Kg(...t) } static documentId() { return new kv(Xo.keyField().canonicalString()) } isEqual(e) { return (e = Re(e)) instanceof Kg && this._delegate._internalPath.isEqual(e._internalPath) } } class Cv { constructor(e) { this._delegate = e } static serverTimestamp() { const e = new ry("serverTimestamp"); return e._methodName = "FieldValue.serverTimestamp", new Cv(e) } static delete() { const e = new ty("deleteField"); return e._methodName = "FieldValue.delete", new Cv(e) } static arrayUnion() { const e = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return new iy("arrayUnion", t) }(...arguments); return e._methodName = "FieldValue.arrayUnion", new Cv(e) } static arrayRemove() { const e = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return new sy("arrayRemove", t) }(...arguments); return e._methodName = "FieldValue.arrayRemove", new Cv(e) } static increment(e) { const t = new oy("increment", e); return t._methodName = "FieldValue.increment", new Cv(t) } isEqual(e) { return this._delegate.isEqual(e._delegate) } } const Nv = { Firestore: hv, GeoPoint: Hg, Timestamp: Go, Blob: lv, Transaction: fv, WriteBatch: pv, DocumentReference: gv, DocumentSnapshot: bv, Query: Sv, QueryDocumentSnapshot: Ev, QuerySnapshot: xv, CollectionReference: Iv, FieldPath: kv, FieldValue: Cv, setLogLevel: function (e) { var t; t = e, bo.setLogLevel(t) }, CACHE_SIZE_UNLIMITED: -1 }; !function (e) { !function (e, t) { e.INTERNAL.registerComponent(new Pe("firestore-compat", (e => { const n = e.getProvider("app-compat").getImmediate(), r = e.getProvider("firestore").getImmediate(); return t(n, r) }), "PUBLIC").setServiceProps(Object.assign({}, Nv))) }(e, ((e, t) => new hv(e, t, new uv))), e.registerVersion("@firebase/firestore-compat", "0.3.12") }(Wt); const Dv = Wt.initializeApp({ apiKey: "AIzaSyCxkCiCBK3jwoncU6ImOnySFDZ6pXNaEGI", authDomain: "blogging-website-3c10f.firebaseapp.com", projectId: "blogging-website-3c10f", storageBucket: "blogging-website-3c10f.appspot.com", messagingSenderId: "380720413493", appId: "1:380720413493:web:8922ee416ad6c7d497ea7c", measurementId: "G-STPZ0312NV" }).firestore(), Av = () => { document.querySelector(".blogs-section"); Dv.collection("blogs").get().then((e => { e.forEach((e => { const t = e.id, n = e.data().bannerImage.split("/"); if (n[2] !== "localhost:".concat(3e3)) { n[2] = "localhost:".concat(3e3); let e = ""; for (let t = 0; t < n.length - 1; t++)e += n[t] + "/"; Dv.collection("blogs").doc(t).update({ bannerImage: e }) } })) })); let e = 0; Dv.collection("blogs").where("publishedAt_month", ">", 1).orderBy("publishedAt_month", "desc").get().then((n => { n.forEach((n => { (null === n || void 0 === n ? void 0 : n.id) !== decodeURI(window.location.pathname.split("/").pop()) && e < 4 ? (console.log("createBlog fun is called"), t(n)) : (null === n || void 0 === n ? void 0 : n.id) === decodeURI(window.location.pathname.split("/").pop()) && e--, e++ })), document.querySelector(".blogs-section").innerHTML = "" })); const t = async e => { let t, n = await e.data(), r = await n.article; (await r.split("\n").filter((e => e.length))).forEach((e => { "#" === e[0] || "!" === e[0] || (t = e) })), console.log(n.bannerImage), document.querySelector(".blogs-section").innerHTML += '\n        <div class="blog-card">\n                <img src="'.concat(n.bannerImage, '"\n                    alt="Loading your Image" class="blog-image" />\n\n                <div class="blog-items">\n                    <h1 class="blog-title fw-bolder">').concat(n.title.substring(0, 100) + "...", '</h1>\n                    <p class="blog-overview">').concat(t.substring(0, 200) + "...", '</p>\n                    <a href="/').concat(e.id, '" class="btn dark">Read</a>\n                </div\n            </div>\n        ') }; return (0, ce.jsxs)(ce.Fragment, { children: [(0, ce.jsx)("div", { className: "header", children: (0, ce.jsxs)("div", { className: "content", children: [(0, ce.jsxs)("h1", { className: "heading", children: [(0, ce.jsx)("span", { className: "small", children: "Welcome in the world of" }), "blog", (0, ce.jsx)("span", { className: "no-fill", children: "writing" })] }), (0, ce.jsx)("a", { href: "/editor", className: "btn", children: "Write a Blog" })] }) }), (0, ce.jsx)("div", { className: "blog-heading", children: (0, ce.jsx)("h1", { children: "Latest Published..." }) }), (0, ce.jsx)("div", { className: "blogs-section" })] }) }; var Ov = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, Rv = t.createContext && t.createContext(Ov), Pv = function () { return Pv = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, Pv.apply(this, arguments) }, Lv = function (e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" === typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n }; function Fv(e) { return e && e.map((function (e, n) { return t.createElement(e.tag, Pv({ key: n }, e.attr), Fv(e.child)) })) } function Mv(e) { return function (n) { return t.createElement(jv, Pv({ attr: Pv({}, e.attr) }, n), Fv(e.child)) } } function jv(e) { var n = function (n) { var r, i = e.attr, s = e.size, o = e.title, a = Lv(e, ["attr", "size", "title"]), l = s || n.size || "1em"; return n.className && (r = n.className), e.className && (r = (r ? r + " " : "") + e.className), t.createElement("svg", Pv({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, i, a, { className: r, style: Pv(Pv({ color: e.color || n.color }, n.style), e.style), height: l, width: l, xmlns: "http://www.w3.org/2000/svg" }), o && t.createElement("title", null, o), e.children) }; return void 0 !== Rv ? t.createElement(Rv.Consumer, null, (function (e) { return n(e) })) : n(Ov) } function Vv(e) { return Mv({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M16 8.049c0-4.446-3.582-8.05-8-8.05C3.58 0-.002 3.603-.002 8.05c0 4.017 2.926 7.347 6.75 7.951v-5.625h-2.03V8.05H6.75V6.275c0-2.017 1.195-3.131 3.022-3.131.876 0 1.791.157 1.791.157v1.98h-1.009c-.993 0-1.303.621-1.303 1.258v1.51h2.218l-.354 2.326H9.25V16c3.824-.604 6.75-3.934 6.75-7.951z" } }] })(e) } function Bv(e) { return Mv({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" } }] })(e) } function Uv(e) { return Mv({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M15.545 6.558a9.42 9.42 0 0 1 .139 1.626c0 2.434-.87 4.492-2.384 5.885h.002C11.978 15.292 10.158 16 8 16A8 8 0 1 1 8 0a7.689 7.689 0 0 1 5.352 2.082l-2.284 2.284A4.347 4.347 0 0 0 8 3.166c-2.087 0-3.86 1.408-4.492 3.304a4.792 4.792 0 0 0 0 3.063h.003c.635 1.893 2.405 3.301 4.492 3.301 1.078 0 2.004-.276 2.722-.764h-.003a3.702 3.702 0 0 0 1.599-2.431H8v-3.08h7.545z" } }] })(e) } function zv(e) { return Mv({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M8 0C5.829 0 5.556.01 4.703.048 3.85.088 3.269.222 2.76.42a3.917 3.917 0 0 0-1.417.923A3.927 3.927 0 0 0 .42 2.76C.222 3.268.087 3.85.048 4.7.01 5.555 0 5.827 0 8.001c0 2.172.01 2.444.048 3.297.04.852.174 1.433.372 1.942.205.526.478.972.923 1.417.444.445.89.719 1.416.923.51.198 1.09.333 1.942.372C5.555 15.99 5.827 16 8 16s2.444-.01 3.298-.048c.851-.04 1.434-.174 1.943-.372a3.916 3.916 0 0 0 1.416-.923c.445-.445.718-.891.923-1.417.197-.509.332-1.09.372-1.942C15.99 10.445 16 10.173 16 8s-.01-2.445-.048-3.299c-.04-.851-.175-1.433-.372-1.941a3.926 3.926 0 0 0-.923-1.417A3.911 3.911 0 0 0 13.24.42c-.51-.198-1.092-.333-1.943-.372C10.443.01 10.172 0 7.998 0h.003zm-.717 1.442h.718c2.136 0 2.389.007 3.232.046.78.035 1.204.166 1.486.275.373.145.64.319.92.599.28.28.453.546.598.92.11.281.24.705.275 1.485.039.843.047 1.096.047 3.231s-.008 2.389-.047 3.232c-.035.78-.166 1.203-.275 1.485a2.47 2.47 0 0 1-.599.919c-.28.28-.546.453-.92.598-.28.11-.704.24-1.485.276-.843.038-1.096.047-3.232.047s-2.39-.009-3.233-.047c-.78-.036-1.203-.166-1.485-.276a2.478 2.478 0 0 1-.92-.598 2.48 2.48 0 0 1-.6-.92c-.109-.281-.24-.705-.275-1.485-.038-.843-.046-1.096-.046-3.233 0-2.136.008-2.388.046-3.231.036-.78.166-1.204.276-1.486.145-.373.319-.64.599-.92.28-.28.546-.453.92-.598.282-.11.705-.24 1.485-.276.738-.034 1.024-.044 2.515-.045v.002zm4.988 1.328a.96.96 0 1 0 0 1.92.96.96 0 0 0 0-1.92zm-4.27 1.122a4.109 4.109 0 1 0 0 8.217 4.109 4.109 0 0 0 0-8.217zm0 1.441a2.667 2.667 0 1 1 0 5.334 2.667 2.667 0 0 1 0-5.334z" } }] })(e) } function qv(e) { return Mv({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822 0-1.359.54-1.359 1.248 0 .694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54 0 0 1 .016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225h2.4z" } }] })(e) } function Kv(e) { return Mv({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" } }] })(e) } const Gv = () => (0, ce.jsx)(ce.Fragment, { children: (0, ce.jsxs)("footer", { className: "bg-dark text-center text-white", children: [(0, ce.jsxs)("div", { className: "container p-4", children: [(0, ce.jsxs)("section", { className: "mb-4", children: [(0, ce.jsx)("a", { className: "btn btn-outline-light btn-floating m-1", href: "#!", role: "button", children: (0, ce.jsx)("i", { className: "fab fa-facebook-f", children: (0, ce.jsx)(Vv, {}) }) }), (0, ce.jsx)("a", { className: "btn btn-outline-light btn-floating m-1", href: "#!", role: "button", children: (0, ce.jsx)("i", { className: "fab fa-twitter", children: (0, ce.jsx)(Kv, {}) }) }), (0, ce.jsx)("a", { className: "btn btn-outline-light btn-floating m-1", href: "#!", role: "button", children: (0, ce.jsx)("i", { className: "fab fa-google", children: (0, ce.jsx)(Uv, {}) }) }), (0, ce.jsx)("a", { className: "btn btn-outline-light btn-floating m-1", href: "#!", role: "button", children: (0, ce.jsx)("i", { className: "fab fa-instagram", children: (0, ce.jsx)(zv, {}) }) }), (0, ce.jsx)("a", { className: "btn btn-outline-light btn-floating m-1", href: "#!", role: "button", children: (0, ce.jsx)("i", { className: "fab fa-linkedin-in", children: (0, ce.jsx)(qv, {}) }) }), (0, ce.jsx)("a", { className: "btn btn-outline-light btn-floating m-1", href: "#!", role: "button", children: (0, ce.jsx)("i", { className: "fab fa-github", children: (0, ce.jsx)(Bv, {}) }) })] }), (0, ce.jsx)("section", { children: (0, ce.jsx)("form", { action: "", children: (0, ce.jsxs)("div", { className: "row d-flex justify-content-center", children: [(0, ce.jsx)("div", { className: "col-auto", children: (0, ce.jsx)("p", { className: "pt-2", children: (0, ce.jsx)("strong", { children: "Sign up for our newsletter" }) }) }), (0, ce.jsx)("div", { className: "col-md-5 col-12", children: (0, ce.jsxs)("div", { className: "form-outline form-white mb-4", children: [(0, ce.jsx)("input", { type: "email", id: "form5Example21", className: "form-control" }), (0, ce.jsx)("label", { className: "form-label", htmlFor: "form5Example21", children: "Email address" })] }) }), (0, ce.jsx)("div", { className: "col-auto", children: (0, ce.jsx)("button", { type: "submit", className: "btn btn-outline-light mb-4", children: "Subscribe" }) })] }) }) }), (0, ce.jsx)("section", { className: "mb-4", children: (0, ce.jsx)("p", { children: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Sunt distinctio earum repellat quaerat voluptatibus placeat nam, commodi optio pariatur est quia magnam eum harum corrupti dicta, aliquam sequi voluptate quas." }) }), (0, ce.jsx)("section", { children: (0, ce.jsxs)("div", { className: "row", children: [(0, ce.jsxs)("div", { className: "col-lg-3 col-md-6 mb-4 mb-md-0", children: [(0, ce.jsx)("h5", { className: "text-uppercase", children: "Links" }), (0, ce.jsxs)("ul", { className: "list-unstyled mb-0", children: [(0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 1" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 2" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 3" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 4" }) })] })] }), (0, ce.jsxs)("div", { className: "col-lg-3 col-md-6 mb-4 mb-md-0", children: [(0, ce.jsx)("h5", { className: "text-uppercase", children: "Help" }), (0, ce.jsxs)("ul", { className: "list-unstyled mb-0", children: [(0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Help Center" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Help Forum" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Video Tutorials" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 4" }) })] })] }), (0, ce.jsxs)("div", { className: "col-lg-3 col-md-6 mb-4 mb-md-0", children: [(0, ce.jsx)("h5", { className: "text-uppercase", children: "Links" }), (0, ce.jsxs)("ul", { className: "list-unstyled mb-0", children: [(0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 1" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 2" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 3" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 4" }) })] })] }), (0, ce.jsxs)("div", { className: "col-lg-3 col-md-6 mb-4 mb-md-0", children: [(0, ce.jsx)("h5", { className: "text-uppercase", children: "Links" }), (0, ce.jsxs)("ul", { className: "list-unstyled mb-0", children: [(0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 1" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 2" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 3" }) }), (0, ce.jsx)("li", { children: (0, ce.jsx)("a", { href: "#!", className: "text-white", children: "Link 4" }) })] })] })] }) })] }), (0, ce.jsxs)("div", { className: "text-center p-3", style: { "background-color": "rgba(0, 0, 0, 0.2)" }, children: ["\xa9 2020 Copyright:", (0, ce.jsx)("a", { className: "text-white", href: "https://mdbootstrap.com/", children: "MDBootstrap.com" })] })] }) }), Hv = (e => t => { let { ...n } = t; return (0, ce.jsxs)(ce.Fragment, { children: [(0, ce.jsx)(ue, {}), (0, ce.jsx)(e, { ...n }), (0, ce.jsx)(Gv, {})] }) })(Av), Qv = () => { const e = decodeURI(window.location.pathname.split("/").pop()); Dv.collection("blogs").doc(e).get().then((e => { e.exists ? t(e.data()) : window.location.replace("/") })).catch((e => { console.log(e) })); const t = e => { const t = document.querySelector(".banner"), r = (document.querySelector(".title"), document.querySelector(".title")), i = document.querySelector(".published"); t.style.backgroundImage = 'url("'.concat(e.bannerImage, '")'), r.innerHTML += e.title; i.innerHTML += "".concat(e.publishedAt_date, " ").concat(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][e.publishedAt_month], " ").concat(e.publishedAt_year); const s = document.querySelector(".article"), o = document.querySelector(".article-image-collection"); n(s, o, e.article) }, n = (e, t, n) => { n = n.split("\n").filter((e => e.length)); let r = !0, i = 1; n.forEach((n => { if ("#" === n[0]) { !1 === r && i < 6 && i++; let t = "h".concat(i); e.innerHTML += "<".concat(t, ">").concat(n.slice(0, n.length), "</").concat(t, ">"), r = !1 } else if ("!" === n[0] && "[" === n[1]) { let e; for (let t = 0; t <= n.length; t++)"]" === n[t] && "(" === n[t + 1] && ")" === n[n.length - 1] && (e = t); let r = n.slice(2, e), i = n.slice(e + 2, n.length - 1); t.innerHTML += '<img src="'.concat(i, '" alt="').concat(r, '" class="article-image" />') } else e.innerHTML += "<p>".concat(n, "</p>") })) }; let r = 0; Dv.collection("blogs").where("publishedAt_month", ">", 1).orderBy("publishedAt_month", "desc").get().then((e => { e.forEach((e => { (null === e || void 0 === e ? void 0 : e.id) !== decodeURI(window.location.pathname.split("/").pop()) && r < 4 ? (console.log("createBlog fun is called"), i(e)) : (null === e || void 0 === e ? void 0 : e.id) === decodeURI(window.location.pathname.split("/").pop()) && r--, r++ })) })); const i = async e => { let t, n = await e.data(), r = await n.article; (await r.split("\n").filter((e => e.length))).forEach((e => { "#" === e[0] || "!" === e[0] || (t = e) })), console.log(n.bannerImage), document.querySelector(".blogs-section").innerHTML += '\n        <div class="blog-card">\n                <img src="'.concat(n.bannerImage, '"\n                    alt="Loading your Image" class="blog-image" />\n\n                <div class="blog-items">\n                    <h1 class="blog-title fw-bolder">').concat(n.title.substring(0, 100) + "...", '</h1>\n                    <p class="blog-overview">').concat(t.substring(0, 200) + "...", '</p>\n                    <a href="/').concat(e.id, '" class="btn dark">Read</a>\n                </div\n            </div>\n        ') }; return (0, ce.jsxs)(ce.Fragment, { children: [(0, ce.jsx)("div", { className: "banner" }), (0, ce.jsxs)("div", { className: "blog", children: [(0, ce.jsxs)("div", { className: "info-container", children: [(0, ce.jsx)("h1", { className: "title" }), (0, ce.jsx)("p", { className: "published", children: (0, ce.jsx)("span", { children: "Published at - " }) }), (0, ce.jsx)("div", { className: "article" })] }), (0, ce.jsx)("div", { className: "article-image-collection" }), (0, ce.jsx)("h1", { className: "sub-heading", children: "Recomended..." }), (0, ce.jsx)("div", { className: "blogs-section" })] })] }) }; function Wv(e, t) { return function () { return e.apply(t, arguments) } } const { toString: $v } = Object.prototype, { getPrototypeOf: Xv } = Object, Yv = (Jv = Object.create(null), e => { const t = $v.call(e); return Jv[t] || (Jv[t] = t.slice(8, -1).toLowerCase()) }); var Jv; const Zv = e => (e = e.toLowerCase(), t => Yv(t) === e), ew = e => t => typeof t === e, { isArray: tw } = Array, nw = ew("undefined"); const rw = Zv("ArrayBuffer"); const iw = ew("string"), sw = ew("function"), ow = ew("number"), aw = e => null !== e && "object" === typeof e, lw = e => { if ("object" !== Yv(e)) return !1; const t = Xv(e); return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) }, cw = Zv("Date"), uw = Zv("File"), hw = Zv("Blob"), dw = Zv("FileList"), fw = Zv("URLSearchParams"); function pw(e, t) { let n, r, { allOwnKeys: i = !1 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (null !== e && "undefined" !== typeof e) if ("object" !== typeof e && (e = [e]), tw(e)) for (n = 0, r = e.length; n < r; n++)t.call(null, e[n], n, e); else { const r = i ? Object.getOwnPropertyNames(e) : Object.keys(e), s = r.length; let o; for (n = 0; n < s; n++)o = r[n], t.call(null, e[o], o, e) } } function mw(e, t) { t = t.toLowerCase(); const n = Object.keys(e); let r, i = n.length; for (; i-- > 0;)if (r = n[i], t === r.toLowerCase()) return r; return null } const gw = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : global, yw = e => !nw(e) && e !== gw; const vw = (ww = "undefined" !== typeof Uint8Array && Xv(Uint8Array), e => ww && e instanceof ww); var ww; const bw = Zv("HTMLFormElement"), Ew = (e => { let { hasOwnProperty: t } = e; return (e, n) => t.call(e, n) })(Object.prototype), Sw = Zv("RegExp"), _w = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; pw(n, ((n, i) => { let s; !1 !== (s = t(n, i, e)) && (r[i] = s || n) })), Object.defineProperties(e, r) }, xw = "abcdefghijklmnopqrstuvwxyz", Iw = "0123456789", Tw = { DIGIT: Iw, ALPHA: xw, ALPHA_DIGIT: xw + xw.toUpperCase() + Iw }; const kw = Zv("AsyncFunction"), Cw = { isArray: tw, isArrayBuffer: rw, isBuffer: function (e) { return null !== e && !nw(e) && null !== e.constructor && !nw(e.constructor) && sw(e.constructor.isBuffer) && e.constructor.isBuffer(e) }, isFormData: e => { let t; return e && ("function" === typeof FormData && e instanceof FormData || sw(e.append) && ("formdata" === (t = Yv(e)) || "object" === t && sw(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && rw(e.buffer), t }, isString: iw, isNumber: ow, isBoolean: e => !0 === e || !1 === e, isObject: aw, isPlainObject: lw, isUndefined: nw, isDate: cw, isFile: uw, isBlob: hw, isRegExp: Sw, isFunction: sw, isStream: e => aw(e) && sw(e.pipe), isURLSearchParams: fw, isTypedArray: vw, isFileList: dw, forEach: pw, merge: function e() { const { caseless: t } = yw(this) && this || {}, n = {}, r = (r, i) => { const s = t && mw(n, i) || i; lw(n[s]) && lw(r) ? n[s] = e(n[s], r) : lw(r) ? n[s] = e({}, r) : tw(r) ? n[s] = r.slice() : n[s] = r }; for (let i = 0, s = arguments.length; i < s; i++)arguments[i] && pw(arguments[i], r); return n }, extend: function (e, t, n) { let { allOwnKeys: r } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return pw(t, ((t, r) => { n && sw(t) ? e[r] = Wv(t, n) : e[r] = t }), { allOwnKeys: r }), e }, trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, toFlatObject: (e, t, n, r) => { let i, s, o; const a = {}; if (t = t || {}, null == e) return t; do { for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0;)o = i[s], r && !r(o, e, t) || a[o] || (t[o] = e[o], a[o] = !0); e = !1 !== n && Xv(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: Yv, kindOfTest: Zv, endsWith: (e, t, n) => { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return -1 !== r && r === n }, toArray: e => { if (!e) return null; if (tw(e)) return e; let t = e.length; if (!ow(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, forEachEntry: (e, t) => { const n = (e && e[Symbol.iterator]).call(e); let r; for (; (r = n.next()) && !r.done;) { const n = r.value; t.call(e, n[0], n[1]) } }, matchAll: (e, t) => { let n; const r = []; for (; null !== (n = e.exec(t));)r.push(n); return r }, isHTMLForm: bw, hasOwnProperty: Ew, hasOwnProp: Ew, reduceDescriptors: _w, freezeMethods: e => { _w(e, ((t, n) => { if (sw(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1; const r = e[n]; sw(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") })) })) }, toObjectSet: (e, t) => { const n = {}, r = e => { e.forEach((e => { n[e] = !0 })) }; return tw(e) ? r(e) : r(String(e).split(t)), n }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function (e, t, n) { return t.toUpperCase() + n })), noop: () => { }, toFiniteNumber: (e, t) => (e = +e, Number.isFinite(e) ? e : t), findKey: mw, global: gw, isContextDefined: yw, ALPHABET: Tw, generateString: function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Tw.ALPHA_DIGIT, n = ""; const { length: r } = t; for (; e--;)n += t[Math.random() * r | 0]; return n }, isSpecCompliantForm: function (e) { return !!(e && sw(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator]) }, toJSONObject: e => { const t = new Array(10), n = (e, r) => { if (aw(e)) { if (t.indexOf(e) >= 0) return; if (!("toJSON" in e)) { t[r] = e; const i = tw(e) ? [] : {}; return pw(e, ((e, t) => { const s = n(e, r + 1); !nw(s) && (i[t] = s) })), t[r] = void 0, i } } return e }; return n(e, 0) }, isAsyncFn: kw, isThenable: e => e && (aw(e) || sw(e)) && sw(e.then) && sw(e.catch) }; function Nw(e, t, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i) } Cw.inherits(Nw, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Cw.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const Dw = Nw.prototype, Aw = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => { Aw[e] = { value: e } })), Object.defineProperties(Nw, Aw), Object.defineProperty(Dw, "isAxiosError", { value: !0 }), Nw.from = (e, t, n, r, i, s) => { const o = Object.create(Dw); return Cw.toFlatObject(e, o, (function (e) { return e !== Error.prototype }), (e => "isAxiosError" !== e)), Nw.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o }; const Ow = Nw; function Rw(e) { return Cw.isPlainObject(e) || Cw.isArray(e) } function Pw(e) { return Cw.endsWith(e, "[]") ? e.slice(0, -2) : e } function Lw(e, t, n) { return e ? e.concat(t).map((function (e, t) { return e = Pw(e), !n && t ? "[" + e + "]" : e })).join(n ? "." : "") : t } const Fw = Cw.toFlatObject(Cw, {}, null, (function (e) { return /^is[A-Z]/.test(e) })); const Mw = function (e, t, n) { if (!Cw.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const r = (n = Cw.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, (function (e, t) { return !Cw.isUndefined(t[e]) }))).metaTokens, i = n.visitor || c, s = n.dots, o = n.indexes, a = (n.Blob || "undefined" !== typeof Blob && Blob) && Cw.isSpecCompliantForm(t); if (!Cw.isFunction(i)) throw new TypeError("visitor must be a function"); function l(e) { if (null === e) return ""; if (Cw.isDate(e)) return e.toISOString(); if (!a && Cw.isBlob(e)) throw new Ow("Blob is not supported. Use a Buffer instead."); return Cw.isArrayBuffer(e) || Cw.isTypedArray(e) ? a && "function" === typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, n, i) { let a = e; if (e && !i && "object" === typeof e) if (Cw.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e); else if (Cw.isArray(e) && function (e) { return Cw.isArray(e) && !e.some(Rw) }(e) || (Cw.isFileList(e) || Cw.endsWith(n, "[]")) && (a = Cw.toArray(e))) return n = Pw(n), a.forEach((function (e, r) { !Cw.isUndefined(e) && null !== e && t.append(!0 === o ? Lw([n], r, s) : null === o ? n : n + "[]", l(e)) })), !1; return !!Rw(e) || (t.append(Lw(i, n, s), l(e)), !1) } const u = [], h = Object.assign(Fw, { defaultVisitor: c, convertValue: l, isVisitable: Rw }); if (!Cw.isObject(e)) throw new TypeError("data must be an object"); return function e(n, r) { if (!Cw.isUndefined(n)) { if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join(".")); u.push(n), Cw.forEach(n, (function (n, s) { !0 === (!(Cw.isUndefined(n) || null === n) && i.call(t, n, Cw.isString(s) ? s.trim() : s, r, h)) && e(n, r ? r.concat(s) : [s]) })), u.pop() } }(e), t }; function jw(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function (e) { return t[e] })) } function Vw(e, t) { this._pairs = [], e && Mw(e, this, t) } const Bw = Vw.prototype; Bw.append = function (e, t) { this._pairs.push([e, t]) }, Bw.toString = function (e) { const t = e ? function (t) { return e.call(this, t, jw) } : jw; return this._pairs.map((function (e) { return t(e[0]) + "=" + t(e[1]) }), "").join("&") }; const Uw = Vw; function zw(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function qw(e, t, n) { if (!t) return e; const r = n && n.encode || zw, i = n && n.serialize; let s; if (s = i ? i(t, n) : Cw.isURLSearchParams(t) ? t.toString() : new Uw(t, n).toString(r), s) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + s } return e } const Kw = class { constructor() { this.handlers = [] } use(e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { Cw.forEach(this.handlers, (function (t) { null !== t && e(t) })) } }, Gw = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Hw = { isBrowser: !0, classes: { URLSearchParams: "undefined" !== typeof URLSearchParams ? URLSearchParams : Uw, FormData: "undefined" !== typeof FormData ? FormData : null, Blob: "undefined" !== typeof Blob ? Blob : null }, isStandardBrowserEnv: (() => { let e; return ("undefined" === typeof navigator || "ReactNative" !== (e = navigator.product) && "NativeScript" !== e && "NS" !== e) && ("undefined" !== typeof window && "undefined" !== typeof document) })(), isStandardBrowserWebWorkerEnv: "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" === typeof self.importScripts, protocols: ["http", "https", "file", "blob", "url", "data"] }; const Qw = function (e) { function t(e, n, r, i) { let s = e[i++]; const o = Number.isFinite(+s), a = i >= e.length; if (s = !s && Cw.isArray(r) ? r.length : s, a) return Cw.hasOwnProp(r, s) ? r[s] = [r[s], n] : r[s] = n, !o; r[s] && Cw.isObject(r[s]) || (r[s] = []); return t(e, n, r[s], i) && Cw.isArray(r[s]) && (r[s] = function (e) { const t = {}, n = Object.keys(e); let r; const i = n.length; let s; for (r = 0; r < i; r++)s = n[r], t[s] = e[s]; return t }(r[s])), !o } if (Cw.isFormData(e) && Cw.isFunction(e.entries)) { const n = {}; return Cw.forEachEntry(e, ((e, r) => { t(function (e) { return Cw.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0])) }(e), r, n, 0) })), n } return null }; const Ww = { transitional: Gw, adapter: ["xhr", "http"], transformRequest: [function (e, t) { const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, i = Cw.isObject(e); i && Cw.isHTMLForm(e) && (e = new FormData(e)); if (Cw.isFormData(e)) return r && r ? JSON.stringify(Qw(e)) : e; if (Cw.isArrayBuffer(e) || Cw.isBuffer(e) || Cw.isStream(e) || Cw.isFile(e) || Cw.isBlob(e)) return e; if (Cw.isArrayBufferView(e)) return e.buffer; if (Cw.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let s; if (i) { if (n.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return Mw(e, new Hw.classes.URLSearchParams, Object.assign({ visitor: function (e, t, n, r) { return Hw.isNode && Cw.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) } }, t)) }(e, this.formSerializer).toString(); if ((s = Cw.isFileList(e)) || n.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return Mw(s ? { "files[]": e } : e, t && new t, this.formSerializer) } } return i || r ? (t.setContentType("application/json", !1), function (e, t, n) { if (Cw.isString(e)) try { return (t || JSON.parse)(e), Cw.trim(e) } catch (r) { if ("SyntaxError" !== r.name) throw r } return (n || JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || Ww.transitional, n = t && t.forcedJSONParsing, r = "json" === this.responseType; if (e && Cw.isString(e) && (n && !this.responseType || r)) { const n = !(t && t.silentJSONParsing) && r; try { return JSON.parse(e) } catch (i) { if (n) { if ("SyntaxError" === i.name) throw Ow.from(i, Ow.ERR_BAD_RESPONSE, this, null, this.response); throw i } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Hw.classes.FormData, Blob: Hw.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; Cw.forEach(["delete", "get", "head", "post", "put", "patch"], (e => { Ww.headers[e] = {} })); const $w = Ww, Xw = Cw.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Yw = Symbol("internals"); function Jw(e) { return e && String(e).trim().toLowerCase() } function Zw(e) { return !1 === e || null == e ? e : Cw.isArray(e) ? e.map(Zw) : String(e) } function eb(e, t, n, r, i) { return Cw.isFunction(r) ? r.call(this, t, n) : (i && (t = n), Cw.isString(t) ? Cw.isString(r) ? -1 !== t.indexOf(r) : Cw.isRegExp(r) ? r.test(t) : void 0 : void 0) } class tb { constructor(e) { e && this.set(e) } set(e, t, n) { const r = this; function i(e, t, n) { const i = Jw(t); if (!i) throw new Error("header name must be a non-empty string"); const s = Cw.findKey(r, i); (!s || void 0 === r[s] || !0 === n || void 0 === n && !1 !== r[s]) && (r[s || t] = Zw(e)) } const s = (e, t) => Cw.forEach(e, ((e, n) => i(e, n, t))); return Cw.isPlainObject(e) || e instanceof this.constructor ? s(e, t) : Cw.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()) ? s((e => { const t = {}; let n, r, i; return e && e.split("\n").forEach((function (e) { i = e.indexOf(":"), n = e.substring(0, i).trim().toLowerCase(), r = e.substring(i + 1).trim(), !n || t[n] && Xw[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) })), t })(e), t) : null != e && i(t, e, n), this } get(e, t) { if (e = Jw(e)) { const n = Cw.findKey(this, e); if (n) { const e = this[n]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t }(e); if (Cw.isFunction(t)) return t.call(this, e, n); if (Cw.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = Jw(e)) { const n = Cw.findKey(this, e); return !(!n || void 0 === this[n] || t && !eb(0, this[n], n, t)) } return !1 } delete(e, t) { const n = this; let r = !1; function i(e) { if (e = Jw(e)) { const i = Cw.findKey(n, e); !i || t && !eb(0, n[i], i, t) || (delete n[i], r = !0) } } return Cw.isArray(e) ? e.forEach(i) : i(e), r } clear(e) { const t = Object.keys(this); let n = t.length, r = !1; for (; n--;) { const i = t[n]; e && !eb(0, this[i], i, e, !0) || (delete this[i], r = !0) } return r } normalize(e) { const t = this, n = {}; return Cw.forEach(this, ((r, i) => { const s = Cw.findKey(n, i); if (s) return t[s] = Zw(r), void delete t[i]; const o = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e, t, n) => t.toUpperCase() + n)) }(i) : String(i).trim(); o !== i && delete t[i], t[o] = Zw(r), n[o] = !0 })), this } concat() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return this.constructor.concat(this, ...t) } toJSON(e) { const t = Object.create(null); return Cw.forEach(this, ((n, r) => { null != n && !1 !== n && (t[r] = e && Cw.isArray(n) ? n.join(", ") : n) })), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map((e => { let [t, n] = e; return t + ": " + n })).join("\n") } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e) { const t = new this(e); for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; return r.forEach((e => t.set(e))), t } static accessor(e) { const t = (this[Yw] = this[Yw] = { accessors: {} }).accessors, n = this.prototype; function r(e) { const r = Jw(e); t[r] || (!function (e, t) { const n = Cw.toCamelCase(" " + t);["get", "set", "has"].forEach((r => { Object.defineProperty(e, r + n, { value: function (e, n, i) { return this[r].call(this, t, e, n, i) }, configurable: !0 }) })) }(n, e), t[r] = !0) } return Cw.isArray(e) ? e.forEach(r) : r(e), this } } tb.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Cw.reduceDescriptors(tb.prototype, ((e, t) => { let { value: n } = e, r = t[0].toUpperCase() + t.slice(1); return { get: () => n, set(e) { this[r] = e } } })), Cw.freezeMethods(tb); const nb = tb; function rb(e, t) { const n = this || $w, r = t || n, i = nb.from(r.headers); let s = r.data; return Cw.forEach(e, (function (e) { s = e.call(n, s, i.normalize(), t ? t.status : void 0) })), i.normalize(), s } function ib(e) { return !(!e || !e.__CANCEL__) } function sb(e, t, n) { Ow.call(this, null == e ? "canceled" : e, Ow.ERR_CANCELED, t, n), this.name = "CanceledError" } Cw.inherits(sb, Ow, { __CANCEL__: !0 }); const ob = sb; const ab = Hw.isStandardBrowserEnv ? { write: function (e, t, n, r, i, s) { const o = []; o.push(e + "=" + encodeURIComponent(t)), Cw.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), Cw.isString(r) && o.push("path=" + r), Cw.isString(i) && o.push("domain=" + i), !0 === s && o.push("secure"), document.cookie = o.join("; ") }, read: function (e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove: function (e) { this.write(e, "", Date.now() - 864e5) } } : { write: function () { }, read: function () { return null }, remove: function () { } }; function lb(e, t) { return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function (e, t) { return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const cb = Hw.isStandardBrowserEnv ? function () { const e = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a"); let n; function r(n) { let r = n; return e && (t.setAttribute("href", r), r = t.href), t.setAttribute("href", r), { href: t.href, protocol: t.protocol ? t.protocol.replace(/:$/, "") : "", host: t.host, search: t.search ? t.search.replace(/^\?/, "") : "", hash: t.hash ? t.hash.replace(/^#/, "") : "", hostname: t.hostname, port: t.port, pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname } } return n = r(window.location.href), function (e) { const t = Cw.isString(e) ? r(e) : e; return t.protocol === n.protocol && t.host === n.host } }() : function () { return !0 }; const ub = function (e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let i, s = 0, o = 0; return t = void 0 !== t ? t : 1e3, function (a) { const l = Date.now(), c = r[o]; i || (i = l), n[s] = a, r[s] = l; let u = o, h = 0; for (; u !== s;)h += n[u++], u %= e; if (s = (s + 1) % e, s === o && (o = (o + 1) % e), l - i < t) return; const d = c && l - c; return d ? Math.round(1e3 * h / d) : void 0 } }; function hb(e, t) { let n = 0; const r = ub(50, 250); return i => { const s = i.loaded, o = i.lengthComputable ? i.total : void 0, a = s - n, l = r(a); n = s; const c = { loaded: s, total: o, progress: o ? s / o : void 0, bytes: a, rate: l || void 0, estimated: l && o && s <= o ? (o - s) / l : void 0, event: i }; c[t ? "download" : "upload"] = !0, e(c) } } const db = { http: null, xhr: "undefined" !== typeof XMLHttpRequest && function (e) { return new Promise((function (t, n) { let r = e.data; const i = nb.from(e.headers).normalize(), s = e.responseType; let o, a; function l() { e.cancelToken && e.cancelToken.unsubscribe(o), e.signal && e.signal.removeEventListener("abort", o) } Cw.isFormData(r) && (Hw.isStandardBrowserEnv || Hw.isStandardBrowserWebWorkerEnv ? i.setContentType(!1) : i.getContentType(/^\s*multipart\/form-data/) ? Cw.isString(a = i.getContentType()) && i.setContentType(a.replace(/^\s*(multipart\/form-data);+/, "$1")) : i.setContentType("multipart/form-data")); let c = new XMLHttpRequest; if (e.auth) { const t = e.auth.username || "", n = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : ""; i.set("Authorization", "Basic " + btoa(t + ":" + n)) } const u = lb(e.baseURL, e.url); function h() { if (!c) return; const r = nb.from("getAllResponseHeaders" in c && c.getAllResponseHeaders()); !function (e, t, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? t(new Ow("Request failed with status code " + n.status, [Ow.ERR_BAD_REQUEST, Ow.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) }((function (e) { t(e), l() }), (function (e) { n(e), l() }), { data: s && "text" !== s && "json" !== s ? c.response : c.responseText, status: c.status, statusText: c.statusText, headers: r, config: e, request: c }), c = null } if (c.open(e.method.toUpperCase(), qw(u, e.params, e.paramsSerializer), !0), c.timeout = e.timeout, "onloadend" in c ? c.onloadend = h : c.onreadystatechange = function () { c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf("file:")) && setTimeout(h) }, c.onabort = function () { c && (n(new Ow("Request aborted", Ow.ECONNABORTED, e, c)), c = null) }, c.onerror = function () { n(new Ow("Network Error", Ow.ERR_NETWORK, e, c)), c = null }, c.ontimeout = function () { let t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded"; const r = e.transitional || Gw; e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(new Ow(t, r.clarifyTimeoutError ? Ow.ETIMEDOUT : Ow.ECONNABORTED, e, c)), c = null }, Hw.isStandardBrowserEnv) { const t = cb(u) && e.xsrfCookieName && ab.read(e.xsrfCookieName); t && i.set(e.xsrfHeaderName, t) } void 0 === r && i.setContentType(null), "setRequestHeader" in c && Cw.forEach(i.toJSON(), (function (e, t) { c.setRequestHeader(t, e) })), Cw.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), s && "json" !== s && (c.responseType = e.responseType), "function" === typeof e.onDownloadProgress && c.addEventListener("progress", hb(e.onDownloadProgress, !0)), "function" === typeof e.onUploadProgress && c.upload && c.upload.addEventListener("progress", hb(e.onUploadProgress)), (e.cancelToken || e.signal) && (o = t => { c && (n(!t || t.type ? new ob(null, e, c) : t), c.abort(), c = null) }, e.cancelToken && e.cancelToken.subscribe(o), e.signal && (e.signal.aborted ? o() : e.signal.addEventListener("abort", o))); const d = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(u); d && -1 === Hw.protocols.indexOf(d) ? n(new Ow("Unsupported protocol " + d + ":", Ow.ERR_BAD_REQUEST, e)) : c.send(r || null) })) } }; Cw.forEach(db, ((e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (n) { } Object.defineProperty(e, "adapterName", { value: t }) } })); const fb = e => "- ".concat(e), pb = e => Cw.isFunction(e) || null === e || !1 === e, mb = e => { e = Cw.isArray(e) ? e : [e]; const { length: t } = e; let n, r; const i = {}; for (let s = 0; s < t; s++) { let t; if (n = e[s], r = n, !pb(n) && (r = db[(t = String(n)).toLowerCase()], void 0 === r)) throw new Ow("Unknown adapter '".concat(t, "'")); if (r) break; i[t || "#" + s] = r } if (!r) { const e = Object.entries(i).map((e => { let [t, n] = e; return "adapter ".concat(t, " ") + (!1 === n ? "is not supported by the environment" : "is not available in the build") })); let n = t ? e.length > 1 ? "since :\n" + e.map(fb).join("\n") : " " + fb(e[0]) : "as no adapter specified"; throw new Ow("There is no suitable adapter to dispatch the request " + n, "ERR_NOT_SUPPORT") } return r }; function gb(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new ob(null, e) } function yb(e) { gb(e), e.headers = nb.from(e.headers), e.data = rb.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1); return mb(e.adapter || $w.adapter)(e).then((function (t) { return gb(e), t.data = rb.call(e, e.transformResponse, t), t.headers = nb.from(t.headers), t }), (function (t) { return ib(t) || (gb(e), t && t.response && (t.response.data = rb.call(e, e.transformResponse, t.response), t.response.headers = nb.from(t.response.headers))), Promise.reject(t) })) } const vb = e => e instanceof nb ? e.toJSON() : e; function wb(e, t) { t = t || {}; const n = {}; function r(e, t, n) { return Cw.isPlainObject(e) && Cw.isPlainObject(t) ? Cw.merge.call({ caseless: n }, e, t) : Cw.isPlainObject(t) ? Cw.merge({}, t) : Cw.isArray(t) ? t.slice() : t } function i(e, t, n) { return Cw.isUndefined(t) ? Cw.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n) } function s(e, t) { if (!Cw.isUndefined(t)) return r(void 0, t) } function o(e, t) { return Cw.isUndefined(t) ? Cw.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t) } function a(n, i, s) { return s in t ? r(n, i) : s in e ? r(void 0, n) : void 0 } const l = { url: s, method: s, data: s, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (e, t) => i(vb(e), vb(t), !0) }; return Cw.forEach(Object.keys(Object.assign({}, e, t)), (function (r) { const s = l[r] || i, o = s(e[r], t[r], r); Cw.isUndefined(o) && s !== a || (n[r] = o) })), n } const bb = "1.6.0", Eb = {};["object", "boolean", "number", "function", "string", "symbol"].forEach(((e, t) => { Eb[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } })); const Sb = {}; Eb.transitional = function (e, t, n) { function r(e, t) { return "[Axios v1.6.0] Transitional option '" + e + "'" + t + (n ? ". " + n : "") } return (n, i, s) => { if (!1 === e) throw new Ow(r(i, " has been removed" + (t ? " in " + t : "")), Ow.ERR_DEPRECATED); return t && !Sb[i] && (Sb[i] = !0, console.warn(r(i, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, i, s) } }; const _b = { assertOptions: function (e, t, n) { if ("object" !== typeof e) throw new Ow("options must be an object", Ow.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let i = r.length; for (; i-- > 0;) { const s = r[i], o = t[s]; if (o) { const t = e[s], n = void 0 === t || o(t, s, e); if (!0 !== n) throw new Ow("option " + s + " must be " + n, Ow.ERR_BAD_OPTION_VALUE) } else if (!0 !== n) throw new Ow("Unknown option " + s, Ow.ERR_BAD_OPTION) } }, validators: Eb }, xb = _b.validators; class Ib { constructor(e) { this.defaults = e, this.interceptors = { request: new Kw, response: new Kw } } request(e, t) { "string" === typeof e ? (t = t || {}).url = e : t = e || {}, t = wb(this.defaults, t); const { transitional: n, paramsSerializer: r, headers: i } = t; void 0 !== n && _b.assertOptions(n, { silentJSONParsing: xb.transitional(xb.boolean), forcedJSONParsing: xb.transitional(xb.boolean), clarifyTimeoutError: xb.transitional(xb.boolean) }, !1), null != r && (Cw.isFunction(r) ? t.paramsSerializer = { serialize: r } : _b.assertOptions(r, { encode: xb.function, serialize: xb.function }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let s = i && Cw.merge(i.common, i[t.method]); i && Cw.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => { delete i[e] })), t.headers = nb.concat(s, i); const o = []; let a = !0; this.interceptors.request.forEach((function (e) { "function" === typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, o.unshift(e.fulfilled, e.rejected)) })); const l = []; let c; this.interceptors.response.forEach((function (e) { l.push(e.fulfilled, e.rejected) })); let u, h = 0; if (!a) { const e = [yb.bind(this), void 0]; for (e.unshift.apply(e, o), e.push.apply(e, l), u = e.length, c = Promise.resolve(t); h < u;)c = c.then(e[h++], e[h++]); return c } u = o.length; let d = t; for (h = 0; h < u;) { const e = o[h++], t = o[h++]; try { d = e(d) } catch (f) { t.call(this, f); break } } try { c = yb.call(this, d) } catch (f) { return Promise.reject(f) } for (h = 0, u = l.length; h < u;)c = c.then(l[h++], l[h++]); return c } getUri(e) { return qw(lb((e = wb(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer) } } Cw.forEach(["delete", "get", "head", "options"], (function (e) { Ib.prototype[e] = function (t, n) { return this.request(wb(n || {}, { method: e, url: t, data: (n || {}).data })) } })), Cw.forEach(["post", "put", "patch"], (function (e) { function t(t) { return function (n, r, i) { return this.request(wb(i || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r })) } } Ib.prototype[e] = t(), Ib.prototype[e + "Form"] = t(!0) })); const Tb = Ib; class kb { constructor(e) { if ("function" !== typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise((function (e) { t = e })); const n = this; this.promise.then((e => { if (!n._listeners) return; let t = n._listeners.length; for (; t-- > 0;)n._listeners[t](e); n._listeners = null })), this.promise.then = e => { let t; const r = new Promise((e => { n.subscribe(e), t = e })).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e((function (e, r, i) { n.reason || (n.reason = new ob(e, r, i), t(n.reason)) })) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } static source() { let e; return { token: new kb((function (t) { e = t })), cancel: e } } } const Cb = kb; const Nb = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Nb).forEach((e => { let [t, n] = e; Nb[n] = t })); const Db = Nb; const Ab = function e(t) { const n = new Tb(t), r = Wv(Tb.prototype.request, n); return Cw.extend(r, Tb.prototype, n, { allOwnKeys: !0 }), Cw.extend(r, n, null, { allOwnKeys: !0 }), r.create = function (n) { return e(wb(t, n)) }, r }($w); Ab.Axios = Tb, Ab.CanceledError = ob, Ab.CancelToken = Cb, Ab.isCancel = ib, Ab.VERSION = bb, Ab.toFormData = Mw, Ab.AxiosError = Ow, Ab.Cancel = Ab.CanceledError, Ab.all = function (e) { return Promise.all(e) }, Ab.spread = function (e) { return function (t) { return e.apply(null, t) } }, Ab.isAxiosError = function (e) { return Cw.isObject(e) && !0 === e.isAxiosError }, Ab.mergeConfig = wb, Ab.AxiosHeaders = nb, Ab.formToJSON = e => Qw(Cw.isHTMLForm(e) ? new FormData(e) : e), Ab.getAdapter = mb, Ab.HttpStatusCode = Db, Ab.default = Ab; Ab.create({ baseURL: "http://127.0.0.1:5001/blogging-website-3c10f/us-central1/app" }); const Ob = () => { const e = document.querySelector(".title"), t = document.querySelector(".article"), n = (document.querySelector("#banner-upload"), document.querySelector(".banner")); let r; const i = document.querySelector(".publish-btn"), s = (document.querySelector("#image-upload"), (e, t) => { console.log("This is image", e); const [i] = e.files; if (console.log("This is file", i), i && i.type.includes("image")) { const e = new FormData; e.append("image", i), console.log("This is formdata", e), fetch("http://127.0.0.1:5001/blogging-website-3c10f/us-central1/app/upload", { method: "post", body: e }).then((e => (console.log("This is res", e), e.json()))).then((e => { "image" === t ? o(e, i.name) : (r = "".concat(window.location.origin, "/").concat(e), n.style.backgroundImage = 'url("'.concat(r, '")')) })) } else alert("Upload Image only") }), o = (e, n) => { let r = t.selectionStart, i = "\r![".concat(n, "](").concat(e, ")\r"); t.value = t.value.slice(0, r) + i + t.value.slice(r) }; return document.addEventListener("DOMContentLoaded", (() => { i.addEventListener("click", (() => { if (t.value.length && e.value.length) { let n = "abcdefghijklmnopqrstuvwxyz", i = e.value.split(" ").join("-"), s = ""; for (let e = 0; e < 4; e++)s += n[Math.floor(Math.random() * n.length)]; let o = "".concat(i, "=").concat(s), a = new Date, l = new Array(a.getDate(), a.getMonth(), a.getFullYear()); Dv.collection("blogs").doc(o).set({ title: e.value, article: t.value, bannerImage: r, publishedAt_date: l[0], publishedAt_month: l[1], publishedAt_year: l[2] }).then((() => { window.location.href = "/".concat(o) })).catch((e => { console.log(e) })) } })) })), (0, ce.jsxs)("div", { children: [(0, ce.jsxs)("div", { className: "banner", children: [(0, ce.jsx)("input", { type: "file", accept: "image/*", id: "banner-upload", onChange: () => { s(document.querySelector("#banner-upload"), "banner") }, hidden: !0 }), (0, ce.jsx)("label", { htmlFor: "banner-upload", className: "banner-upload-btn", children: (0, ce.jsx)("img", { src: "https://th.bing.com/th/id/R.b8b98667496dff6c2a04d8dc98a28e10?rik=6AIhuGRS%2fa0JVg&riu=http%3a%2f%2fcdn.onlinewebfonts.com%2fsvg%2fimg_523458.png&ehk=MsOIuGWZGtuXqB7IAkYDqbWHnc%2bb300R7Z7B5q05f4A%3d&risl=&pid=ImgRaw&r=0", alt: "upload your banner" }) })] }), (0, ce.jsxs)("div", { className: "blog w-70", children: [(0, ce.jsx)("textarea", { type: "text", className: "title", placeholder: "Blog title..." }), (0, ce.jsx)("textarea", { type: "text", className: "article", placeholder: "Start Writing here..." })] }), (0, ce.jsxs)("div", { className: "blog-options", children: [(0, ce.jsx)("button", { className: "btn dark publish-btn", children: "Publish" }), (0, ce.jsx)("input", { type: "file", accept: "image/*", id: "image-upload", onChange: () => { s(document.querySelector("#image-upload"), "image") }, hidden: !0 }), (0, ce.jsx)("label", { htmlFor: "image-upload", className: "btn grey upload-btn", children: "Upload Image" })] })] }) }; const Rb = function () { return (0, ce.jsx)(oe, { children: (0, ce.jsxs)(re, { children: [(0, ce.jsx)(te, { path: "/", Component: () => (0, ce.jsx)(t.Fragment, { children: (0, ce.jsx)(Hv, {}) }) }), (0, ce.jsx)(te, { path: "/editor", Component: () => (0, ce.jsxs)(t.Fragment, { children: [(0, ce.jsx)(ue, {}), (0, ce.jsx)(Ob, {}), (0, ce.jsx)(Gv, {})] }) }), (0, ce.jsx)(te, { path: "/:blog", Component: () => (0, ce.jsxs)(t.Fragment, { children: [(0, ce.jsx)(ue, {}), (0, ce.jsx)(Qv, {}), (0, ce.jsx)(Gv, {})] }) })] }) }) }; i.createRoot(document.getElementById("root")).render((0, ce.jsx)(Rb, {})), s() })() })();
//# sourceMappingURL=main.8f581b25.js.map